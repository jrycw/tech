[
  {
    "objectID": "posts/marimo-gt-time-machine/20250626.html",
    "href": "posts/marimo-gt-time-machine/20250626.html",
    "title": "Time Machine for Great Tables in marimo",
    "section": "",
    "text": "This post demonstrates how to build a “time machine” that lets you easily navigate through different stages of table construction using Great Tables in a marimo notebook."
  },
  {
    "objectID": "posts/marimo-gt-time-machine/20250626.html#building-the-time-machine-core",
    "href": "posts/marimo-gt-time-machine/20250626.html#building-the-time-machine-core",
    "title": "Time Machine for Great Tables in marimo",
    "section": "Building the Time Machine Core",
    "text": "Building the Time Machine Core\n\n\n\n\n\n\nGive It a Sec – WASM Magic Happening\n\n\n\nThe widgets may take a few moments to load, as they rely on WebAssembly under the hood.\n\n\nThe goal is to create a WigGT object that behaves like a GT object from Great Tables. As we progressively build the table, we maintain two versions:\n\nThe original (non-interactive) table\nAn interactive version that includes a marimo widget (in this case, a slider)\n\nThis setup allows us to move back and forth through the table-building steps and see how each method transforms the output — effectively creating a table “time machine.”\nLet’s break it down.\n\n    \n    \n    \n    import%20marimo%20as%20mo%0Aimport%20copy%0Aimport%20inspect%0Afrom%20functools%20import%20wraps%0Afrom%20typing%20import%20Callable%2C%20Self%0A%0Aimport%20pandas%20as%20pd%0Afrom%20great_tables%20import%20GT%2C%20html%0Afrom%20great_tables.data%20import%20airquality\n\n\nGetting the Allowed Method Names\nFirst, we need a list of Great Tables methods that should be wrapped and recorded. For now, this list is constructed manually, but ideally, Great Tables could expose this for easier third-party use.\ndef get_allowed_member_names() -&gt; list[str]:\n    return [\"fmt\", \"fmt_number\", ...]\n\n    \n    \n    \n    def%20get_allowed_member_names()%20-%3E%20list%5Bstr%5D%3A%0A%20%20%20%20return%20%5B%0A%20%20%20%20%20%20%20%20%22fmt%22%2C%0A%20%20%20%20%20%20%20%20%22fmt_number%22%2C%0A%20%20%20%20%20%20%20%20%22fmt_integer%22%2C%0A%20%20%20%20%20%20%20%20%22fmt_percent%22%2C%0A%20%20%20%20%20%20%20%20%22fmt_scientific%22%2C%0A%20%20%20%20%20%20%20%20%22fmt_currency%22%2C%0A%20%20%20%20%20%20%20%20%22fmt_bytes%22%2C%0A%20%20%20%20%20%20%20%20%22fmt_roman%22%2C%0A%20%20%20%20%20%20%20%20%22fmt_date%22%2C%0A%20%20%20%20%20%20%20%20%22fmt_time%22%2C%0A%20%20%20%20%20%20%20%20%22fmt_datetime%22%2C%0A%20%20%20%20%20%20%20%20%22fmt_markdown%22%2C%0A%20%20%20%20%20%20%20%20%22fmt_image%22%2C%0A%20%20%20%20%20%20%20%20%22fmt_icon%22%2C%0A%20%20%20%20%20%20%20%20%22fmt_flag%22%2C%0A%20%20%20%20%20%20%20%20%22fmt_units%22%2C%0A%20%20%20%20%20%20%20%20%22fmt_nanoplot%22%2C%0A%20%20%20%20%20%20%20%20%22data_color%22%2C%0A%20%20%20%20%20%20%20%20%22sub_missing%22%2C%0A%20%20%20%20%20%20%20%20%22sub_zero%22%2C%0A%20%20%20%20%20%20%20%20%22opt_stylize%22%2C%0A%20%20%20%20%20%20%20%20%22opt_align_table_header%22%2C%0A%20%20%20%20%20%20%20%20%22opt_all_caps%22%2C%0A%20%20%20%20%20%20%20%20%22opt_footnote_marks%22%2C%0A%20%20%20%20%20%20%20%20%22opt_row_striping%22%2C%0A%20%20%20%20%20%20%20%20%22opt_vertical_padding%22%2C%0A%20%20%20%20%20%20%20%20%22opt_horizontal_padding%22%2C%0A%20%20%20%20%20%20%20%20%22opt_table_outline%22%2C%0A%20%20%20%20%20%20%20%20%22opt_table_font%22%2C%0A%20%20%20%20%20%20%20%20%22cols_align%22%2C%0A%20%20%20%20%20%20%20%20%22cols_width%22%2C%0A%20%20%20%20%20%20%20%20%22cols_label%22%2C%0A%20%20%20%20%20%20%20%20%22cols_move%22%2C%0A%20%20%20%20%20%20%20%20%22cols_move_to_start%22%2C%0A%20%20%20%20%20%20%20%20%22cols_move_to_end%22%2C%0A%20%20%20%20%20%20%20%20%22cols_hide%22%2C%0A%20%20%20%20%20%20%20%20%22cols_unhide%22%2C%0A%20%20%20%20%20%20%20%20%22tab_header%22%2C%0A%20%20%20%20%20%20%20%20%22tab_source_note%22%2C%0A%20%20%20%20%20%20%20%20%22tab_spanner%22%2C%0A%20%20%20%20%20%20%20%20%22tab_stubhead%22%2C%0A%20%20%20%20%20%20%20%20%22tab_style%22%2C%0A%20%20%20%20%20%20%20%20%22tab_options%22%2C%0A%20%20%20%20%20%20%20%20%22row_group_order%22%2C%0A%20%20%20%20%20%20%20%20%22tab_stub%22%2C%0A%20%20%20%20%20%20%20%20%22with_id%22%2C%0A%20%20%20%20%20%20%20%20%22with_locale%22%2C%0A%20%20%20%20%20%20%20%20%22save%22%2C%0A%20%20%20%20%20%20%20%20%22show%22%2C%0A%20%20%20%20%20%20%20%20%22as_raw_html%22%2C%0A%20%20%20%20%20%20%20%20%22write_raw_html%22%2C%0A%20%20%20%20%20%20%20%20%22as_latex%22%2C%0A%20%20%20%20%20%20%20%20%22pipe%22%2C%0A%20%20%20%20%5D\n\n\n\nThe lazify Decorator\nThe lazify decorator wraps each method call and stores it in a pipeline. This allows us to defer execution until we’re ready to materialize the final table using .collect(). Only the selected methods from Great Tables will be decorated.\ndef lazify(cls: GT) -&gt; GT:\n    def add_to_pipeline(func: Callable[..., GT]) -&gt; callable:\n        @wraps(func)\n        def wrapper(self, *args, **kwargs):\n            def inner(self):\n                return func(self, *args, **kwargs)\n\n            # container for storing callable objects\n            self._pipeline.append(inner)\n            return self\n\n        wrapper.__signature__ = inspect.signature(func)\n        return wrapper\n\n    for member_name in get_allowed_member_names():\n        setattr(cls, member_name, add_to_pipeline(getattr(GT, member_name)))\n    return cls\n\n    \n    \n    \n    def%20lazify(cls%3A%20GT)%20-%3E%20GT%3A%0A%20%20%20%20def%20add_to_pipeline(func%3A%20Callable%5B...%2C%20GT%5D)%20-%3E%20callable%3A%0A%20%20%20%20%20%20%20%20%40wraps(func)%0A%20%20%20%20%20%20%20%20def%20wrapper(self%2C%20*args%2C%20**kwargs)%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20def%20inner(self)%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20func(self%2C%20*args%2C%20**kwargs)%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%23%20container%20for%20storing%20callable%20objects%0A%20%20%20%20%20%20%20%20%20%20%20%20self._pipeline.append(inner)%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20self%0A%0A%20%20%20%20%20%20%20%20wrapper.__signature__%20%3D%20inspect.signature(func)%0A%20%20%20%20%20%20%20%20return%20wrapper%0A%0A%20%20%20%20for%20member_name%20in%20get_allowed_member_names()%3A%0A%20%20%20%20%20%20%20%20setattr(%0A%20%20%20%20%20%20%20%20%20%20%20%20cls%2C%20member_name%2C%20add_to_pipeline(getattr(GT%2C%20member_name))%0A%20%20%20%20%20%20%20%20)%0A%20%20%20%20return%20cls\n\n\n\nDesigning the WigGT Class\nHere are the main ideas behind the design:\n\nOriginal tables are stored in self._tables, accessible via the .tables property.\nInteractive versions with embedded marimo widgets are stored in self._wtables. These aren’t exposed directly — interaction is done through the marimo UI.\nThe rendering method follows marimo’s convention, trying _display_, then _repr_html_, and finally _mime_, in that order.\n\nWith this setup, WigGT tracks the full transformation pipeline and allows easy replay of each step through a slider.\n@lazify\nclass WigGT:\n    def __init__(self, *args, widget, **kwargs):\n        self._args = args\n        self._widget = widget\n        self._kwargs = kwargs\n        self.set_to_init()\n\n    @property\n    def tables(self) -&gt; list[GT]:\n        return list(self._tables)  # return a new list\n\n    def _widgetify(self, obj: GT) -&gt; GT:\n        return obj.tab_source_note(html(self._widget))\n\n    def collect(self) -&gt; Self:\n        if not self._is_collect:\n            new_obj = self._tables[0]  # don't use self._wtables[0]\n            for f in self._pipeline:\n                new_obj = f(self=copy.copy(new_obj))\n                self._tables.append(new_obj)\n                self._wtables.append(self._widgetify(new_obj))\n            self._is_collect = True\n        return self\n\n    def _repr_html_(self) -&gt; str:\n        try:\n            obj = self._wtables[self._widget.value]\n        except IndexError:\n            obj = self._wtables[-1]\n\n        if hasattr(obj, \"_display_\"):\n            render_method = \"_display_\"\n        elif hasattr(obj, \"_repr_html_\"):\n            render_method = \"_repr_html_\"\n        elif hasattr(obj, \"_mime_\"):\n            render_method = \"_mime_\"\n        else:\n            raise AttributeError(\n                \"The object does not have a valid render method.\"\n            )\n        return getattr(obj, render_method)()  # remember to invoke\n\n    def set_to_init(self) -&gt; None:\n        if not getattr(self, \"_pipeline\", None):\n            self._pipeline: list[callable] = []\n        else:\n            self._pipeline.clear()\n\n        if not getattr(self, \"_tables\", None):\n            self._tables = []\n        else:\n            self._tables.clear()\n\n        if not getattr(self, \"_wtables\", None):\n            self._wtables = []\n        else:\n            self._wtables.clear()\n\n        obj = self._make_gt()\n        self._tables.append(obj)\n        self._wtables.append(self._widgetify(obj))\n        self._is_collect = False\n\n    def _make_gt(self) -&gt; GT:\n        return GT(*self._args, **self._kwargs)\n\n    \n    \n    \n    %40lazify%0Aclass%20WigGT%3A%0A%20%20%20%20def%20__init__(self%2C%20*args%2C%20widget%2C%20**kwargs)%3A%0A%20%20%20%20%20%20%20%20self._args%20%3D%20args%0A%20%20%20%20%20%20%20%20self._widget%20%3D%20widget%0A%20%20%20%20%20%20%20%20self._kwargs%20%3D%20kwargs%0A%20%20%20%20%20%20%20%20self.set_to_init()%0A%0A%20%20%20%20%40property%0A%20%20%20%20def%20tables(self)%20-%3E%20list%5BGT%5D%3A%0A%20%20%20%20%20%20%20%20return%20list(self._tables)%20%20%23%20return%20a%20new%20list%0A%0A%20%20%20%20def%20_widgetify(self%2C%20obj%3A%20GT)%20-%3E%20GT%3A%0A%20%20%20%20%20%20%20%20return%20obj.tab_source_note(html(self._widget))%0A%0A%20%20%20%20def%20collect(self)%20-%3E%20Self%3A%0A%20%20%20%20%20%20%20%20if%20not%20self._is_collect%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20new_obj%20%3D%20self._tables%5B0%5D%20%20%23%20don't%20use%20self._wtables%5B0%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20for%20f%20in%20self._pipeline%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20new_obj%20%3D%20f(self%3Dcopy.copy(new_obj))%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20self._tables.append(new_obj)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20self._wtables.append(self._widgetify(new_obj))%0A%20%20%20%20%20%20%20%20%20%20%20%20self._is_collect%20%3D%20True%0A%20%20%20%20%20%20%20%20return%20self%0A%0A%20%20%20%20def%20_repr_html_(self)%20-%3E%20str%3A%0A%20%20%20%20%20%20%20%20try%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20obj%20%3D%20self._wtables%5Bself._widget.value%5D%0A%20%20%20%20%20%20%20%20except%20IndexError%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20obj%20%3D%20self._wtables%5B-1%5D%0A%0A%20%20%20%20%20%20%20%20if%20hasattr(obj%2C%20%22_display_%22)%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20render_method%20%3D%20%22_display_%22%0A%20%20%20%20%20%20%20%20elif%20hasattr(obj%2C%20%22_repr_html_%22)%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20render_method%20%3D%20%22_repr_html_%22%0A%20%20%20%20%20%20%20%20elif%20hasattr(obj%2C%20%22_mime_%22)%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20render_method%20%3D%20%22_mime_%22%0A%20%20%20%20%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20raise%20AttributeError(%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22The%20object%20does%20not%20have%20a%20valid%20render%20method.%22%0A%20%20%20%20%20%20%20%20%20%20%20%20)%0A%20%20%20%20%20%20%20%20return%20getattr(obj%2C%20render_method)()%20%20%23%20remember%20to%20invoke%0A%0A%20%20%20%20def%20set_to_init(self)%20-%3E%20None%3A%0A%20%20%20%20%20%20%20%20if%20not%20getattr(self%2C%20%22_pipeline%22%2C%20None)%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20self._pipeline%3A%20list%5Bcallable%5D%20%3D%20%5B%5D%0A%20%20%20%20%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20self._pipeline.clear()%0A%0A%20%20%20%20%20%20%20%20if%20not%20getattr(self%2C%20%22_tables%22%2C%20None)%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20self._tables%20%3D%20%5B%5D%0A%20%20%20%20%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20self._tables.clear()%0A%0A%20%20%20%20%20%20%20%20if%20not%20getattr(self%2C%20%22_wtables%22%2C%20None)%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20self._wtables%20%3D%20%5B%5D%0A%20%20%20%20%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20self._wtables.clear()%0A%0A%20%20%20%20%20%20%20%20obj%20%3D%20self._make_gt()%0A%20%20%20%20%20%20%20%20self._tables.append(obj)%0A%20%20%20%20%20%20%20%20self._wtables.append(self._widgetify(obj))%0A%20%20%20%20%20%20%20%20self._is_collect%20%3D%20False%0A%0A%20%20%20%20def%20_make_gt(self)%20-%3E%20GT%3A%0A%20%20%20%20%20%20%20%20return%20GT(*self._args%2C%20**self._kwargs)"
  },
  {
    "objectID": "posts/marimo-gt-time-machine/20250626.html#marimo",
    "href": "posts/marimo-gt-time-machine/20250626.html#marimo",
    "title": "Time Machine for Great Tables in marimo",
    "section": "marimo",
    "text": "marimo\nNow we’re ready to time travel through the table-building process!\n\nStep 1: Create a Slider to Navigate Table States\nWe begin by creating a slider that represents each step in the build pipeline.\n\nStep 0 is the original GT object.\nStep 1 applies the first method call, and so on.\n\n\n\n\n\n\n\nSlider Range Limitation\n\n\n\nBecause all method calls are deferred, we can’t determine the total number of steps ahead of time. This means the developer needs to manually specify a reasonable range for the slider. If the selected index exceeds the available range, the last table will be shown by default.\n\n\ntime_widget = mo.ui.slider(start=0, stop=6, step=1, value=0, label=\"Step\")\n\n    \n    \n    \n    time_widget%20%3D%20mo.ui.slider(start%3D0%2C%20stop%3D6%2C%20step%3D1%2C%20value%3D0%2C%20label%3D%22Step%22)\n\n\n\nStep 2: Build the Lazy Table Sequence\nNext, we use an example from the Great Tables documentation to create a lazy WigGT object. This will internally store each method call but won’t execute them just yet.\nYou’ll see a slider widget embedded in the table’s source note — but it won’t be functional until we finalize the process.\nlazy_wig_gt = (\n    WigGT(airquality.head(10).assign(Year=1973), widget=time_widget)\n    .opt_stylize(color=\"pink\", style=2)\n    .tab_header(\n        title=\"New York Air Quality Measurements\",\n        subtitle=\"Daily measurements in New York City (May 1-10, 1973)\",\n    )\n    .tab_spanner(label=\"Time\", columns=[\"Year\", \"Month\", \"Day\"])\n    .tab_spanner(\n        label=\"Measurement\", columns=[\"Ozone\", \"Solar_R\", \"Wind\", \"Temp\"]\n    )\n    .cols_move_to_start(columns=[\"Year\", \"Month\", \"Day\"])\n    .cols_label(\n        Ozone=html(\"Ozone,&lt;br&gt;ppbV\"),\n        Solar_R=html(\"Solar R.,&lt;br&gt;cal/m&lt;sup&gt;2&lt;/sup&gt;\"),\n        Wind=html(\"Wind,&lt;br&gt;mph\"),\n        Temp=html(\"Temp,&lt;br&gt;&deg;F\"),\n    )\n)\nlazy_wig_gt\n\n    \n    \n    \n    lazy_wig_gt%20%3D%20(%0A%20%20%20%20WigGT(airquality.head(10).assign(Year%3D1973)%2C%20widget%3Dtime_widget)%0A%20%20%20%20.opt_stylize(color%3D%22pink%22%2C%20style%3D2)%0A%20%20%20%20.tab_header(%0A%20%20%20%20%20%20%20%20title%3D%22New%20York%20Air%20Quality%20Measurements%22%2C%0A%20%20%20%20%20%20%20%20subtitle%3D%22Daily%20measurements%20in%20New%20York%20City%20(May%201-10%2C%201973)%22%2C%0A%20%20%20%20)%0A%20%20%20%20.tab_spanner(label%3D%22Time%22%2C%20columns%3D%5B%22Year%22%2C%20%22Month%22%2C%20%22Day%22%5D)%0A%20%20%20%20.tab_spanner(%0A%20%20%20%20%20%20%20%20label%3D%22Measurement%22%2C%20columns%3D%5B%22Ozone%22%2C%20%22Solar_R%22%2C%20%22Wind%22%2C%20%22Temp%22%5D%0A%20%20%20%20)%0A%20%20%20%20.cols_move_to_start(columns%3D%5B%22Year%22%2C%20%22Month%22%2C%20%22Day%22%5D)%0A%20%20%20%20.cols_label(%0A%20%20%20%20%20%20%20%20Ozone%3Dhtml(%22Ozone%2C%3Cbr%3EppbV%22)%2C%0A%20%20%20%20%20%20%20%20Solar_R%3Dhtml(%22Solar%20R.%2C%3Cbr%3Ecal%2Fm%3Csup%3E2%3C%2Fsup%3E%22)%2C%0A%20%20%20%20%20%20%20%20Wind%3Dhtml(%22Wind%2C%3Cbr%3Emph%22)%2C%0A%20%20%20%20%20%20%20%20Temp%3Dhtml(%22Temp%2C%3Cbr%3E%26deg%3BF%22)%2C%0A%20%20%20%20)%0A)%0Alazy_wig_gt\n\n\n\nStep 3: Trigger Execution with .collect()\nTo make the slider work, we call .collect() on the WigGT instance. This executes the stored methods and generates a list of tables, one for each step.\nOnce collected, you can interactively slide through each version of the table!\nwig_gt = lazy_wig_gt.collect()\nwig_gt\n\n    \n    \n    \n    wig_gt%20%3D%20lazy_wig_gt.collect()%0Awig_gt\n\n\n\nStep 4: Access All Built Tables\nFinally, you can retrieve all constructed tables using the .tables property, which returns a list of GT objects.\nwig_gt.tables\n\n\nFull marimo code\nCheck out the full marimo code below or view it on molab.\n\n\nShow full code\nimport marimo\n\n__generated_with = \"0.14.8\"\napp = marimo.App(width=\"medium\")\n\n\n@app.cell\ndef _():\n    import marimo as mo\n\n    return (mo,)\n\n\n@app.cell\ndef _():\n    import copy\n    import inspect\n    from functools import wraps\n    from typing import Callable, Self\n\n    import pandas as pd\n    from great_tables import GT, html\n    from great_tables.data import airquality\n\n    return Callable, GT, Self, airquality, copy, html, inspect, wraps\n\n\n@app.cell\ndef _(Callable, GT, Self, copy, html, inspect, wraps):\n    def get_allowed_member_names() -&gt; list[str]:\n        \"\"\"\n        Manually constructing the list —\n        it would be great if Great Tables exposed the available method names.\n        \"\"\"\n        return [\n            \"fmt\",\n            \"fmt_number\",\n            \"fmt_integer\",\n            \"fmt_percent\",\n            \"fmt_scientific\",\n            \"fmt_currency\",\n            \"fmt_bytes\",\n            \"fmt_roman\",\n            \"fmt_date\",\n            \"fmt_time\",\n            \"fmt_datetime\",\n            \"fmt_markdown\",\n            \"fmt_image\",\n            \"fmt_icon\",\n            \"fmt_flag\",\n            \"fmt_units\",\n            \"fmt_nanoplot\",\n            \"data_color\",\n            \"sub_missing\",\n            \"sub_zero\",\n            \"opt_stylize\",\n            \"opt_align_table_header\",\n            \"opt_all_caps\",\n            \"opt_footnote_marks\",\n            \"opt_row_striping\",\n            \"opt_vertical_padding\",\n            \"opt_horizontal_padding\",\n            \"opt_table_outline\",\n            \"opt_table_font\",\n            \"cols_align\",\n            \"cols_width\",\n            \"cols_label\",\n            \"cols_move\",\n            \"cols_move_to_start\",\n            \"cols_move_to_end\",\n            \"cols_hide\",\n            \"cols_unhide\",\n            \"tab_header\",\n            \"tab_source_note\",\n            \"tab_spanner\",\n            \"tab_stubhead\",\n            \"tab_style\",\n            \"tab_options\",\n            \"row_group_order\",\n            \"tab_stub\",\n            \"with_id\",\n            \"with_locale\",\n            \"save\",\n            \"show\",\n            \"as_raw_html\",\n            \"write_raw_html\",\n            \"as_latex\",\n            \"pipe\",\n        ]\n\n    def lazify(cls: GT) -&gt; GT:\n        def add_to_pipeline(func: Callable[..., GT]) -&gt; callable:\n            @wraps(func)\n            def wrapper(self, *args, **kwargs):\n                def inner(self):\n                    return func(self, *args, **kwargs)\n\n                # container for storing callable objects\n                self._pipeline.append(inner)\n                return self\n\n            wrapper.__signature__ = inspect.signature(func)\n            return wrapper\n\n        for member_name in get_allowed_member_names():\n            setattr(\n                cls, member_name, add_to_pipeline(getattr(GT, member_name))\n            )\n        return cls\n\n    @lazify\n    class WigGT:\n        def __init__(self, *args, widget, **kwargs):\n            self._args = args\n            self._widget = widget\n            self._kwargs = kwargs\n            self.set_to_init()\n\n        @property\n        def tables(self) -&gt; list[GT]:\n            return list(self._tables)  # return a new list\n\n        def _widgetify(self, obj: GT) -&gt; GT:\n            return obj.tab_source_note(html(self._widget))\n\n        def collect(self) -&gt; Self:\n            if not self._is_collect:\n                new_obj = self._tables[0]  # don't use self._wtables[0]\n                for f in self._pipeline:\n                    new_obj = f(self=copy.copy(new_obj))\n                    self._tables.append(new_obj)\n                    self._wtables.append(self._widgetify(new_obj))\n                self._is_collect = True\n            return self\n\n        def _repr_html_(self) -&gt; str:\n            try:\n                obj = self._wtables[self._widget.value]\n            except IndexError:\n                obj = self._wtables[-1]\n\n            if hasattr(obj, \"_display_\"):\n                render_method = \"_display_\"\n            elif hasattr(obj, \"_repr_html_\"):\n                render_method = \"_repr_html_\"\n            elif hasattr(obj, \"_mime_\"):\n                render_method = \"_mime_\"\n            else:\n                raise AttributeError(\n                    \"The object does not have a valid render method.\"\n                )\n            return getattr(obj, render_method)()  # remember to invoke\n\n        def set_to_init(self) -&gt; None:\n            if not getattr(self, \"_pipeline\", None):\n                self._pipeline: list[callable] = []\n            else:\n                self._pipeline.clear()\n\n            if not getattr(self, \"_tables\", None):\n                self._tables = []\n            else:\n                self._tables.clear()\n\n            if not getattr(self, \"_wtables\", None):\n                self._wtables = []\n            else:\n                self._wtables.clear()\n\n            obj = self._make_gt()\n            self._tables.append(obj)\n            self._wtables.append(self._widgetify(obj))\n            self._is_collect = False\n\n        def _make_gt(self) -&gt; GT:\n            return GT(*self._args, **self._kwargs)\n\n    return (WigGT,)\n\n\n@app.cell\ndef _(mo):\n    time_widget = mo.ui.slider(start=0, stop=6, step=1, value=0, label=\"Step\")\n    time_widget\n    return (time_widget,)\n\n\n@app.cell\ndef _(WigGT, airquality, html, time_widget):\n    # The lazy_wig_gt object is not interactive until collect() is called.\n    lazy_wig_gt = (\n        WigGT(airquality.head(10).assign(Year=1973), widget=time_widget)\n        .opt_stylize(color=\"pink\", style=2)\n        .tab_header(\n            title=\"New York Air Quality Measurements\",\n            subtitle=\"Daily measurements in New York City (May 1-10, 1973)\",\n        )\n        .tab_spanner(label=\"Time\", columns=[\"Year\", \"Month\", \"Day\"])\n        .tab_spanner(\n            label=\"Measurement\", columns=[\"Ozone\", \"Solar_R\", \"Wind\", \"Temp\"]\n        )\n        .cols_move_to_start(columns=[\"Year\", \"Month\", \"Day\"])\n        .cols_label(\n            Ozone=html(\"Ozone,&lt;br&gt;ppbV\"),\n            Solar_R=html(\"Solar R.,&lt;br&gt;cal/m&lt;sup&gt;2&lt;/sup&gt;\"),\n            Wind=html(\"Wind,&lt;br&gt;mph\"),\n            Temp=html(\"Temp,&lt;br&gt;&deg;F\"),\n        )\n    )\n    lazy_wig_gt\n    return (lazy_wig_gt,)\n\n\n@app.cell\ndef _(lazy_wig_gt):\n    # The wig_gt object is now interactive\n    wig_gt = lazy_wig_gt.collect()\n    wig_gt\n    return (wig_gt,)\n\n\n@app.cell\ndef _(wig_gt):\n    # retrieve all `gt` tables\n    wig_gt.tables\n    return\n\n\nif __name__ == \"__main__\":\n    app.run()"
  },
  {
    "objectID": "posts/marimo-gt-time-machine/20250626.html#in-closing",
    "href": "posts/marimo-gt-time-machine/20250626.html#in-closing",
    "title": "Time Machine for Great Tables in marimo",
    "section": "In Closing",
    "text": "In Closing\nmarimo has turned out to be far more powerful than I expected — I’ve had a lot of fun experimenting with it.\nI highly recommend checking out their YouTube channel, which is full of high-quality content across many Python topics.\nThis idea was heavily inspired by their videos — all credit goes to the amazing marimo team!\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/p9-polars-alta-ski-resort/20250412.html",
    "href": "posts/p9-polars-alta-ski-resort/20250412.html",
    "title": "Weekend Challenge – Recreating a Data Visualization with Polars and Plotnine",
    "section": "",
    "text": "This post is part of a visualization recreation challenge using Polars and plotnine, inspired by my earlier work.\nIt marks my first serious dive into plotnine—an impressive library with a bit of a learning curve.\nI’ll walk through the journey I took to recreate the visualization. Some parts may overlap with the earlier post, but I believe that’s acceptable to keep this one self-contained.\nThe final figure, shown below, visualizes temperature trends for the ski season in Alta over the past few decades.\nShow full code\nimport polars as pl\nimport polars.selectors as cs\nfrom highlight_text import ax_text\nfrom matplotlib.axes import Axes\nfrom matplotlib.figure import Figure\n\nfrom plotnine import (\n    aes,\n    element_blank,\n    element_text,\n    geom_line,\n    geom_point,\n    geom_segment,\n    geom_text,\n    ggplot,\n    labs,\n    scale_color_cmap,\n    scale_x_continuous,\n    scale_y_continuous,\n    theme,\n    theme_classic,\n)\n\n# https://github.com/mattharrison/datasets/raw/refs/heads/master/data/alta-noaa-1980-2019.csv\ndata_path = \"alta-noaa-1980-2019.csv\"\ncolumns = [\"DATE\", \"TOBS\"]\nidx_colname = \"DAY_OF_SEASON\"\ntemp_colname = \"temp\"\n\nheading_fontsize = 9.5\nheading_fontweight = \"bold\"\nsubheading_fontsize = 8\nsubheading_fontweight = \"normal\"\nsource_fontsize = 6.5\nsource_fontweight = \"light\"\naxis_fontsize = 7\naxis_fontweight = \"normal\"\nsub_props = {\"fontsize\": subheading_fontsize, \"fontweight\": subheading_fontweight}\n\ngrey = \"#aaaaaa\"\nred = \"#e3120b\"\nblue = \"#0000ff\"\n\n\ndef get_season_expr(col: str = \"DATE\", alias: str = \"SEASON\") -&gt; pl.expr:\n    return (\n        (\n            pl.when((pl.col(col).dt.month().is_between(5, 10, closed=\"both\")))\n            .then(pl.lit(\"Summer \"))\n            .otherwise(pl.lit(\"Ski \"))\n        )\n        .add(\n            pl.when(pl.col(col).dt.month() &lt; 11)\n            .then(pl.col(col).dt.year().cast(pl.String))\n            .otherwise(pl.col(col).dt.year().add(1).cast(pl.String))\n        )\n        .alias(alias)\n    )\n\n\ndef add_day_of_season_expr(\n    col: str = \"DATE\", group_col: str = \"SEASON\", alias: str = \"DAY_OF_SEASON\"\n) -&gt; pl.expr:\n    return (\n        (pl.col(col) - pl.col(col).min()).dt.total_days().over(group_col).alias(alias)\n    )\n\n\ndef tweak_df(\n    data_path: str, columns: list[str], idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    return (\n        pl.scan_csv(data_path)\n        .select(columns)\n        .with_columns(\n            pl.col(\"DATE\").str.to_datetime(),\n            pl.col(\"TOBS\").interpolate(),\n        )\n        .sort(\"DATE\")\n        .with_columns(\n            # Caveat: Cannot be placed in the previous `with_columns()`\n            # due to different statuses of `TOBS`.\n            pl.col(\"TOBS\").rolling_mean(window_size=28, center=True).alias(\"TMEAN\"),\n            get_season_expr(col=\"DATE\", alias=\"SEASON\"),\n        )\n        .with_columns(\n            add_day_of_season_expr(col=\"DATE\", group_col=\"SEASON\", alias=idx_colname)\n        )\n        .collect()\n    )\n\n\ndef plot_temps(_df: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\") -&gt; ggplot:\n    season_temps = _df.filter(pl.col(\"SEASON\").str.contains(\"Ski\")).pivot(\n        \"SEASON\", index=idx_colname, values=\"TMEAN\", aggregate_function=\"first\"\n    )\n\n    # main\n    df_main = season_temps.unpivot(\n        (cs.starts_with(\"Ski\") - cs.by_name(\"Ski 2019\")),\n        index=idx_colname,\n        variable_name=\"year\",\n        value_name=temp_colname,\n    ).select(\n        idx_colname,\n        temp_colname,\n        pl.col(\"year\").str.slice(-4).cast(pl.Int32),\n    )\n\n    # decades\n    decades = [1980, 1990, 2000, 2010]\n    blues = [\"#0055EE\", \"#0033CC\", \"#0011AA\", \"#3377FF\"]\n\n    df_decade = pl.concat(\n        [\n            season_temps.select(\n                idx_colname,\n                pl.mean_horizontal(cs.contains(str(decade)[:-1])).alias(temp_colname),\n                pl.lit(b).alias(\"color\"),\n            )\n            for b, decade in zip(blues, decades)\n        ],\n        how=\"vertical\",\n    )\n\n    # decade points\n    df_decade_pts = (\n        df_decade.group_by(pl.col(\"color\"), maintain_order=True)\n        .agg(\n            pl.col(idx_colname).first().append(pl.col(idx_colname).last()),\n            pl.col(temp_colname).first().append(pl.col(temp_colname).last()),\n        )\n        .explode(idx_colname, temp_colname)\n    )\n\n    # decade annotations\n    decade_annts = (\n        df_decade_pts.filter(pl.col(idx_colname).eq(pl.col(idx_colname).max()))\n        .select(temp_colname)\n        .to_series()\n        .to_list()\n    )\n\n    df_decade_annt = pl.DataFrame(\n        {\n            \"x\": [185] * len(decade_annts),\n            # adjust y position for better appearance\n            \"y\": [\n                decade_annts[0],\n                decade_annts[1] + 0.5,\n                decade_annts[2] - 3,\n                decade_annts[3],\n            ],\n            \"color\": blues,\n            \"label\": decades,\n        }\n    )\n\n    # ski_2019\n    ski_2019 = (\n        season_temps.select(\n            idx_colname, pl.col(\"Ski 2019\").alias(temp_colname)\n        ).drop_nulls()  # \"DAY_OF_SEASON\"=181, \"temp\"=null\n    )\n\n    # ski_2019 points\n    ski_2019_pts = pl.concat([ski_2019.head(1), ski_2019.tail(1)])\n\n    # ggplot\n    return (\n        ggplot(mapping=aes(x=idx_colname, y=temp_colname))\n        # multiple grey lines\n        + geom_line(\n            mapping=aes(color=\"factor(year)\"),\n            data=df_main,\n            alpha=0.2,\n            size=0.5,\n        )\n        # 4 blue lines\n        + geom_line(\n            mapping=aes(fill=\"factor(color)\"),\n            data=df_decade,\n            color=df_decade[\"color\"],\n            size=0.5,\n            lineend=\"round\",\n        )\n        # 2019 red line\n        + geom_line(\n            data=ski_2019,\n            color=red,\n            size=0.8,\n            lineend=\"round\",\n        )\n        # 1 black dashed line for temp=32F\n        + geom_segment(\n            mapping=aes(x=0, xend=200, y=32, yend=32),\n            size=0.5,\n            linetype=\"dashed\",\n        )\n        # start and end dots for 4 blue lines\n        + geom_point(\n            mapping=aes(x=idx_colname, y=temp_colname),\n            data=df_decade_pts,\n            color=df_decade_pts[\"color\"],\n            size=0.2,\n        )\n        # start and end dots for 2019 red line\n        + geom_point(\n            mapping=aes(x=idx_colname, y=temp_colname),\n            data=ski_2019_pts,\n            color=red,\n            size=1,\n        )\n        # annotations for 4 blue lines\n        + geom_text(\n            mapping=aes(x=\"x\", y=\"y\", label=\"label\"),\n            data=df_decade_annt,\n            color=df_decade_annt[\"color\"],\n            size=axis_fontsize,\n            fontweight=axis_fontweight,\n            ha=\"left\",\n            va=\"center\",\n        )\n        + labs(x=idx_colname, y=\"\")\n        + scale_x_continuous(\n            breaks=[0, 50, 100, 150],\n            limits=(0, 200),\n            expand=(0, 10, 0, 15),\n        )\n        + scale_y_continuous(breaks=[10, 32, 40], limits=(10, 70), expand=(0, 0))\n        + scale_color_cmap(\"Greys\", guide=None)\n    )\n\n\ndef points_to_inches(points):\n    return points / 72\n\n\ndef themify(p: ggplot) -&gt; Figure:\n    figsize = (160, 165)  # pts\n    figsize_inches = [points_to_inches(dim) for dim in figsize]\n\n    return (\n        p\n        + theme_classic()\n        + theme(\n            axis_line_y=element_blank(),\n            axis_title_x=element_text(weight=axis_fontweight, size=axis_fontsize),\n            axis_title_y=element_text(weight=axis_fontweight, size=axis_fontsize),\n            axis_text_x=element_text(color=\"black\"),\n            axis_text_y=element_text(color=\"black\"),\n            dpi=300,\n            figure_size=figsize_inches,\n            aspect_ratio=2 / 3,\n            text=element_text(\"Roboto\"),\n        )\n    ).draw(show=False)\n\n\ndef add_ax_text(ax: Axes) -&gt; Axes:\n    ax_text(\n        s=\"&lt;Alta Ski Resort&gt;\\n&lt;Temperature trends by &gt;\\n&lt;decade&gt;&lt; and &gt;&lt;2019&gt;\",\n        x=-5,\n        y=55,\n        fontsize=heading_fontsize,\n        ax=ax,\n        va=\"bottom\",\n        ha=\"left\",\n        zorder=5,\n        highlight_textprops=[\n            {\"fontsize\": heading_fontsize, \"fontweight\": heading_fontweight},\n            sub_props,\n            {\"color\": blue, **sub_props},\n            sub_props,\n            {\"color\": red, **sub_props},\n        ],\n    )\n\n    ax.text(\n        0,\n        -10,\n        \"Source: NOAA\",\n        fontsize=source_fontsize,\n        fontweight=source_fontweight,\n        color=grey,\n    )\n    return ax\n\n\ndf = tweak_df(data_path, columns, idx_colname)\np = plot_temps(df, idx_colname)\nfig = themify(p)\nax = fig.axes[0]\nax = add_ax_text(ax)\nfig"
  },
  {
    "objectID": "posts/p9-polars-alta-ski-resort/20250412.html#data-processing-pipeline",
    "href": "posts/p9-polars-alta-ski-resort/20250412.html#data-processing-pipeline",
    "title": "Weekend Challenge – Recreating a Data Visualization with Polars and Plotnine",
    "section": "Data Processing Pipeline",
    "text": "Data Processing Pipeline\nBelow is the data pipeline used to generate the DataFrame for the upcoming visualization stage:\ndata_path = \"alta-noaa-1980-2019.csv\"\ncolumns = [\"DATE\", \"TOBS\"]\nidx_colname = \"DAY_OF_SEASON\"\ntemp_colname = \"temp\"\n\n\ndef tweak_df(data_path: str, columns: list[str], idx_colname: str = \"DAY_OF_SEASON\"):\n    return (\n        pl.scan_csv(data_path)\n1        .select(columns)\n        .with_columns(\n2            pl.col(\"DATE\").str.to_datetime(),\n3            pl.col(\"TOBS\").interpolate(),\n        )\n        .sort(\"DATE\")\n        .with_columns(\n            # Caveat: Cannot be placed in the previous `with_columns()`\n            # due to different statuses of `TOBS`.\n4            pl.col(\"TOBS\").rolling_mean(window_size=28, center=True).alias(\"TMEAN\"),\n5            get_season_expr(col=\"DATE\", alias=\"SEASON\"),\n        )\n        .with_columns(\n6            add_day_of_season_expr(col=\"DATE\", group_col=\"SEASON\", alias=idx_colname)\n        )\n        .collect()\n    )\n\n1\n\nSelect the DATE column (dates) and TOBS column (recorded temperatures in Fahrenheit).\n\n2\n\nConvert the DATE column to a datetime format.\n\n3\n\nPerform interpolation on the TOBS column.\n\n4\n\nCompute a 28-day rolling average for TOBS.\n\n5\n\nUse get_season_expr() to categorize each date into a SEASON.\n\n6\n\nApply add_day_of_season_expr() to calculate DAY_OF_SEASON, representing days elapsed since the start of the season.\n\n\nThe first three steps involve straightforward Polars expressions. In the following two sub-sections, we’ll dive deeper into steps 5 and 6.\n\nCategorizing Dates into Summer and Ski Seasons\nTo analyze seasonal trends, we classify dates into two categories:\n\nSummer: Covers May through October.\n\nSki: Covers November through April.\n\nIf a date falls in November or December, it is assigned to the following year’s season. For example, 2015-10-31 is categorized as Summer 2015, while 2015-11-01 belongs to Ski 2016.\nTo implement this logic, we define get_season_expr(), which leverages Polars’ when-then-otherwise expressions to determine the season and year.\ndef get_season_expr(col: str = \"DATE\", alias: str = \"SEASON\") -&gt; pl.expr:\n    return (\n        (\n            pl.when((pl.col(col).dt.month().is_between(5, 10, closed=\"both\")))\n            .then(pl.lit(\"Summer \"))\n            .otherwise(pl.lit(\"Ski \"))\n        )\n        .add(\n            pl.when(pl.col(col).dt.month() &lt; 11)\n            .then(pl.col(col).dt.year().cast(pl.String))\n            .otherwise(pl.col(col).dt.year().add(1).cast(pl.String))\n        )\n        .alias(alias)\n    )\nIn this function:\n\nIf the month is between May and October, the function assigns \"Summer \". Otherwise, it assigns \"Ski \" (with a trailing space for concatenation).\n\nThe year is determined based on the month: dates from January to October retain their current year, while those in November and December are shifted to the next year.\n\nBy applying this function, we can add a SEASON column to a DataFrame, ensuring each date is categorized correctly.\n\n\nCalculating the Total Days for Each Season\nOnce we have the seasonal categories, we calculate DAY_OF_SEASON, which tracks the number of days elapsed within each season. This is achieved using the pl.expr.over() expression, which operates similarly to Pandas’ groupby().transform(), applying transformations within groups.\ndef add_day_of_season_expr(\n    col: str = \"DATE\", group_col: str = \"SEASON\", alias: str = \"DAY_OF_SEASON\"\n) -&gt; pl.expr:\n    return (\n        (pl.col(col) - pl.col(col).min()).dt.total_days().over(group_col).alias(alias)\n    )"
  },
  {
    "objectID": "posts/p9-polars-alta-ski-resort/20250412.html#visualizing-temperature-trends-with-plotnine",
    "href": "posts/p9-polars-alta-ski-resort/20250412.html#visualizing-temperature-trends-with-plotnine",
    "title": "Weekend Challenge – Recreating a Data Visualization with Polars and Plotnine",
    "section": "Visualizing Temperature Trends with Plotnine",
    "text": "Visualizing Temperature Trends with Plotnine\nWith the data prepared, we now turn our focus to visualization. The plot_temps() function is relatively long, so we’ll walk through it step by step. Ultimately, we’ll construct several intermediate DataFrames and use them to build a ggplot object for rendering.\n\nReshaping the Main DataFrame\nWe begin by filtering the dataset to include only rows corresponding to Ski seasons. Then, using pl.DataFrame.pivot() and pl.DataFrame.unpivot(), we reshape the main DataFrame.\ndef plot_temps(\n    _df: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; ggplot:\n    season_temps = _df.filter(pl.col(\"SEASON\").str.contains(\"Ski\")).pivot(\n        \"SEASON\", index=idx_colname, values=\"TMEAN\", aggregate_function=\"first\"\n    )\n\n    df_main = season_temps.unpivot(\n        (cs.starts_with(\"Ski\") - cs.by_name(\"Ski 2019\")),\n        index=idx_colname,\n        variable_name=\"year\",\n        value_name=temp_colname,\n    ).select(\n        idx_colname,\n        temp_colname,\n        pl.col(\"year\").str.slice(-4).cast(pl.Int32),\n    )\n    ...\nNote: We intentionally exclude Ski 2019 here, as it will be handled separately later.\nPreview of df_main:\nshape: (7_098, 3)\n┌───────────────┬───────────┬──────┐\n│ DAY_OF_SEASON ┆ temp      ┆ year │\n│ ---           ┆ ---       ┆ ---  │\n│ i64           ┆ f64       ┆ i32  │\n╞═══════════════╪═══════════╪══════╡\n│ 0             ┆ null      ┆ 1980 │\n│ 1             ┆ null      ┆ 1980 │\n│ 2             ┆ null      ┆ 1980 │\n│ 3             ┆ null      ┆ 1980 │\n│ 4             ┆ null      ┆ 1980 │\n│ …             ┆ …         ┆ …    │\n│ 177           ┆ 44.0      ┆ 2018 │\n│ 178           ┆ 44.464286 ┆ 2018 │\n│ 179           ┆ 44.607143 ┆ 2018 │\n│ 180           ┆ 44.142857 ┆ 2018 │\n│ 181           ┆ null      ┆ 2018 │\n└───────────────┴───────────┴──────┘\n\n\nBuilding a DataFrame for Decade Averages\nTo reveal long-term patterns, we compute average temperature trends by decade. Each decade will be represented by a separate line with a distinct color.\ndef plot_temps(df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\") -&gt; ggplot:\n    ...\n    decades = [1980, 1990, 2000, 2010]\n    blues = [\"#0055EE\", \"#0033CC\", \"#0011AA\", \"#3377FF\"]\n\n    df_decade = pl.concat(\n        [\n            season_temps.select(\n                idx_colname,\n                pl.mean_horizontal(cs.contains(str(decade)[:-1])).alias(temp_colname),\n                pl.lit(b).alias(\"color\"),\n            )\n            for b, decade in zip(blues, decades)\n        ],\n        how=\"vertical\",\n    )\nPreview of df_decade:\nshape: (728, 3)\n┌───────────────┬───────────┬─────────┐\n│ DAY_OF_SEASON ┆ temp      ┆ color   │\n│ ---           ┆ ---       ┆ ---     │\n│ i64           ┆ f64       ┆ str     │\n╞═══════════════╪═══════════╪═════════╡\n│ 0             ┆ 32.704365 ┆ #0055EE │\n│ 1             ┆ 32.156746 ┆ #0055EE │\n│ 2             ┆ 31.875    ┆ #0055EE │\n│ 3             ┆ 31.561508 ┆ #0055EE │\n│ 4             ┆ 31.041667 ┆ #0055EE │\n│ …             ┆ …         ┆ …       │\n│ 177           ┆ 39.275    ┆ #3377FF │\n│ 178           ┆ 39.639286 ┆ #3377FF │\n│ 179           ┆ 40.092857 ┆ #3377FF │\n│ 180           ┆ 40.653571 ┆ #3377FF │\n│ 181           ┆ 41.428571 ┆ #3377FF │\n└───────────────┴───────────┴─────────┘\n\n\nAnnotating Decade Lines\nTo enhance readability, we annotate each decade line in two ways: by marking the start and end points and by adding labels to the line endings. For this purpose, we create two separate DataFrames.\ndef plot_temps(df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\") -&gt; ggplot:\n    ...\n    df_decade_pts = (\n        df_decade.group_by(pl.col(\"color\"), maintain_order=True)\n        .agg(\n            pl.col(idx_colname).first().append(pl.col(idx_colname).last()),\n            pl.col(temp_colname).first().append(pl.col(temp_colname).last()),\n        )\n        .explode(idx_colname, temp_colname)\n    )\n\n    decade_annts = (\n        df_decade_pts.filter(pl.col(idx_colname).eq(pl.col(idx_colname).max()))\n        .select(temp_colname)\n        .to_series()\n        .to_list()\n    )\n\n    df_decade_annt = pl.DataFrame(\n        {\n            \"x\": [185] * len(decade_annts),\n            # adjust y position for better appearance\n            \"y\": [\n                decade_annts[0],\n                decade_annts[1] + 0.5,\n                decade_annts[2] - 3,\n                decade_annts[3],\n            ],\n            \"color\": blues,\n            \"label\": decades,\n        }\n    )\nPreview of df_decade_pts (start and end points):\nshape: (8, 3)\n┌─────────┬───────────────┬───────────┐\n│ color   ┆ DAY_OF_SEASON ┆ temp      │\n│ ---     ┆ ---           ┆ ---       │\n│ str     ┆ i64           ┆ f64       │\n╞═════════╪═══════════════╪═══════════╡\n│ #0055EE ┆ 0             ┆ 32.704365 │\n│ #0055EE ┆ 181           ┆ 34.357143 │\n│ #0033CC ┆ 0             ┆ 34.851786 │\n│ #0033CC ┆ 181           ┆ 44.535714 │\n│ #0011AA ┆ 0             ┆ 35.719643 │\n│ #0011AA ┆ 181           ┆ 40.77381  │\n│ #3377FF ┆ 0             ┆ 35.380357 │\n│ #3377FF ┆ 181           ┆ 41.428571 │\n└─────────┴───────────────┴───────────┘\nPreview of df_decade_annt (annotation labels):\nshape: (4, 4)\n┌─────┬───────────┬─────────┬───────┐\n│ x   ┆ y         ┆ color   ┆ label │\n│ --- ┆ ---       ┆ ---     ┆ ---   │\n│ i64 ┆ f64       ┆ str     ┆ i64   │\n╞═════╪═══════════╪═════════╪═══════╡\n│ 185 ┆ 34.357143 ┆ #0055EE ┆ 1980  │\n│ 185 ┆ 45.035714 ┆ #0033CC ┆ 1990  │\n│ 185 ┆ 37.77381  ┆ #0011AA ┆ 2000  │\n│ 185 ┆ 41.428571 ┆ #3377FF ┆ 2010  │\n└─────┴───────────┴─────────┴───────┘\n\n\nIsolating the 2019 Ski Season\nWe separate out the 2019 Ski season so that we can highlight it independently in the final visualization.\ndef plot_temps(df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\") -&gt; ggplot:\n    ...\n    ski_2019 = (\n        season_temps.select(\n            idx_colname, pl.col(\"Ski 2019\").alias(temp_colname)\n        ).drop_nulls()  # \"DAY_OF_SEASON\"=181, \"temp\"=null\n    )\nPreview of ski_2019:\nshape: (181, 2)\n┌───────────────┬───────────┐\n│ DAY_OF_SEASON ┆ temp      │\n│ ---           ┆ ---       │\n│ i64           ┆ f64       │\n╞═══════════════╪═══════════╡\n│ 0             ┆ 33.214286 │\n│ 1             ┆ 32.892857 │\n│ 2             ┆ 32.25     │\n│ 3             ┆ 31.142857 │\n│ 4             ┆ 30.357143 │\n│ …             ┆ …         │\n│ 176           ┆ 38.607143 │\n│ 177           ┆ 39.285714 │\n│ 178           ┆ 39.964286 │\n│ 179           ┆ 40.464286 │\n│ 180           ┆ 41.25     │\n└───────────────┴───────────┘\nWe also prepare a small DataFrame to annotate the start and end points of the 2019 line:\nPreview of ski_2019_pts:\ndef plot_temps(df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\") -&gt; ggplot:\n    ...\n    ski_2019_pts = pl.concat([ski_2019.head(1), ski_2019.tail(1)])\n\n\nCreating the ggplot Object\nWe now bring everything together into a single ggplot object:\ndef plot_temps(df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\") -&gt; ggplot:\n    ...\n    return (\n1        ggplot(mapping=aes(x=idx_colname, y=temp_colname))\n        # multiple grey lines\n        + geom_line(\n2            mapping=aes(color=\"factor(year)\"),\n            data=df_main,\n            alpha=0.2,\n            size=0.5,\n        )\n        # 4 blue lines\n        + geom_line(\n3            mapping=aes(fill=\"factor(color)\"),\n            data=df_decade,\n            color=df_decade[\"color\"],\n            size=0.5,\n4            lineend=\"round\",\n        )\n        # 2019 red line\n        + geom_line(\n            data=ski_2019,\n            color=red,\n            size=0.8,\n            lineend=\"round\",\n        )\n        # 1 black dashed line for temp=32F\n5        + geom_segment(\n            mapping=aes(x=0, xend=200, y=32, yend=32),\n            size=0.5,\n            linetype=\"dashed\",\n        )\n        # start and end dots for 4 blue lines\n        + geom_point(\n            mapping=aes(x=idx_colname, y=temp_colname),\n            data=df_decade_pts,\n            color=df_decade_pts[\"color\"],\n            size=0.2,\n        )\n        # start and end dots for 2019 red line\n        + geom_point(\n            mapping=aes(x=idx_colname, y=temp_colname),\n            data=ski_2019_pts,\n            color=red,\n            size=1,\n        )\n        # annotations for 4 blue lines\n        + geom_text(\n6            mapping=aes(x=\"x\", y=\"y\", label=\"label\"),\n            data=df_decade_annt,\n            color=df_decade_annt[\"color\"],\n            size=axis_fontsize,\n            fontweight=axis_fontweight,\n            ha=\"left\",\n            va=\"center\",\n        )\n        + labs(x=idx_colname, y=\"\")\n        + scale_x_continuous(\n            breaks=[0, 50, 100, 150],\n            limits=(0, 200),\n            expand=(0, 10, 0, 15),\n        )\n        + scale_y_continuous(breaks=[10, 32, 40], limits=(10, 70), expand=(0, 0))\n        + scale_color_cmap(\"Greys\", guide=None)\n    )\n\n1\n\nWe define the default aesthetic mapping in ggplot() to avoid repetition in later layers.\n\n2\n\nfactor(year) is mapped to color=, and the Greys colormap is applied using scale_color_cmap()—a very convenient way to show progression.\n\n3\n\nFor the decade lines, factor(color) is mapped to the fill= aesthetic. Colors are controlled via a color column in the dataframe—an effective trick.\n\n4\n\nThe lineend= parameter is useful if you don’t plan to mark endpoints with dots.\n\n5\n\nUsing geom_hline() would extend the line infinitely in both directions. In this case, we used geom_segment() to constrain the line.\n\n6\n\nThe label= aesthetic in geom_text() is mapped from the label column in df_decade_annt."
  },
  {
    "objectID": "posts/p9-polars-alta-ski-resort/20250412.html#touchups",
    "href": "posts/p9-polars-alta-ski-resort/20250412.html#touchups",
    "title": "Weekend Challenge – Recreating a Data Visualization with Polars and Plotnine",
    "section": "Touchups",
    "text": "Touchups\n\nAdding a Theme\nWe apply a custom theme using the themify() function, adjusting various themeable elements to refine the plot’s appearance:\ndef points_to_inches(points):\n    return points / 72\n\n\ndef themify(p: ggplot) -&gt; Figure:\n    figsize = (160, 165)  # pts\n    figsize_inches = [points_to_inches(dim) for dim in figsize]\n\n    return (\n        p\n        + theme_classic()\n        + theme(\n            axis_line_y=element_blank(),\n            axis_title_x=element_text(weight=axis_fontweight, size=axis_fontsize),\n            axis_title_y=element_text(weight=axis_fontweight, size=axis_fontsize),\n            axis_text_x=element_text(color=\"black\"),\n            axis_text_y=element_text(color=\"black\"),\n            dpi=300,\n            figure_size=figsize_inches,\n            aspect_ratio=2 / 3,\n            text=element_text(\"Roboto\"),\n        )\n    ).draw(show=False)\n\n\nAdding a Title and Source Note\nFor the title, we use ax_text() from the HighlightText library. It allows inline text highlighting using &lt; &gt;, letting us emphasize specific parts of the title like &lt;Alta Ski Resort&gt;, &lt;Temperature trends by &gt;, &lt;decade&gt;, &lt; and &gt;, and &lt;2019&gt; with customized styles.\nTo add a source note, we simply use Matplotlib’s ax.text():\ndef add_ax_text(ax: Axes) -&gt; Axes:\n    ax_text(\n        s=\"&lt;Alta Ski Resort&gt;\\n&lt;Temperature trends by &gt;\\n&lt;decade&gt;&lt; and &gt;&lt;2019&gt;\",\n        x=-5,\n        y=55,\n        fontsize=heading_fontsize,\n        ax=ax,\n        va=\"bottom\",\n        ha=\"left\",\n        zorder=5,\n        highlight_textprops=[\n            {\"fontsize\": heading_fontsize, \"fontweight\": heading_fontweight},\n            sub_props,\n            {\"color\": blue, **sub_props},\n            sub_props,\n            {\"color\": red, **sub_props},\n        ],\n    )\n\n    ax.text(\n        0,\n        -10,\n        \"Source: NOAA\",\n        fontsize=source_fontsize,\n        fontweight=source_fontweight,\n        color=grey,\n    )\n    return ax"
  },
  {
    "objectID": "posts/p9-polars-alta-ski-resort/20250412.html#rendering-the-plot",
    "href": "posts/p9-polars-alta-ski-resort/20250412.html#rendering-the-plot",
    "title": "Weekend Challenge – Recreating a Data Visualization with Polars and Plotnine",
    "section": "Rendering the Plot",
    "text": "Rendering the Plot\nNow we put everything together and render the final plot. A key trick here is retrieving the ax object using fig.axes[0], which allows us to apply both HighlightText and regular Matplotlib functions.\ndf = tweak_df(data_path, columns, idx_colname)\np = plot_temps(df, idx_colname)\nfig = themify(p)\nax = fig.axes[0]\nax = add_ax_text(ax)\nfig"
  },
  {
    "objectID": "posts/p9-polars-alta-ski-resort/20250412.html#takeaways",
    "href": "posts/p9-polars-alta-ski-resort/20250412.html#takeaways",
    "title": "Weekend Challenge – Recreating a Data Visualization with Polars and Plotnine",
    "section": "Takeaways",
    "text": "Takeaways\nWrapping up this post, I’ve come to appreciate how powerful the plotnine library truly is. While its aesthetic system requires a bit of mental shift, it offers a clean, expressive way to build layered visualizations.\nOne key takeaway for me is that each layer can operate on its own dataset, which adds a lot of flexibility. What I enjoyed most, though, is the theme system—it makes it easy to define a consistent visual style that can be reused across different plots.\nOne limitation I ran into was the lack of a plotnine-native alternative to pli.subplot_mosaic(). This feature allows for more granular layout control—for example, dividing the figure into separate axes with custom height ratios for the title, main plot, and source note using gridspec_kw={\"height_ratios\": [6, 12, 1]}.\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/django-allauth-resend/20241223.html",
    "href": "posts/django-allauth-resend/20241223.html",
    "title": "Exploring Resend SMTP Service with Django",
    "section": "",
    "text": "This post demonstrates how to integrate Resend with django-allauth seamlessly in a Django project. If you’re looking to use Resend for sending emails via Django, refer to the repo provided by Resend."
  },
  {
    "objectID": "posts/django-allauth-resend/20241223.html#preparations-for-django",
    "href": "posts/django-allauth-resend/20241223.html#preparations-for-django",
    "title": "Exploring Resend SMTP Service with Django",
    "section": "Preparations for Django",
    "text": "Preparations for Django\n\nCreate a Virtual Environment\nStart by creating a virtual environment using uv and activating it:\nuv venv venv\nsource venv/bin/activate\n\n\nInstall Required Packages\nCreate a requirements.txt file and add the necessary dependencies:\ndjango\nenvirons[django]\ndjango-allauth\nInstall the packages via uv:\nuv pip install -r requirements.txt\n\n\nSet Up a Django Project\nUse the django-admin command to create a project named core:\ndjango-admin startproject core .\n\n\nConfigure Environment Variables\nCreate a .env file with the following content:\nDEFAULT_FROM_EMAIL=\nRESEND_SMTP_HOST=smtp.resend.com\nRESEND_SMTP_USERNAME=resend\nRESEND_API_KEY=\nRESEND_SMTP_PORT=587\nRESEND_USE_TLS=True\nThe next sections explain how to obtain DEFAULT_FROM_EMAIL and RESEND_API_KEY."
  },
  {
    "objectID": "posts/django-allauth-resend/20241223.html#preparations-for-resend",
    "href": "posts/django-allauth-resend/20241223.html#preparations-for-resend",
    "title": "Exploring Resend SMTP Service with Django",
    "section": "Preparations for Resend",
    "text": "Preparations for Resend\n\nVerify Your Domain\nFollow the Resend documentation to verify your domain. Once verified, you can send emails using an address like user@send.yourdomain.com.\n\nYou control the prefix before @, as ownership of the domain has been confirmed.\n\nAdd your chosen email to DEFAULT_FROM_EMAIL in the .env file.\n\n\n\nObtain an API Key\nGenerate an API key via the Resend API Keys page and add it to the RESEND_API_KEY field in your .env file."
  },
  {
    "objectID": "posts/django-allauth-resend/20241223.html#django-scaffold",
    "href": "posts/django-allauth-resend/20241223.html#django-scaffold",
    "title": "Exploring Resend SMTP Service with Django",
    "section": "Django Scaffold",
    "text": "Django Scaffold\nFollow the quick start guide from django-allauth to configure the project with minimal setup.\n\nModify core/urls.py\nInclude django-allauth routes and define a homepage route:\n# core/urls.py\n\nfrom django.contrib import admin\nfrom django.urls import path, include\nfrom . import views\n\nurlpatterns = [\n    path(\"admin/\", admin.site.urls),\n    path(\"accounts/\", include(\"allauth.urls\")),  # added\n    path(\"\", views.index, name=\"home\"),  # added\n]\n\n\nAdd core/views.py\nDefine the homepage with a link to the signup URL provided by django-allauth:\nfrom django.http import HttpResponse\nfrom django.urls import reverse\n\n\ndef index(request):\n    signup_url = reverse(\"account_signup\")\n    return HttpResponse(f'&lt;a href=\"{signup_url}\"&gt;Hello, please Sign Up here!&lt;/a&gt;')\n\n\nModify core/settings.py\n\nRead Environment Variables\n# core/settings.py\n\nfrom environs import Env\n\nenv = Env()\nenv.read_env()\n\n\nUpdate INSTALLED_APPS\n# core/settings.py\n\nINSTALLED_APPS = [\n    ...\n    \"allauth\",  # added\n    \"allauth.account\",  # added\n]\n\n\nUpdate MIDDLEWARE\n# core/settings.py\n\nMIDDLEWARE = [\n    \"django.middleware.security.SecurityMiddleware\",\n    \"django.contrib.sessions.middleware.SessionMiddleware\",\n    \"django.middleware.common.CommonMiddleware\",\n    \"django.middleware.csrf.CsrfViewMiddleware\",\n    \"django.contrib.auth.middleware.AuthenticationMiddleware\",\n    \"django.contrib.messages.middleware.MessageMiddleware\",\n    \"allauth.account.middleware.AccountMiddleware\",  # added\n    ...\n]\n\n\nConfigure Email Backend and Authentication Backends\n# core/settings.py\n\nEMAIL_BACKEND = \"django.core.mail.backends.smtp.EmailBackend\"\n\nAUTHENTICATION_BACKENDS = [\n    \"django.contrib.auth.backends.ModelBackend\",\n    \"allauth.account.auth_backends.AuthenticationBackend\",\n]\n\n\nDefine Login and Logout Redirect URLs\nHere, we define only ACCOUNT_LOGOUT_REDIRECT_URL because django-allauth overwrites LOGOUT_REDIRECT_URL.\nLOGIN_REDIRECT_URL = \"home\"\nACCOUNT_LOGOUT_REDIRECT_URL = \"home\"\n\n\nOptional Preference Settings\nOpinionated configurations for a simplified signup and email-based login:\nACCOUNT_SIGNUP_PASSWORD_ENTER_TWICE = False\nACCOUNT_USERNAME_REQUIRED = False\nACCOUNT_AUTHENTICATION_METHOD = \"email\"\nACCOUNT_EMAIL_REQUIRED = True\nACCOUNT_UNIQUE_EMAIL = True\n\n\nDefine Resend Variables\nDEFAULT_FROM_EMAIL = env(\"DEFAULT_FROM_EMAIL\")\nRESEND_SMTP_HOST = env(\"RESEND_SMTP_HOST\")\nRESEND_SMTP_USERNAME = env(\"RESEND_SMTP_USERNAME\")\nRESEND_API_KEY = env(\"RESEND_API_KEY\")\nRESEND_SMTP_PORT = env.int(\"RESEND_SMTP_PORT\")\nRESEND_USE_TLS = env.bool(\"RESEND_USE_TLS\")\n\n\nMap Resend Variables to Django Email Variables\nDelegate Django email settings to Resend environment variables:\nEMAIL_HOST = RESEND_SMTP_HOST\nEMAIL_HOST_USER = RESEND_SMTP_USERNAME\nEMAIL_HOST_PASSWORD = RESEND_API_KEY\nEMAIL_PORT = RESEND_SMTP_PORT\nEMAIL_USE_TLS = RESEND_USE_TLS"
  },
  {
    "objectID": "posts/django-allauth-resend/20241223.html#tryout",
    "href": "posts/django-allauth-resend/20241223.html#tryout",
    "title": "Exploring Resend SMTP Service with Django",
    "section": "Tryout",
    "text": "Tryout\nMigrate the database and run the development server with the following commands:\npython manage.py migrate\npython manage.py runserver\nNow, go to http://127.0.0.1:8000/ and click the sign-up link. You should see the signup page. After submitting the form, you will be redirected to the homepage.\nNext, check your inbox for an email with the subject [127.0.0.1:8000] Please Confirm Your Email Address.\nThe email will contain a confirmation link. Click the link, then click the confirmation button, and you’re all set for user registration!\n\n\n\n\n\n\nTip\n\n\n\nIf you encounter issues during configuration, the Resend logs can be a helpful resource, as they provide the request body, response body, and status code."
  },
  {
    "objectID": "posts/django-allauth-resend/20241223.html#final-words",
    "href": "posts/django-allauth-resend/20241223.html#final-words",
    "title": "Exploring Resend SMTP Service with Django",
    "section": "Final Words",
    "text": "Final Words\nThe configuration is straightforward, and it’s great that Resend offers SMTP services. The modern dashboard operates smoothly, and the well-documented resources make it easy for developers to find needed information. So far, the user experience has been positive, and I look forward to using it in real projects.\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/turtle-island-notes/20250721.html",
    "href": "posts/turtle-island-notes/20250721.html",
    "title": "Notes on Turtle Island",
    "section": "",
    "text": "This is a short post documenting some things I often forget while building Turtle Island."
  },
  {
    "objectID": "posts/turtle-island-notes/20250721.html#output-column-names",
    "href": "posts/turtle-island-notes/20250721.html#output-column-names",
    "title": "Notes on Turtle Island",
    "section": "Output Column Names",
    "text": "Output Column Names\nIn Polars, if an explicit name isn’t provided, the output column will take the name of the first expression. This default behavior is generally helpful, but it can lead to unexpected results—especially when the first expression doesn’t directly represent a column. For example, if the first expression is pl.lit(), the resulting column name will be \"literal\".\nThis isn’t a big issue when dealing with a single column, but it becomes problematic when using expressions like pl.all() or pl.col(\"*\"). In such cases, logic that depends on column names often breaks.\nMy current workaround is to tweak the internal logic so that the returned expression doesn’t start with something like pl.lit(), especially in functions that aim to support wildcard expressions."
  },
  {
    "objectID": "posts/turtle-island-notes/20250721.html#expression-context-vs-dataframe-context",
    "href": "posts/turtle-island-notes/20250721.html#expression-context-vs-dataframe-context",
    "title": "Notes on Turtle Island",
    "section": "Expression Context vs DataFrame Context",
    "text": "Expression Context vs DataFrame Context\nSince Polars expressions are designed to be evaluated later (not immediately), we cannot rely on any runtime properties of the DataFrame when building them. That means things like the shape or number of rows in the DataFrame are not available during expression construction.\nHowever, some built-in Polars functions help bridge this gap. For instance, pl.len() returns an expression that can be used to represent the number of rows in the future evaluation context. This is useful for writing general-purpose logic in Turtle Island.\nA major caveat is that Polars expressions can’t be evaluated directly in Python. You can’t write something like if pl.len() or pl.len() + 1 as regular Python code. These expressions must be used inside other Polars expressions or functions—such as pl.int_range(0, pl.len() + 1)—where they’ll be correctly interpreted and evaluated within the Polars execution context.\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/clone-reciprocal-tariffs-table-p9/20250416.html",
    "href": "posts/clone-reciprocal-tariffs-table-p9/20250416.html",
    "title": "Clone the Reciprocal Tariffs Table Using Plotnine",
    "section": "",
    "text": "This post presents a recreated visualization using Polars and plotnine, based on my earlier work.\nBelow is the final figure:\nShow full code\nimport polars as pl\nfrom matplotlib.figure import Figure\nfrom plotnine import (\n    aes,\n    element_blank,\n    element_rect,\n    element_text,\n    geom_segment,\n    geom_text,\n    ggplot,\n    position_nudge,\n    scale_color_identity,\n    scale_size_identity,\n    scale_y_discrete,\n    theme,\n    theme_void,\n    watermark,\n)\n\n\n# source1: https://truthsocial.com/@realDonaldTrump/114270398531479278\n# source2:\n# \"https://upload.wikimedia.org/wikipedia/commons/\n# thumb/3/36/Seal_of_the_President_of_the_United_States.svg/\n# 800px-Seal_of_the_President_of_the_United_States.svg.png\"\nlogo_filename = \"logo_resized.png\"\n\ndata = {\n    \"country\": [\n        \"China\",\n        \"European Union\",\n        \"Vietnam\",\n        \"Taiwan\",\n        \"Japan\",\n        \"India\",\n        \"South Korea\",\n        \"Thailand\",\n        \"Switzerland\",\n        \"Indonesia\",\n        \"Malaysia\",\n        \"Cambodia\",\n        \"United Kingdom\",\n        \"South Africa\",\n        \"Brazil\",\n        \"Bangladesh\",\n        \"Singapore\",\n        \"Israel\",\n        \"Philippines\",\n        \"Chile\",\n        \"Australia\",\n        \"Pakistan\",\n        \"Turkey\",\n        \"Sri Lanka\",\n        \"Colombia\",\n    ],\n    \"tariffs_charged\": [\n        \"67%\",\n        \"39%\",\n        \"90%\",\n        \"64%\",\n        \"46%\",\n        \"52%\",\n        \"50%\",\n        \"72%\",\n        \"61%\",\n        \"64%\",\n        \"47%\",\n        \"97%\",\n        \"10%\",\n        \"60%\",\n        \"10%\",\n        \"74%\",\n        \"10%\",\n        \"33%\",\n        \"34%\",\n        \"10%\",\n        \"10%\",\n        \"58%\",\n        \"10%\",\n        \"88%\",\n        \"10%\",\n    ],\n    \"reciprocal_tariffs\": [\n        \"34%\",\n        \"20%\",\n        \"46%\",\n        \"32%\",\n        \"24%\",\n        \"26%\",\n        \"25%\",\n        \"36%\",\n        \"31%\",\n        \"32%\",\n        \"24%\",\n        \"49%\",\n        \"10%\",\n        \"30%\",\n        \"10%\",\n        \"37%\",\n        \"10%\",\n        \"17%\",\n        \"17%\",\n        \"10%\",\n        \"10%\",\n        \"29%\",\n        \"10%\",\n        \"44%\",\n        \"10%\",\n    ],\n}\n\ncountry, tariffs_charged, reciprocal_tariffs = data.keys()\n\ndark_navy_blue = \"#0B162A\"  # background\nlight_blue = \"#B5D3E7\"  # row\nwhite = \"#FFFFFF\"  # row\nyellow = \"#F6D588\"  # \"reciprocal_tariffs\" column\ngold = \"#FFF8DE\"  # logo\n\nfontname_georgia = \"Georgia\"  # title\nfontname_roboto = \"Roboto\"  # body\n\n\ndef tweak_df() -&gt; pl.DataFrame:\n    # column width\n    x_col1_start, x_col1_end = 5, 52.5\n    x_col2_start, x_col2_end = 60, 75\n    x_col3_start, x_col3_end = 82.5, 97.5\n\n    # x-position for body text\n    x_col1_text = 5\n    x_col2_text = x_col2_start + (x_col2_end - x_col2_start) / 3 + 1\n    x_col3_text = x_col3_start + (x_col3_end - x_col3_start) / 3 + 1\n\n    return (\n        pl.DataFrame(data)\n        .with_row_index()\n        .with_columns(\n            pl.col(country).cast(pl.Categorical),\n            pl.when(pl.col(\"index\").mod(2).eq(0))\n            .then(pl.lit(light_blue))\n            .otherwise(pl.lit(white))\n            .alias(\"color_mod\"),\n            pl.lit(x_col1_start).alias(\"x_col1_start\"),\n            pl.lit(x_col1_end).alias(\"x_col1_end\"),\n            pl.lit(x_col2_start).alias(\"x_col2_start\"),\n            pl.lit(x_col2_end).alias(\"x_col2_end\"),\n            pl.lit(x_col3_start).alias(\"x_col3_start\"),\n            pl.lit(x_col3_end).alias(\"x_col3_end\"),\n            pl.lit(x_col1_text).alias(\"x_col1_text\"),\n            pl.lit(x_col2_text).alias(\"x_col2_text\"),\n            pl.lit(x_col3_text).alias(\"x_col3_text\"),\n        )\n    )\n\n\ndef get_textdata_df(x_ref: float = 0.0, y_ref: float = 0.0) -&gt; pl.DataFrame:\n    title_fontsize = 16\n    title_fontweight = \"bold\"\n    heading_fontsize = 8\n    heading_fontweight = \"bold\"\n    subheading_fontsize = 6\n    subheading_fontweight = \"normal\"\n\n    textdata_df = pl.DataFrame(\n        {\n            \"label\": [\n                \"Reciprocal Tariffs\",  # title\n                \"Country\",  # col1\n                \"Tariffs Charged\",  # col2\n                \"to the U.S.A.\",\n                \"Including\",\n                \"Currency Manipulation\",\n                \"and Trade Barriers\",\n                \"U.S.A. Discounted\",  # col3\n                \"Reciprocal Tariffs\",\n            ],\n            \"x\": [\n                x_ref + 34.0,\n                x_ref + 29.5,\n                x_ref + 67.5,\n                x_ref + 67.5,\n                x_ref + 67.5,\n                x_ref + 67.5,\n                x_ref + 67.5,\n                x_ref + 89.5,\n                x_ref + 89.5,\n            ],\n            \"y\": [\n                y_ref + 27,\n                y_ref + 25.5,\n                y_ref + 26.8,\n                y_ref + 26.4,\n                y_ref + 26.1,\n                y_ref + 25.8,\n                y_ref + 25.5,\n                y_ref + 26.0,\n                y_ref + 25.6,\n            ],\n            \"color\": [\n                gold,\n                white,\n                white,\n                white,\n                white,\n                white,\n                white,\n                white,\n                white,\n            ],\n            \"fontsize\": [\n                title_fontsize,\n                heading_fontsize,\n                heading_fontsize,\n                heading_fontsize,\n                subheading_fontsize,\n                subheading_fontsize,\n                subheading_fontsize,\n                heading_fontsize,\n                heading_fontsize,\n            ],\n            \"fontweight\": [\n                title_fontweight,\n                heading_fontweight,\n                heading_fontweight,\n                heading_fontweight,\n                subheading_fontweight,\n                subheading_fontweight,\n                subheading_fontweight,\n                heading_fontweight,\n                heading_fontweight,\n            ],\n            \"fontname\": [\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n            ],\n        }\n    )\n    return textdata_df\n\n\ndef plot_g() -&gt; ggplot:\n    geom_segment_props = {\"size\": 8, \"lineend\": \"round\"}\n\n    geom_text_props = {\n        \"ha\": \"left\",\n        \"va\": \"center\",\n        \"position\": position_nudge(y=-0.08),\n        \"size\": 10,\n        \"fontweight\": \"bold\",\n    }\n\n    return (\n        ggplot(data=df, mapping=aes(y=country, yend=country))\n        # col1 segment\n        + geom_segment(\n            mapping=aes(x=\"x_col1_start\", xend=\"x_col1_end\", color=\"color_mod\"),\n            **geom_segment_props,\n        )\n        # col2 segment\n        + geom_segment(\n            mapping=aes(x=\"x_col2_start\", xend=\"x_col2_end\", color=\"color_mod\"),\n            **geom_segment_props,\n        )\n        # col3 segment\n        + geom_segment(\n            mapping=aes(x=\"x_col3_start\", xend=\"x_col3_end\"),\n            color=yellow,\n            **geom_segment_props,\n        )\n        # col1 text\n        + geom_text(aes(x=\"x_col1_text\", label=country), **geom_text_props)\n        # col2 text\n        + geom_text(aes(x=\"x_col2_text\", label=tariffs_charged), **geom_text_props)\n        # col3 text\n        + geom_text(aes(x=\"x_col3_text\", label=reciprocal_tariffs), **geom_text_props)\n        # using \"color_mod\" column directly\n        + scale_color_identity()\n        # expand extra space\n        + scale_y_discrete(\n            limits=df.select(country).reverse().to_series().to_list(),\n            expand=(0.02, 0, 0, 1.5),\n        )\n        # title and headers\n        + geom_text(\n            data=textdata_df,\n            mapping=aes(\n                x=\"x\",\n                y=\"y\",\n                label=\"label\",\n                color=\"color\",\n                size=\"fontsize\",\n                fontweight=\"fontweight\",\n                fontname=\"fontname\",\n            ),\n            va=\"bottom\",\n            ha=\"center\",\n        )\n        # using \"size\" column directly\n        + scale_size_identity()\n        # logo\n        + watermark(logo_filename, 100, 2235)\n    )\n\n\ndef themify(p: ggplot) -&gt; Figure:\n    return (\n        p\n        + theme_void()\n        + theme(\n            legend_position=\"none\",  # turns off the legend\n            axis_text_x=element_blank(),\n            axis_text_y=element_blank(),\n            axis_title_x=element_blank(),\n            axis_title_y=element_blank(),\n            panel_background=element_rect(fill=dark_navy_blue),\n            plot_background=element_rect(fill=dark_navy_blue),\n            text=element_text(family=fontname_roboto),\n            dpi=300,\n            figure_size=(6, 8),\n        )\n    ).draw(False)\n\n\ndf = tweak_df()\ntextdata_df = get_textdata_df()\np = plot_g()\nfig = themify(p)\nfig"
  },
  {
    "objectID": "posts/clone-reciprocal-tariffs-table-p9/20250416.html#preparing-the-dataframes",
    "href": "posts/clone-reciprocal-tariffs-table-p9/20250416.html#preparing-the-dataframes",
    "title": "Clone the Reciprocal Tariffs Table Using Plotnine",
    "section": "Preparing the DataFrames",
    "text": "Preparing the DataFrames\n\nMain DataFrame\nWe start by extracting the data from a previous project. The country column is converted to a categorical type, which simplifies handling in plotnine. To enable alternating row colors in the final visualization, we also create a new column called color_mod. Additional columns are created to define the positions for the segments and text labels.\ndef tweak_df() -&gt; pl.DataFrame:\n    # column width\n    x_col1_start, x_col1_end = 5, 52.5\n    x_col2_start, x_col2_end = 60, 75\n    x_col3_start, x_col3_end = 82.5, 97.5\n\n    # x-position for body text\n    x_col1_text = 5\n    x_col2_text = x_col2_start + (x_col2_end - x_col2_start) / 3 + 1\n    x_col3_text = x_col3_start + (x_col3_end - x_col3_start) / 3 + 1\n\n    return (\n        pl.DataFrame(data)\n        .with_row_index()\n        .with_columns(\n            pl.col(country).cast(pl.Categorical),\n            pl.when(pl.col(\"index\").mod(2).eq(0))\n            .then(pl.lit(light_blue))\n            .otherwise(pl.lit(white))\n            .alias(\"color_mod\"),\n            pl.lit(x_col1_start).alias(\"x_col1_start\"),\n            pl.lit(x_col1_end).alias(\"x_col1_end\"),\n            pl.lit(x_col2_start).alias(\"x_col2_start\"),\n            pl.lit(x_col2_end).alias(\"x_col2_end\"),\n            pl.lit(x_col3_start).alias(\"x_col3_start\"),\n            pl.lit(x_col3_end).alias(\"x_col3_end\"),\n            pl.lit(x_col1_text).alias(\"x_col1_text\"),\n            pl.lit(x_col2_text).alias(\"x_col2_text\"),\n            pl.lit(x_col3_text).alias(\"x_col3_text\"),\n        )\n    )\n\ndf = tweak_df()\n\n\nTextdata DataFrame\nNext, we create another DataFrame that contains information for all the text elements, such as text color, font size, and font weight, for the title and headers.\ndef get_textdata_df(\n    x_ref: float = 0.0, y_ref: float = 0.0\n) -&gt; pl.DataFrame:\n    title_fontsize = 16\n    title_fontweight = \"bold\"\n    heading_fontsize = 8\n    heading_fontweight = \"bold\"\n    subheading_fontsize = 6\n    subheading_fontweight = \"normal\"\n\n    textdata_df = pl.DataFrame(\n        {\n            \"label\": [\n                \"Reciprocal Tariffs\",  # title\n                \"Country\",  # col1\n                \"Tariffs Charged\",  # col2\n                \"to the U.S.A.\",\n                \"Including\",\n                \"Currency Manipulation\",\n                \"and Trade Barriers\",\n                \"U.S.A. Discounted\",  # col3\n                \"Reciprocal Tariffs\",\n            ],\n            \"x\": [\n                x_ref + 34.0,\n                x_ref + 29.5,\n                x_ref + 67.5,\n                x_ref + 67.5,\n                x_ref + 67.5,\n                x_ref + 67.5,\n                x_ref + 67.5,\n                x_ref + 89.5,\n                x_ref + 89.5,\n            ],\n            \"y\": [\n                y_ref + 27,\n                y_ref + 25.5,\n                y_ref + 26.8,\n                y_ref + 26.4,\n                y_ref + 26.1,\n                y_ref + 25.8,\n                y_ref + 25.5,\n                y_ref + 26.0,\n                y_ref + 25.6,\n            ],\n            \"color\": [\n                gold,\n                white,\n                white,\n                white,\n                white,\n                white,\n                white,\n                white,\n                white,\n            ],\n            \"fontsize\": [\n                title_fontsize,\n                heading_fontsize,\n                heading_fontsize,\n                heading_fontsize,\n                subheading_fontsize,\n                subheading_fontsize,\n                subheading_fontsize,\n                heading_fontsize,\n                heading_fontsize,\n            ],\n            \"fontweight\": [\n                title_fontweight,\n                heading_fontweight,\n                heading_fontweight,\n                heading_fontweight,\n                subheading_fontweight,\n                subheading_fontweight,\n                subheading_fontweight,\n                heading_fontweight,\n                heading_fontweight,\n            ],\n            \"fontname\": [\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n            ],\n        }\n    )\n    return textdata_df\n\ntextdata_df = get_textdata_df()"
  },
  {
    "objectID": "posts/clone-reciprocal-tariffs-table-p9/20250416.html#constructing-the-ggplot-object",
    "href": "posts/clone-reciprocal-tariffs-table-p9/20250416.html#constructing-the-ggplot-object",
    "title": "Clone the Reciprocal Tariffs Table Using Plotnine",
    "section": "Constructing the ggplot Object",
    "text": "Constructing the ggplot Object\nWith the processed DataFrame ready, we can now build the ggplot() object:\ndef plot_g() -&gt; ggplot:\n    geom_segment_props = {\"size\": 8, \"lineend\": \"round\"}\n\n    geom_text_props = {\n        \"ha\": \"left\",\n        \"va\": \"center\",\n        \"position\": position_nudge(y=-0.08),\n        \"size\": 10,\n        \"fontweight\": \"bold\",\n    }\n\n    return (\n        ggplot(data=df, mapping=aes(y=country, yend=country))\n        # col1 segment\n        + geom_segment(\n            mapping=aes(x=\"x_col1_start\", xend=\"x_col1_end\", color=\"color_mod\"),\n            **geom_segment_props,\n        )\n        # col2 segment\n        + geom_segment(\n            mapping=aes(x=\"x_col2_start\", xend=\"x_col2_end\", color=\"color_mod\"),\n            **geom_segment_props,\n        )\n        # col3 segment\n        + geom_segment(\n            mapping=aes(x=\"x_col3_start\", xend=\"x_col3_end\"),\n            color=yellow,\n            **geom_segment_props,\n        )\n        # col1 text\n        + geom_text(aes(x=\"x_col1_text\", label=country), **geom_text_props)\n        # col2 text\n        + geom_text(aes(x=\"x_col2_text\", label=tariffs_charged), **geom_text_props)\n        # col3 text\n        + geom_text(aes(x=\"x_col3_text\", label=reciprocal_tariffs), **geom_text_props)\n        # using \"color_mod\" column directly\n        + scale_color_identity()\n        # expand extra space\n        + scale_y_discrete(\n            limits=df.select(country).reverse().to_series().to_list(),\n            expand=(0.02, 0, 0, 1.5),\n        )\n        # title and headers\n        + geom_text(\n1            data=textdata_df,\n            mapping=aes(\n                x=\"x\",\n                y=\"y\",\n                label=\"label\",\n                color=\"color\",\n                size=\"fontsize\",\n                fontweight=\"fontweight\",\n                fontname=\"fontname\",\n            ),\n            va=\"bottom\",\n            ha=\"center\",\n        )\n        # using \"size\" column directly\n        + scale_size_identity()\n        # logo\n        + watermark(logo_filename, 100, 2235)\n    )\n\n1\n\nThe data= argument is set to textdata_df, which contains all the custom label and styling details for the title and column headers.\n\n\n\nWhat’s happening here?\n\ngeom_segment(): Since I couldn’t find a way to apply border radius, I used geom_segment() with lineend=\"round\" as the best available workaround. Thick lines serve as cell backgrounds.\ngeom_text(): Adds text for each column.\nscale_color_identity(): Uses the color values directly from the color_mod column, without applying a scale.\nscale_y_discrete(): Reorders the country axis and tweaks padding to add space above and below the table.\nscale_size_identity(): Similar to color scaling, this instructs plotnine to use the font sizes specified in the fontsize column without transformation.\nwatermark(): Embeds a logo. Since there’s no native figure size parameter in plotnine, I manually scaled the output."
  },
  {
    "objectID": "posts/clone-reciprocal-tariffs-table-p9/20250416.html#custom-theme",
    "href": "posts/clone-reciprocal-tariffs-table-p9/20250416.html#custom-theme",
    "title": "Clone the Reciprocal Tariffs Table Using Plotnine",
    "section": "Custom Theme",
    "text": "Custom Theme\nWe apply a tailored theme with themify() to refine the figure’s appearance:\ndef themify(p: ggplot) -&gt; Figure:\n    return (\n        p\n        + theme_void()\n        + theme(\n            legend_position=\"none\",  # turns off the legend\n            axis_text_x=element_blank(),\n            axis_text_y=element_blank(),\n            axis_title_x=element_blank(),\n            axis_title_y=element_blank(),\n            panel_background=element_rect(fill=dark_navy_blue),\n            plot_background=element_rect(fill=dark_navy_blue),\n            text=element_text(family=fontname_roboto),\n            dpi=300,\n            figure_size=(6, 8),\n        )\n    ).draw(False)"
  },
  {
    "objectID": "posts/clone-reciprocal-tariffs-table-p9/20250416.html#final-rendering",
    "href": "posts/clone-reciprocal-tariffs-table-p9/20250416.html#final-rendering",
    "title": "Clone the Reciprocal Tariffs Table Using Plotnine",
    "section": "Final Rendering",
    "text": "Final Rendering\nNow, let’s tie it all together:\np = plot_g()\nfig = themify(p)\nfig"
  },
  {
    "objectID": "posts/clone-reciprocal-tariffs-table-p9/20250416.html#closing-thoughts",
    "href": "posts/clone-reciprocal-tariffs-table-p9/20250416.html#closing-thoughts",
    "title": "Clone the Reciprocal Tariffs Table Using Plotnine",
    "section": "Closing Thoughts",
    "text": "Closing Thoughts\nThis post showcases how plotnine can be used to create table-like visualizations. I’m genuinely impressed by its capabilities — it’s surprisingly fun to approach a table as a figure.\nThroughout this exploration, I learned a lot from this repository, which won the Plotnine Contest 2024. It’s a fantastic example of what’s possible with the library.\nIt would be exciting to explore how plotnine and Great Tables might work together to enable even richer visual storytelling — I’m looking forward to diving into that next.\n\n\n\n\n\n\nDisclaimer\n\n\n\n\nThis table is intended as a self-practice project, and the data in the table may not be 100% accurate. Please refer to the original source if you require verified data.\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/access-axes-in-plotnine/20250411.html",
    "href": "posts/access-axes-in-plotnine/20250411.html",
    "title": "How to Access the Axes in Plotnine",
    "section": "",
    "text": "This is a short post documenting my experience trying to retrieve the Axes from plotnine.\nThe idea was inspired by this code and this video I came across, but the original solution didn’t quite work for me. Fortunately, I found that we can access the list of Axes directly using either fig.axes or fig.get_axes().\nIn the example below, I adapt a snippet from the plotnine documentation to demonstrate how to highlight text in color using HighlightText.\n\n\n\n\n\n\nimport highlight_text as ht\nfrom plotnine import aes, geom_point, ggplot, labs, theme_matplotlib, theme_set\nfrom plotnine.data import mpg\n\ntheme_set(theme_matplotlib())\n\np = (\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\nfig = p.draw()\nax = fig.axes[0]  # or via fig.get_axes()[0]\nht_ax_text = 'Color highlighted by &lt;HighlightText::{\"color\": \"#E58606\"}&gt;'\nht.ax_text(4, 40, ht_ax_text, vsep=3, fontsize=9, va=\"top\", ax=ax)\nfig\n\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html",
    "href": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html",
    "title": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib",
    "section": "",
    "text": "It was an honor to be one of the reviewers for Matt Harrison’s new book, Effective Visualization. If you’re looking to deepen your understanding of how to use Pandas and Matplotlib to craft compelling data stories, this book is a must-read.\nLast weekend, I decided to convert some of the Pandas code from the book into Polars just for fun, and I’d like to share an example in this post. You can find the original Pandas code in the repo (empty link for now).\nThe final figure, shown below, visualizes temperature trends for the ski season in Alta over the past few decades.\nShow full code\nimport matplotlib.pyplot as plt\nimport polars as pl\nimport polars.selectors as cs\nfrom highlight_text import ax_text\nfrom matplotlib import colormaps\n\n# https://github.com/mattharrison/datasets/raw/refs/heads/master/data/alta-noaa-1980-2019.csv\ndata_path = \"alta-noaa-1980-2019.csv\"\ncolumns = [\"DATE\", \"TOBS\"]\nidx_colname = \"DAY_OF_SEASON\"\n\n\ndef tweak_df(data_path: str, columns: list[str], idx_colname: str = \"DAY_OF_SEASON\"):\n    return (\n        pl.scan_csv(data_path)\n        .select(columns)\n        .with_columns(\n            pl.col(\"DATE\").str.to_datetime(),\n            pl.col(\"TOBS\").interpolate(),\n        )\n        .sort(\"DATE\")\n        .with_columns(\n            # Caveat: Cannot be placed in the previous `with_columns()`\n            # due to different statuses of `TOBS`.\n            pl.col(\"TOBS\").rolling_mean(window_size=28, center=True).alias(\"TMEAN\"),\n            get_season_expr(col=\"DATE\", alias=\"SEASON\"),\n        )\n        .with_columns(\n            add_day_of_season_expr(col=\"DATE\", group_col=\"SEASON\", alias=idx_colname)  #\n        )\n        .collect()\n    )\n\n\ndef get_season_expr(col: str = \"DATE\", alias: str = \"SEASON\") -&gt; pl.expr:\n    return (\n        (\n            pl.when((pl.col(col).dt.month().is_between(5, 10, closed=\"both\")))\n            .then(pl.lit(\"Summer \"))\n            .otherwise(pl.lit(\"Ski \"))\n        )\n        .add(\n            pl.when(pl.col(col).dt.month() &lt; 11)\n            .then(pl.col(col).dt.year().cast(pl.String))\n            .otherwise(pl.col(col).dt.year().add(1).cast(pl.String))\n        )\n        .alias(alias)\n    )\n\n\ndef add_day_of_season_expr(\n    col: str = \"DATE\", group_col: str = \"SEASON\", alias: str = \"DAY_OF_SEASON\"\n) -&gt; pl.expr:\n    return (\n        (pl.col(col) - pl.col(col).min()).dt.total_days().over(group_col).alias(alias)\n    )\n\n\ndef plot_temps(_df: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\") -&gt; pl.DataFrame:\n    plt.rcParams[\"font.family\"] = \"Roboto\"\n    figsize = (160, 165)  # pts\n\n    def points_to_inches(points):\n        return points / 72\n\n    figsize_inches = [points_to_inches(dim) for dim in figsize]\n\n    heading_fontsize = 9.5\n    heading_fontweight = \"bold\"\n    subheading_fontsize = 8\n    subheading_fontweight = \"normal\"\n    source_fontsize = 6.5\n    source_fontweight = \"light\"\n    axis_fontsize = 7\n    axis_fontweight = \"normal\"\n\n    grey = \"#aaaaaa\"\n    red = \"#e3120b\"\n    blue = \"#0000ff\"\n    cmap = colormaps.get_cmap(\"Grays\")\n\n    layout = [[\"title\"], [\"plot\"], [\"notes\"]]\n    fig, axs = plt.subplot_mosaic(\n        layout,\n        gridspec_kw={\"height_ratios\": [6, 12, 1]},\n        figsize=figsize_inches,\n        dpi=300,\n        constrained_layout=True,\n    )\n\n    # ----- Title -----\n    ax_title = axs[\"title\"]\n    ax_title.axis(\"off\")\n    sub_props = {\"fontsize\": subheading_fontsize, \"fontweight\": subheading_fontweight}\n    ax_text(\n        s=\"&lt;Alta Ski Resort&gt;\\n&lt;Temperature trends by &gt;\\n&lt;decade&gt;&lt; and &gt;&lt;2019&gt;\",\n        x=0,\n        y=0,\n        fontsize=heading_fontsize,\n        ax=ax_title,\n        va=\"bottom\",\n        ha=\"left\",\n        zorder=5,\n        highlight_textprops=[\n            {\"fontsize\": heading_fontsize, \"fontweight\": heading_fontweight},\n            sub_props,\n            {\"color\": blue, **sub_props},\n            sub_props,\n            {\"color\": red, **sub_props},\n        ],\n    )\n\n    # ----- Plot -----\n    ax = axs[\"plot\"]\n    season_temps = _df.filter(pl.col(\"SEASON\").str.contains(\"Ski\")).pivot(\n        \"SEASON\", index=idx_colname, values=\"TMEAN\", aggregate_function=\"first\"\n    )\n    season_temps_index = season_temps[idx_colname]\n\n    columns = season_temps.columns\n    columns.remove(idx_colname)\n    columns.remove(\"Ski 2019\")\n    for i, column in enumerate(columns):\n        color = cmap(i / len(columns))\n        ax.plot(\n            season_temps_index,\n            season_temps[column],\n            color=color,\n            linewidth=1,\n            alpha=0.2,\n            zorder=1,\n        )\n\n    # # ---- Decade Averages ----\n    decades = [1980, 1990, 2000, 2010]\n    blues = [\"#0055EE\", \"#0033CC\", \"#0011AA\", \"#3377FF\"]\n    for decade, color in zip(decades, blues):\n        match = str(decade)[:-1]  # 1980 -&gt; \"198\", 2010 -&gt; \"201\"\n        decade_temps = season_temps.select(cs.contains(match)).mean_horizontal()\n        ax.plot(season_temps_index, decade_temps, color=color, linewidth=1)\n\n        # add label to right of line\n        last_y_label = decade_temps.last()\n\n        if decade == 2000:\n            last_y_label -= 3\n        elif decade == 2010:\n            last_y_label -= 0.3\n\n        ax.text(\n            185,\n            last_y_label,\n            f\"{decade}\",\n            va=\"center\",\n            ha=\"left\",\n            fontsize=axis_fontsize,\n            fontweight=axis_fontweight,\n            color=color,\n        )\n        # # add dot to start and end of each line\n        ax.plot(\n            season_temps_index.first(),\n            decade_temps.first(),\n            marker=\"o\",\n            color=color,\n            markersize=1,\n            zorder=2,\n        )\n        ax.plot(\n            season_temps_index.last(),\n            decade_temps.last(),\n            marker=\"o\",\n            color=color,\n            markersize=1,\n            zorder=2,\n        )\n\n    # # ------ Ski 2019 ------\n    # # plot `Ski 2019` in red\n    ski_2019 = season_temps.select(idx_colname, cs.by_name(\"Ski 2019\")).drop_nulls()\n    ski_2019_index = ski_2019[idx_colname]\n    ski_2019 = ski_2019.drop([idx_colname]).to_series()\n    ax.plot(ski_2019_index, ski_2019, color=\"red\", linewidth=1)\n\n    # add dot to start and end of each line\n    ax.plot(\n        ski_2019_index.first(),\n        ski_2019.first(),\n        marker=\"o\",\n        color=\"red\",\n        markersize=2,\n        zorder=2,\n    )\n    ax.plot(\n        ski_2019_index.last(),\n        ski_2019.last(),\n        marker=\"o\",\n        color=\"red\",\n        markersize=2,\n        zorder=2,\n    )\n\n    # # ------ Ticks & Lines ------\n    # # remove spines\n    for side in [\"top\", \"left\", \"right\"]:\n        ax.spines[side].set_visible(False)\n\n    # # add horizontal line at 32F\n    ax.axhline(32, color=\"black\", linestyle=\"--\", linewidth=1, zorder=1)\n\n    # # set y ticks\n    ax.set_yticks(ticks=[10, 32, 40])\n\n    # # set y limit\n    ax.set_ylim([10, 55])\n\n    # # set x label\n    ax.set_xlabel(\"Day of season\", fontsize=axis_fontsize, fontweight=axis_fontweight)\n\n    # # ------ Source ------\n    ax_notes = axs[\"notes\"]\n    # add source\n    ax_notes.axis(\"off\")\n    ax_notes.text(\n        0,\n        0,\n        \"Source: NOAA\",\n        fontsize=source_fontsize,\n        fontweight=source_fontweight,\n        color=grey,\n    )\n    return _df\n\n\ndf = tweak_df(data_path, columns, idx_colname)\ndf.pipe(plot_temps, idx_colname)"
  },
  {
    "objectID": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#data-processing-pipeline",
    "href": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#data-processing-pipeline",
    "title": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib",
    "section": "Data Processing Pipeline",
    "text": "Data Processing Pipeline\nBelow is the data pipeline used to generate the DataFrame for the upcoming visualization stage:\ndata_path = \"alta-noaa-1980-2019.csv\"\ncolumns = [\"DATE\", \"TOBS\"]\nidx_colname = \"DAY_OF_SEASON\"\n\n\ndef tweak_df(data_path: str, columns: list[str], idx_colname: str = \"DAY_OF_SEASON\"):\n    return (\n        pl.scan_csv(data_path)\n1        .select(columns)\n        .with_columns(\n2            pl.col(\"DATE\").str.to_datetime(),\n3            pl.col(\"TOBS\").interpolate(),\n        )\n        .sort(\"DATE\")\n        .with_columns(\n            # Caveat: Cannot be placed in the previous `with_columns()`\n            # due to different statuses of `TOBS`.\n4            pl.col(\"TOBS\").rolling_mean(window_size=28, center=True).alias(\"TMEAN\"),\n5            get_season_expr(col=\"DATE\", alias=\"SEASON\"),\n        )\n        .with_columns(\n6            add_day_of_season_expr(col=\"DATE\", group_col=\"SEASON\", alias=idx_colname)\n        )\n        .collect()\n    )\n\ndf = tweak_df(data_path, columns, idx_colname)\n\n1\n\nSelect the DATE column (dates) and TOBS column (recorded temperatures in Fahrenheit).\n\n2\n\nConvert the DATE column to a datetime format.\n\n3\n\nPerform interpolation on the TOBS column.\n\n4\n\nCompute a 28-day rolling average for TOBS.\n\n5\n\nUse get_season_expr() to categorize each date into a SEASON.\n\n6\n\nApply add_day_of_season_expr() to calculate DAY_OF_SEASON, representing days elapsed since the start of the season.\n\n\nThe first three steps involve straightforward Polars expressions. In the following sections, we’ll dive deeper into steps 5 to 6.\n\nCategorizing Dates into Summer and Ski Seasons\nTo analyze seasonal trends, we classify dates into two categories:\n\nSummer: Covers May through October.\n\nSki: Covers November through April.\n\nIf a date falls in November or December, it is assigned to the following year’s season. For example, 2015-10-31 is categorized as Summer 2015, while 2015-11-01 belongs to Ski 2016.\nTo implement this logic, we define get_season_expr(), which leverages Polars’ when-then-otherwise expressions to determine the season and year.\ndef get_season_expr(col: str = \"DATE\", alias: str = \"SEASON\") -&gt; pl.expr:\n    return (\n        (\n            pl.when((pl.col(col).dt.month().is_between(5, 10, closed=\"both\")))\n            .then(pl.lit(\"Summer \"))\n            .otherwise(pl.lit(\"Ski \"))\n        )\n        .add(\n            pl.when(pl.col(col).dt.month() &lt; 11)\n            .then(pl.col(col).dt.year().cast(pl.String))\n            .otherwise(pl.col(col).dt.year().add(1).cast(pl.String))\n        )\n        .alias(alias)\n    )\nIn this function:\n\nIf the month is between May and October, the function assigns \"Summer \". Otherwise, it assigns \"Ski \" (with a trailing space for concatenation).\n\nThe year is determined based on the month: dates from January to October retain their current year, while those in November and December are shifted to the next year.\n\nBy applying this function, we can add a SEASON column to a Polars DataFrame, ensuring each date is categorized correctly.\n\n\nCalculating the Total Days for Each Season\nOnce we have the seasonal categories, we calculate DAY_OF_SEASON, which tracks the number of days elapsed within each season. This is achieved using the pl.expr.over() expression, which operates similarly to Pandas’ groupby().transform(), applying transformations within groups.\ndef add_day_of_season_expr(\n    col: str = \"DATE\", group_col: str = \"SEASON\", alias: str = \"DAY_OF_SEASON\"\n) -&gt; pl.expr:\n    return (\n        (pl.col(col) - pl.col(col).min()).dt.total_days().over(group_col).alias(alias)\n    )"
  },
  {
    "objectID": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#visualizing-temperature-trends-with-matplotlib",
    "href": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#visualizing-temperature-trends-with-matplotlib",
    "title": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib",
    "section": "Visualizing Temperature Trends with Matplotlib",
    "text": "Visualizing Temperature Trends with Matplotlib\nWith the data prepared, we move on to plotting. Since plot_temps() is quite long, we’ll break it down into several parts for easier explanation.\n\nSetting Up the Figure\nWe start by defining some parameters and using plt.subplot_mosaic() to create the figure layout. This provides structured axes for different elements of the visualization.\ndef plot_temps(_df: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\") -&gt; pl.DataFrame:\n    plt.rcParams[\"font.family\"] = \"Roboto\"\n    figsize = (160, 165)  # pts\n\n    def points_to_inches(points):\n        return points / 72\n\n    figsize_inches = [points_to_inches(dim) for dim in figsize]\n\n    heading_fontsize = 9.5\n    heading_fontweight = \"bold\"\n    subheading_fontsize = 8\n    subheading_fontweight = \"normal\"\n    source_fontsize = 6.5\n    source_fontweight = \"light\"\n    axis_fontsize = 7\n    axis_fontweight = \"normal\"\n\n    grey = \"#aaaaaa\"\n    red = \"#e3120b\"\n    blue = \"#0000ff\"\n    cmap = colormaps.get_cmap(\"Grays\")\n\n    layout = [[\"title\"], [\"plot\"], [\"notes\"]]\n    fig, axs = plt.subplot_mosaic(\n        layout,\n        gridspec_kw={\"height_ratios\": [6, 12, 1]},\n        figsize=figsize_inches,\n        dpi=300,\n        constrained_layout=True,\n    )\n    ...\n    \n\n\nAdding the Title\nFor the title, we use ax_text() from the HighlightText library, which allows selective styling of text enclosed in &lt; &gt;. This lets us highlight key parts of the title, such as &lt;Alta Ski Resort&gt;, &lt;Temperature trends by &gt;, &lt;decade&gt;, &lt; and &gt;, and &lt;2019&gt;, with custom formatting.\ndef plot_temps(\n    _df: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    ...\n\n    # ----- Title -----\n    ax_title = axs[\"title\"]\n    ax_title.axis(\"off\")\n    sub_props = {\"fontsize\": subheading_fontsize, \"fontweight\": subheading_fontweight}\n    ax_text(\n        s=\"&lt;Alta Ski Resort&gt;\\n&lt;Temperature trends by &gt;\\n&lt;decade&gt;&lt; and &gt;&lt;2019&gt;\",\n        x=0,\n        y=0,\n        fontsize=heading_fontsize,\n        ax=ax_title,\n        va=\"bottom\",\n        ha=\"left\",\n        zorder=5,\n        highlight_textprops=[\n            {\"fontsize\": heading_fontsize, \"fontweight\": heading_fontweight},\n            sub_props,\n            {\"color\": blue, **sub_props},\n            sub_props,\n            {\"color\": red, **sub_props},\n        ],\n    )\n\n\nPlotting Seasonal Trends\nNext, we generate the main plot by:\n\nFiltering the dataset for Ski seasons.\n\nPivoting the table to organize TMEAN values by DAY_OF_SEASON and SEASON.\n\nUsing ax.plot() to draw a separate line for each Ski season.\n\ndef plot_temps(\n    _df: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    ...\n\n    # ----- Plot -----\n    ax = axs[\"plot\"]\n    season_temps = _df.filter(pl.col(\"SEASON\").str.contains(\"Ski\")).pivot(\n        \"SEASON\", index=idx_colname, values=\"TMEAN\", aggregate_function=\"first\"\n    )\n    season_temps_index = season_temps[idx_colname]\n\n    columns = season_temps.columns\n    columns.remove(idx_colname)\n    columns.remove(\"Ski 2019\")\n    for i, column in enumerate(columns):\n        color = cmap(i / len(columns))\n        ax.plot(\n            season_temps_index,\n            season_temps[column],\n            color=color,\n            linewidth=1,\n            alpha=0.2,\n            zorder=1,\n        )\nTo illustrate long-term trends, we overlay four lines representing the average temperature trends for different decades, marking their start and end points with dots for emphasis.\ndef plot_temps(\n    _df: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    ...\n\n    # # ---- Decade Averages ----\n    decades = [1980, 1990, 2000, 2010]\n    blues = [\"#0055EE\", \"#0033CC\", \"#0011AA\", \"#3377FF\"]\n    for decade, color in zip(decades, blues):\n        match = str(decade)[:-1] # 1980 -&gt; \"198\", 2010 -&gt; \"201\"\n1        decade_temps = season_temps.select(cs.contains(match)).mean_horizontal()\n        ax.plot(season_temps_index, decade_temps, color=color, linewidth=1)\n\n        # add label to right of line\n        last_y_label = decade_temps.last()\n\n        if decade == 2000:\n            last_y_label -= 3\n        elif decade == 2010:\n            last_y_label -= 0.3\n\n        ax.text(\n            185,\n            last_y_label,\n            f\"{decade}\",\n            va=\"center\",\n            ha=\"left\",\n            fontsize=axis_fontsize,\n            fontweight=axis_fontweight,\n            color=color,\n        )\n        # # add dot to start and end of each line\n        ax.plot(\n            season_temps_index.first(),\n            decade_temps.first(),\n            marker=\"o\",\n            color=color,\n            markersize=1,\n            zorder=2,\n        )\n        ax.plot(\n            season_temps_index.last(),\n            decade_temps.last(),\n            marker=\"o\",\n            color=color,\n            markersize=1,\n            zorder=2,\n        )\n\n1\n\nWe leverage two powerful features of Polars: Polars selectors, which enable efficient column selection based on name patterns to extract data for each decade (cs.contains(match)), and df.mean_horizontal(), which performs vectorized operations across columns to compute the average temperature for each decade.\n\n\n\n\nHighlighting the 2019 Ski Season\nTo make Ski 2019 stand out, we plot its trend in red and highlight its start and end points with dots, similar to the decade lines.\ndef plot_temps(\n    _df: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    ...\n\n    # # ------ Ski 2019 ------\n    # # plot `Ski 2019` in red\n1    ski_2019 = season_temps.select(idx_colname, cs.by_name(\"Ski 2019\")).drop_nulls()\n    ski_2019_index = ski_2019[idx_colname]\n    ski_2019 = ski_2019.drop([idx_colname]).to_series()\n    ax.plot(ski_2019_index, ski_2019, color=\"red\", linewidth=1)\n\n    # add dot to start and end of each line\n    ax.plot(\n        ski_2019_index.first(),\n        ski_2019.first(),\n        marker=\"o\",\n        color=\"red\",\n        markersize=2,\n        zorder=2,\n    )\n    ax.plot(\n        ski_2019_index.last(),\n        ski_2019.last(),\n        marker=\"o\",\n        color=\"red\",\n        markersize=2,\n        zorder=2,\n    )\n\n1\n\nWe use the Polars selector (cs.by_name()) to isolate the Ski 2019 data.\n\n\n\n\nRefinements for Clarity\nTo enhance readability, we refine the visualization by adjusting:\n\nSpines: Removing unnecessary borders.\n\nReference Line: Adding a horizontal dashed line at 32°F for context.\n\nTicks & Limits: Setting appropriate y-axis ticks and limits.\n\nLabels: Customizing the x-axis label for clarity.\n\ndef plot_temps(\n    _df: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    ...\n\n    # # ------ Ticks & Lines ------\n    # # remove spines\n    for side in [\"top\", \"left\", \"right\"]:\n        ax.spines[side].set_visible(False)\n\n    # # add horizontal line at 32F\n    ax.axhline(32, color=\"black\", linestyle=\"--\", linewidth=1, zorder=1)\n\n    # # set y ticks\n    ax.set_yticks(ticks=[10, 32, 40])\n\n    # # set y limit\n    ax.set_ylim([10, 55])\n\n    # # set x label\n    ax.set_xlabel(\"Day of season\", fontsize=axis_fontsize, fontweight=axis_fontweight)\n\n\nAdding Notes\nFinally, we use Matplotlib’s ax.text() to annotate the source of the data.\ndef plot_temps(\n    _df: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    ...\n\n    # # ------ Source ------\n    ax_notes = axs[\"notes\"]\n    # add source\n    ax_notes.axis(\"off\")\n    ax_notes.text(\n        0,\n        0,\n        \"Source: NOAA\",\n        fontsize=source_fontsize,\n        fontweight=source_fontweight,\n        color=grey,\n    )\n    return _df"
  },
  {
    "objectID": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#rendering-the-plot",
    "href": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#rendering-the-plot",
    "title": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib",
    "section": "Rendering the Plot",
    "text": "Rendering the Plot\nFinally, we render the plot using pl.DataFrame.pipe():\ndf.pipe(plot_temps, idx_colname)"
  },
  {
    "objectID": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#wrapping-up",
    "href": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#wrapping-up",
    "title": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib",
    "section": "Wrapping Up",
    "text": "Wrapping Up\nRecreating this figure with Polars turned out to be more involved than I initially expected. However, the process was incredibly rewarding, as it deepened my understanding of Pandas, Polars, and Matplotlib. Switching between Pandas and Polars required a shift in mindset, but it also reinforced key concepts in both libraries. I look forward to exploring more of these challenges in the future.\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/gt-row-selector/20250511.html",
    "href": "posts/gt-row-selector/20250511.html",
    "title": "Custom Row Selector in Great Tables",
    "section": "",
    "text": "This short post shows how we can create custom row selectors in Great Tables by leveraging the row index. While it may or may not be adopted by the team, I thought it would be fun to document it here on the blog.\nI recently created a utility called every_n_row(), designed to work with both Pandas and Polars DataFrames (support for pyarrow is still under investigation). With every_n_row(), we can easily target alternating rows—for example, select odd rows using every_n_row(2) and even rows using either every_n_row(2, 1) or ~every_n_row(2).\n\nimport polars as pl\n\nfrom great_tables import GT, every_n_row, loc, style\nfrom great_tables.data import countrypops\n\ndf_pd = countrypops.sample(5).loc[:, [\"country_name\", \"year\", \"population\"]]\ndf_pl = pl.from_pandas(df_pd)\n\n(\n    GT(df_pd)\n    .tab_style(style=style.fill(\"lightblue\"), locations=loc.body(rows=every_n_row(2)))\n    .tab_style(style=style.fill(\"papayawhip\"), locations=loc.body(rows=every_n_row(2, 1)))\n    .opt_stylize(style=3, color=\"pink\")\n)\n\n(\n    GT(df_pl)\n    .tab_style(style=style.fill(\"lightblue\"), locations=loc.body(rows=every_n_row(2)))\n    .tab_style(style=style.fill(\"papayawhip\"), locations=loc.body(rows=~every_n_row(2)))\n    .opt_stylize(style=3, color=\"pink\")\n)\n\n\n\n\n\n\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/casewhen-in-polars/20250525.html",
    "href": "posts/casewhen-in-polars/20250525.html",
    "title": "case_when() in Polars",
    "section": "",
    "text": "This is a follow-up to my previous post.\nWhile the conditional branching mechanism of pl.when().then().otherwise() is quite powerful, I often find it a bit verbose—especially when the conditions are complex. In those cases, it becomes harder to validate the correctness of each branch at a glance.\nOn the other hand, I find the pd.Series.case_when() pattern in Pandas slightly more concise and readable. However, I’ve always wished it supported a fallback mechanism like Polars’ .otherwise().\nIn the end, I thought it would be interesting to borrow the concept behind pd.Series.case_when() and implement it as a standalone utility function in Polars."
  },
  {
    "objectID": "posts/casewhen-in-polars/20250525.html#case_when",
    "href": "posts/casewhen-in-polars/20250525.html#case_when",
    "title": "case_when() in Polars",
    "section": "case_when()",
    "text": "case_when()\nThe case_when() function accepts two arguments:\n\ncaselist: A list of two-element tuples, where the first item is the condition (used in pl.when()), and the second is the corresponding result expression (used in .then()).\notherwise: A fallback expression used in .otherwise() if no conditions match.\n\nThe given example demonstrates how case_when() can simplify conditional logic compared to the more verbose pl.when().then().otherwise() chain.\n\nfrom functools import cache\nfrom typing import Any\n\nimport polars as pl\n\n\ndef case_when(\n    caselist: list[tuple[pl.Expr, pl.Expr]], otherwise: pl.Expr | None = None\n) -&gt; pl.Expr:\n    \"\"\"\n    Simplifies conditional logic in Polars by chaining multiple `when-then` expressions.\n\n    Parameters\n    ----------\n    caselist\n        A list of (condition, value) pairs. Each condition is evaluated in order,\n        and the corresponding value is returned when a condition is met.\n    otherwise\n        The fallback value to use if none of the conditions match.\n\n    Returns\n    -------\n    pl.Expr\n\n    Examples:\n    -------\n    ```python\n    import polars as pl\n\n    df = pl.DataFrame({\"x\": [1, 2, 3, 4]})\n\n    expr = case_when(\n        caselist=[\n            (pl.col(\"x\") &lt; 2, pl.lit(\"small\")),\n            (pl.col(\"x\") &lt; 4, pl.lit(\"medium\"))\n        ],\n        otherwise=pl.lit(\"large\"),\n    ).alias(\"size\")\n\n    # This is equivalent to writing:\n    # expr = (\n    #     pl.when(pl.col(\"x\") &lt; 2)\n    #       .then(pl.lit(\"small\"))\n    #       .when(pl.col(\"x\") &lt; 4)\n    #       .then(pl.lit(\"medium\"))\n    #       .otherwise(pl.lit(\"large\"))\n    #       .alias(\"size\")\n    # )\n\n    df.with_columns(expr)\n    ```\n    shape: (4, 2)\n    ┌─────┬────────┐\n    │ x   ┆ size   │\n    │ --- ┆ ---    │\n    │ i64 ┆ str    │\n    ├─────┼────────┤\n    │ 1   ┆ small  │\n    │ 2   ┆ medium │\n    │ 3   ┆ medium │\n    │ 4   ┆ large  │\n    └─────┴────────┘\n    \"\"\"\n    (first_when, first_then), *cases = caselist\n\n    # first\n    expr = pl.when(first_when).then(first_then)\n\n    # middles\n    for when, then in cases:\n        expr = expr.when(when).then(then)\n\n    # last\n    expr = expr.otherwise(otherwise)\n\n    return expr"
  },
  {
    "objectID": "posts/casewhen-in-polars/20250525.html#custom-expression-namespace",
    "href": "posts/casewhen-in-polars/20250525.html#custom-expression-namespace",
    "title": "case_when() in Polars",
    "section": "Custom Expression Namespace",
    "text": "Custom Expression Namespace\nWith case_when() in place, we can refactor the DiscreteSplitter expression namespace like this:\n\n@cache\ndef _mod_expr(n: int) -&gt; pl.Expr:\n    return pl.int_range(pl.len(), dtype=pl.UInt32).mod(n)\n\n\ndef _litify(lits: list[Any]) -&gt; list[pl.lit]:\n    return [pl.lit(lit) for lit in lits]\n\n\n@pl.api.register_expr_namespace(\"spt\")\nclass DiscreteSplitter:\n    def __init__(self, expr: pl.Expr) -&gt; None:\n        self._expr = expr\n\n    def _get_expr(self, lits: list[Any], name: str):\n        n = len(lits)\n        mod_expr = _mod_expr(n)\n        *litified, litified_otherwise = _litify(lits)\n        caselist = [(mod_expr.eq(i), lit) for i, lit in enumerate(litified)]\n        return case_when(caselist, litified_otherwise).alias(name)\n\n    def binarize(self, lit1: Any, lit2: Any, name: str = \"binarized\") -&gt; pl.Expr:\n        return self.bucketize([lit1, lit2], name)\n\n    def trinarize(\n        self, lit1: Any, lit2: Any, lit3: Any, name: str = \"trinarized\"\n    ) -&gt; pl.Expr:\n        return self.bucketize([lit1, lit2, lit3], name)\n\n    def bucketize(self, lits: list[Any], name: str = \"bucketized\") -&gt; pl.Expr:\n        return self._get_expr(lits, name)\n\nNow, bucketize() is the primary method that encapsulates the core logic for categorical mapping. binarize() and trinarize() are just convenient wrappers for common cases.\nHere’s a simple example of using the custom expression namespace:\ndf = (\n    pl.DataFrame({\"n\": [100, 50, 72, 83, 97, 42, 20, 51, 77]})\n    .with_row_index(offset=1)\n    .with_columns(\n        pl.col(\"\").spt.binarize(\"lightblue\", \"papayawhip\"),\n        pl.col(\"\").spt.trinarize(\"one\", \"two\", \"three\"),\n        pl.col(\"\").spt.bucketize([1, 2, 3, 4]),\n    )\n)\nshape: (9, 5)\n┌───────┬─────┬────────────┬────────────┬────────────┐\n│ index ┆ n   ┆ binarized  ┆ trinarized ┆ bucketized │\n│ ---   ┆ --- ┆ ---        ┆ ---        ┆ ---        │\n│ u32   ┆ i64 ┆ str        ┆ str        ┆ i32        │\n╞═══════╪═════╪════════════╪════════════╪════════════╡\n│ 1     ┆ 100 ┆ lightblue  ┆ one        ┆ 1          │\n│ 2     ┆ 50  ┆ papayawhip ┆ two        ┆ 2          │\n│ 3     ┆ 72  ┆ lightblue  ┆ three      ┆ 3          │\n│ 4     ┆ 83  ┆ papayawhip ┆ one        ┆ 4          │\n│ 5     ┆ 97  ┆ lightblue  ┆ two        ┆ 1          │\n│ 6     ┆ 42  ┆ papayawhip ┆ three      ┆ 2          │\n│ 7     ┆ 20  ┆ lightblue  ┆ one        ┆ 3          │\n│ 8     ┆ 51  ┆ papayawhip ┆ two        ┆ 4          │\n│ 9     ┆ 77  ┆ lightblue  ┆ three      ┆ 1          │\n└───────┴─────┴────────────┴────────────┴────────────┘"
  },
  {
    "objectID": "posts/casewhen-in-polars/20250525.html#custom-dataframe-namespace",
    "href": "posts/casewhen-in-polars/20250525.html#custom-dataframe-namespace",
    "title": "case_when() in Polars",
    "section": "Custom DataFrame Namespace",
    "text": "Custom DataFrame Namespace\nInstead of relying on pl.DataFrame.with_row_index(), we can also use _mod_expr() directly to enable similar categorization.\nHere’s how the DiscreteSplitter can be implemented as a custom DataFrame namespace:\n\n@pl.api.register_dataframe_namespace(\"spt\")\nclass DiscreteSplitter:\n    def __init__(self, df: pl.DataFrame) -&gt; None:\n        self._df = df\n\n    def _get_expr(self, lits: list[Any], name: str):\n        n = len(lits)\n        mod_expr = _mod_expr(n)\n        *litified, litified_otherwise = _litify(lits)\n        caselist = [(mod_expr.eq(i), lit) for i, lit in enumerate(litified)]\n        return case_when(caselist, litified_otherwise).alias(name)\n\n    def _get_final_df(self, lits: list[Any], name: str) -&gt; pl.DataFrame:\n        cls = type(self)\n        expr = self._get_expr(lits, name)\n        new_spt = cls(self._df.with_columns(expr))\n        return new_spt._df\n\n    def binarize(self, lit1: Any, lit2: Any, name: str = \"binarized\") -&gt; pl.DataFrame:\n        return self.bucketize([lit1, lit2], name=name)\n\n    def trinarize(\n        self, lit1: Any, lit2: Any, lit3: Any, name: str = \"trinarized\"\n    ) -&gt; pl.DataFrame:\n        return self.bucketize([lit1, lit2, lit3], name=name)\n\n    def bucketize(self, lits: list[Any], name: str = \"bucketized\") -&gt; pl.DataFrame:\n        return self._get_final_df(lits, name)\n\nExample usage:\ndf = (\n    pl.DataFrame({\"n\": [100, 50, 72, 83, 97, 42, 20, 51, 77]})\n    .spt.binarize(\"lightblue\", \"papayawhip\")\n    .spt.trinarize(\"one\", \"two\", \"three\")\n    .spt.bucketize([1, 2, 3, 4])\n    .with_row_index(offset=1)\n)\nshape: (9, 5)\n┌───────┬─────┬────────────┬────────────┬────────────┐\n│ index ┆ n   ┆ binarized  ┆ trinarized ┆ bucketized │\n│ ---   ┆ --- ┆ ---        ┆ ---        ┆ ---        │\n│ u32   ┆ i64 ┆ str        ┆ str        ┆ i32        │\n╞═══════╪═════╪════════════╪════════════╪════════════╡\n│ 1     ┆ 100 ┆ lightblue  ┆ one        ┆ 1          │\n│ 2     ┆ 50  ┆ papayawhip ┆ two        ┆ 2          │\n│ 3     ┆ 72  ┆ lightblue  ┆ three      ┆ 3          │\n│ 4     ┆ 83  ┆ papayawhip ┆ one        ┆ 4          │\n│ 5     ┆ 97  ┆ lightblue  ┆ two        ┆ 1          │\n│ 6     ┆ 42  ┆ papayawhip ┆ three      ┆ 2          │\n│ 7     ┆ 20  ┆ lightblue  ┆ one        ┆ 3          │\n│ 8     ┆ 51  ┆ papayawhip ┆ two        ┆ 4          │\n│ 9     ┆ 77  ┆ lightblue  ┆ three      ┆ 1          │\n└───────┴─────┴────────────┴────────────┴────────────┘"
  },
  {
    "objectID": "posts/casewhen-in-polars/20250525.html#conclusion",
    "href": "posts/casewhen-in-polars/20250525.html#conclusion",
    "title": "case_when() in Polars",
    "section": "Conclusion",
    "text": "Conclusion\nExtracting the conditional logic into a standalone case_when() function turned out to be both a practical and satisfying exercise—perfect for a rainy afternoon of coding. It not only improves readability but also makes the branching logic easier to reuse and reason about.\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/style-table-body/20250124.html",
    "href": "posts/style-table-body/20250124.html",
    "title": "Three Approaches to Styling the Table Body in Great Tables",
    "section": "",
    "text": "This post demonstrates three approaches to styling the table body:\nLet’s dive in."
  },
  {
    "objectID": "posts/style-table-body/20250124.html#preparations",
    "href": "posts/style-table-body/20250124.html#preparations",
    "title": "Three Approaches to Styling the Table Body in Great Tables",
    "section": "Preparations",
    "text": "Preparations\nWe’ll use the built-in dataset gtcars to create a Polars DataFrame. First, we’ll select the columns mfr, drivetrain, year, and hp to create a small pivoted table named df_mini. Then, we’ll pass df_mini to the GT object and use GT.tab_stub(), setting drivetrain as rowname_col= and mfr as groupname_col= to create the table gt, as shown below:\n\n\nCode\nimport polars as pl\nfrom great_tables import GT, loc, style\nfrom great_tables.data import gtcars\nfrom polars import selectors as cs\n\nyear_cols = [\"2014\", \"2015\", \"2016\", \"2017\"]\ndf_mini = (\n    pl.from_pandas(gtcars)\n    .filter(pl.col(\"mfr\").is_in([\"Ferrari\", \"Lamborghini\", \"BMW\"]))\n    .sort(\"drivetrain\")\n    .pivot(on=\"year\", index=[\"mfr\", \"drivetrain\"], values=\"hp\", aggregate_function=\"mean\")\n    .select([\"mfr\", \"drivetrain\", *year_cols])\n)\n\ngt = GT(df_mini).tab_stub(rowname_col=\"drivetrain\", groupname_col=\"mfr\").opt_stylize()\ngt\n\n\n\n\n\n\n\n\n  \n  2014\n  2015\n  2016\n  2017\n\n\n\n  \n    Ferrari\n  \n  \n    awd\n    None\n    652.0\n    None\n    680.0\n  \n  \n    rwd\n    562.0\n    678.4\n    661.0\n    None\n  \n  \n    Lamborghini\n  \n  \n    awd\n    None\n    700.0\n    None\n    None\n  \n  \n    rwd\n    550.0\n    610.0\n    None\n    None\n  \n  \n    BMW\n  \n  \n    awd\n    None\n    None\n    357.0\n    None\n  \n  \n    rwd\n    None\n    None\n    465.0\n    None\n  \n\n\n\n\n\n\n        \n\n\nThe numbers in the cells represent the average horsepower for each combination of mfr and drivetrain for a specific year.\nIn the following section, we’ll demonstrate three different ways to highlight the cell text in red if the average horsepower exceeds 650."
  },
  {
    "objectID": "posts/style-table-body/20250124.html#using-a-for-loop-repeatedly-call-gt.tab_style-for-each-column",
    "href": "posts/style-table-body/20250124.html#using-a-for-loop-repeatedly-call-gt.tab_style-for-each-column",
    "title": "Three Approaches to Styling the Table Body in Great Tables",
    "section": "Using a For-Loop: Repeatedly Call GT.tab_style() for Each Column",
    "text": "Using a For-Loop: Repeatedly Call GT.tab_style() for Each Column\nThe most intuitive way is to call GT.tab_style() for each column. Here’s how:\n\n1gt1 = gt\nfor col in year_cols:\n    gt1 = gt1.tab_style(\n        style=style.text(color=\"red\"),\n        locations=loc.body(columns=col, rows=pl.col(col).gt(650))\n    )\ngt1\n\n\n1\n\nSince we want to keep gt intact for later use, we will modify gt1 in this approach instead.\n\n\n\n\n\n\n\n\n\n\n  \n  2014\n  2015\n  2016\n  2017\n\n\n\n  \n    Ferrari\n  \n  \n    awd\n    None\n    652.0\n    None\n    680.0\n  \n  \n    rwd\n    562.0\n    678.4\n    661.0\n    None\n  \n  \n    Lamborghini\n  \n  \n    awd\n    None\n    700.0\n    None\n    None\n  \n  \n    rwd\n    550.0\n    610.0\n    None\n    None\n  \n  \n    BMW\n  \n  \n    awd\n    None\n    None\n    357.0\n    None\n  \n  \n    rwd\n    None\n    None\n    465.0\n    None"
  },
  {
    "objectID": "posts/style-table-body/20250124.html#utilizing-the-locations-parameter-in-gt.tab_style-pass-a-list-of-loc.body-objects",
    "href": "posts/style-table-body/20250124.html#utilizing-the-locations-parameter-in-gt.tab_style-pass-a-list-of-loc.body-objects",
    "title": "Three Approaches to Styling the Table Body in Great Tables",
    "section": "Utilizing the locations= Parameter in GT.tab_style(): Pass a List of loc.body() Objects",
    "text": "Utilizing the locations= Parameter in GT.tab_style(): Pass a List of loc.body() Objects\nA more concise method is to pass a list of loc.body() objects to the locations= parameter in GT.tab_style(), as shown below:\n\n(\n    gt.tab_style(\n        style=style.text(color=\"red\"),\n        locations=[\n            loc.body(columns=col, rows=pl.col(col).gt(650))\n            for col in year_cols\n        ],\n    )\n)\n\n\n\n\n\n\n\n  \n  2014\n  2015\n  2016\n  2017\n\n\n\n  \n    Ferrari\n  \n  \n    awd\n    None\n    652.0\n    None\n    680.0\n  \n  \n    rwd\n    562.0\n    678.4\n    661.0\n    None\n  \n  \n    Lamborghini\n  \n  \n    awd\n    None\n    700.0\n    None\n    None\n  \n  \n    rwd\n    550.0\n    610.0\n    None\n    None\n  \n  \n    BMW\n  \n  \n    awd\n    None\n    None\n    357.0\n    None\n  \n  \n    rwd\n    None\n    None\n    465.0\n    None"
  },
  {
    "objectID": "posts/style-table-body/20250124.html#leveraging-the-mask-parameter-in-loc.body-use-polars-expressions-for-streamlined-styling",
    "href": "posts/style-table-body/20250124.html#leveraging-the-mask-parameter-in-loc.body-use-polars-expressions-for-streamlined-styling",
    "title": "Three Approaches to Styling the Table Body in Great Tables",
    "section": "Leveraging the mask= Parameter in loc.body(): Use Polars Expressions for Streamlined Styling",
    "text": "Leveraging the mask= Parameter in loc.body(): Use Polars Expressions for Streamlined Styling\nThe most modern approach (0.16.0) is to pass a Polars expression to the mask= parameter in loc.body(), as illustrated here:\n\n(\n    gt.tab_style(\n        style=style.text(color=\"red\"),\n        locations=loc.body(mask=cs.numeric().gt(650))\n    )\n)\n\n\n\n\n\n\n\n  \n  2014\n  2015\n  2016\n  2017\n\n\n\n  \n    Ferrari\n  \n  \n    awd\n    None\n    652.0\n    None\n    680.0\n  \n  \n    rwd\n    562.0\n    678.4\n    661.0\n    None\n  \n  \n    Lamborghini\n  \n  \n    awd\n    None\n    700.0\n    None\n    None\n  \n  \n    rwd\n    550.0\n    610.0\n    None\n    None\n  \n  \n    BMW\n  \n  \n    awd\n    None\n    None\n    357.0\n    None\n  \n  \n    rwd\n    None\n    None\n    465.0\n    None\n  \n\n\n\n\n\n\n        \n\n\nIn this example, loc.body() is smart enough to automatically target the rows where the cell value exceeds 650 for each numerical column. In general, you can think of mask= as a syntactic sugar that Great Tables provides to save you from having to manually loop through the columns."
  },
  {
    "objectID": "posts/style-table-body/20250124.html#final-words",
    "href": "posts/style-table-body/20250124.html#final-words",
    "title": "Three Approaches to Styling the Table Body in Great Tables",
    "section": "Final Words",
    "text": "Final Words\nThis post summarizes three approaches to styling the table body. Among them, the mask= parameter in loc.body() is definitely my favorite, inspired by #389 and implemented by me.\nSpecial thanks to @rich-iannone and @machow for their invaluable suggestions during development. Any remaining bugs are entirely on me.\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Posts",
    "section": "",
    "text": "Notes on Turtle Island\n\n\n\npython\n\npolars\n\nti\n\n\n\n\n\n\n\n\n\nJul 21, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nTurtle Island: A Utility Kit for Polars Expressions\n\n\n\npython\n\npolars\n\nti\n\n\n\n\n\n\n\n\n\nJul 6, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nCreating an Integrated marimo UI Explorer with Great Tables\n\n\n\npython\n\nmarimo\n\ngt\n\n\n\n\n\n\n\n\n\nJul 4, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nTime Machine for Great Tables in marimo\n\n\n\npython\n\nmarimo\n\ngt\n\n\n\n\n\n\n\n\n\nJun 26, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nInteractive Django Deployment Checklist with marimo\n\n\n\npython\n\nmarimo\n\ngt\n\ndjango\n\n\n\n\n\n\n\n\n\nJun 25, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nSend Email via marimo\n\n\n\npython\n\nmarimo\n\nresend\n\n\n\n\n\n\n\n\n\nJun 25, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nGreat Tables with marimo in Quarto\n\n\n\npython\n\ngt\n\nmarimo\n\n\n\n\n\n\n\n\n\nJun 12, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nmarimo in Quarto\n\n\n\npython\n\nmarimo\n\n\n\n\n\n\n\n\n\nJun 7, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nStyling tricks in Great Tables\n\n\n\npython\n\npandas\n\npolars\n\ngt\n\n\n\n\n\n\n\n\n\nMay 26, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\ncase_when() in Polars\n\n\n\npython\n\npolars\n\n\n\n\n\n\n\n\n\nMay 25, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nCustom Row Selector in Great Tables\n\n\n\npython\n\npandas\n\npolars\n\ngt\n\n\n\n\n\n\n\n\n\nMay 11, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nPolars Custom Expression Namespace\n\n\n\npython\n\npolars\n\n\n\n\n\n\n\n\n\nApr 17, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nClone the Reciprocal Tariffs Table Using Plotnine\n\n\n\npython\n\npolars\n\nplotnine\n\n\n\n\n\n\n\n\n\nApr 16, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nWeekend Challenge – Recreating a Data Visualization with Polars and Plotnine\n\n\n\npython\n\npolars\n\nmatplotlib\n\nplotnine\n\n\n\n\n\n\n\n\n\nApr 12, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nHow to Access the Axes in Plotnine\n\n\n\npython\n\nmatplotlib\n\nplotnine\n\n\n\n\n\n\n\n\n\nApr 11, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nClone the Reciprocal Tariffs Table Using Great Tables\n\n\n\npython\n\npolars\n\ngt\n\n\n\n\n\n\n\n\n\nApr 3, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nApplying Custom Color Palettes to the Table Body in Great Tables\n\n\n\npython\n\npandas\n\npolars\n\ngt\n\n\n\n\n\n\n\n\n\nFeb 25, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nWeekend Challenge - Effective Data Visualization with Polars and Matplotlib\n\n\n\npython\n\npandas\n\npolars\n\nmatplotlib\n\n\n\n\n\n\n\n\n\nFeb 10, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nThree Approaches to Styling the Table Body in Great Tables\n\n\n\npython\n\npolars\n\ngt\n\n\n\n\n\n\n\n\n\nJan 24, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nExploring Resend SMTP Service with Django\n\n\n\npython\n\ndjango\n\nresend\n\n\n\n\n\n\n\n\n\nDec 23, 2024\n\n\nJerry Wu\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/marimo-django-deployment-checklist/20250625.html",
    "href": "posts/marimo-django-deployment-checklist/20250625.html",
    "title": "Interactive Django Deployment Checklist with marimo",
    "section": "",
    "text": "I love Django—it covers pretty much everything I need in a web environment. However, when it comes time to deploy a project to production, there are always a bunch of pre-deployment checks, and I can never seem to remember them all. I find myself constantly revisiting the official Django deployment checklist page.\nToday I realized I don’t need all the detailed information every time—just a simple reminder list is enough. So, I built an interactive Django deployment checklist using Great Tables in marimo and hosted it on marimo.app. Now I can interact with it whenever I need a quick double-check.\n\n\n\n\n\n\nmarimo\n\n\n\n\n\n\nGive It a Sec – WASM Magic Happening\n\n\n\nThe widgets may take a few moments to load, as they rely on WebAssembly under the hood.\n\n\n\nI asked AI to generate a checklist and wrapped it in a Polars DataFrame called df.\nI created 10 switch widgets and stacked them into an array widget named status_widgets to represent the status of each checklist item.\nI extracted the HTML representation of each widget via its _repr_html_() method and inserted it as a new \"Status\" column in df, which I then wrapped in a Great Tables GT object.\nI added two source notes using GT.tab_source_note()—one to display progress, and another for a visual progress bar.\nFinally, I gave the table a nice header with GT.tab_header() and applied some styling using GT.opt_stylize().\n\n\n    \n    \n    \n    import%20marimo%20as%20mo%0Aimport%20polars%20as%20pl%0Afrom%20great_tables%20import%20GT%2C%20html%2C%20md\n\n\n    \n    \n    \n    tasks%20%3D%20%5B%0A%20%20%20%20%22Set%20DEBUG%20%3D%20False%22%2C%0A%20%20%20%20%22Configure%20ALLOWED_HOSTS%22%2C%0A%20%20%20%20%22Set%20up%20a%20secret%20key%22%2C%0A%20%20%20%20%22Collect%20static%20files%22%2C%0A%20%20%20%20%22Apply%20database%20migrations%22%2C%0A%20%20%20%20%22Set%20up%20gunicorn%20or%20uWSGI%22%2C%0A%20%20%20%20%22Configure%20reverse%20proxy%20(e.g.%2C%20Nginx)%22%2C%0A%20%20%20%20%22Secure%20the%20database%22%2C%0A%20%20%20%20%22Set%20up%20HTTPS%20(SSL)%22%2C%0A%20%20%20%20%22Configure%20logging%20%26%20monitoring%22%2C%0A%5D%0A%0Anotes%20%3D%20%5B%0A%20%20%20%20%22Never%20deploy%20with%20DEBUG%20%3D%20True%20%E2%9A%A0%EF%B8%8F%22%2C%0A%20%20%20%20%22Include%20your%20domain(s)%20or%20IP%20address%20%F0%9F%8C%90%22%2C%0A%20%20%20%20%22Use%20a%20strong%2C%20secure%20key%20from%20an%20environment%20variable%20%F0%9F%94%90%22%2C%0A%20%20%20%20%22Run%20%60python%20manage.py%20collectstatic%60%20%F0%9F%93%A6%22%2C%0A%20%20%20%20%22Run%20%60python%20manage.py%20migrate%60%20%F0%9F%97%83%EF%B8%8F%22%2C%0A%20%20%20%20%22Use%20as%20a%20WSGI%20server%20in%20production%20%F0%9F%94%84%22%2C%0A%20%20%20%20%22Serve%20static%2Fmedia%20files%20and%20forward%20to%20WSGI%20server%20%F0%9F%A7%AD%22%2C%0A%20%20%20%20%22Use%20strong%20credentials%2C%20disable%20remote%20root%20login%20%F0%9F%9B%A1%EF%B8%8F%22%2C%0A%20%20%20%20%22Use%20Let's%20Encrypt%20or%20your%20own%20certificate%20%F0%9F%94%92%22%2C%0A%20%20%20%20%22Track%20errors%20and%20app%20performance%20%F0%9F%93%8A%22%2C%0A%5D%0A%0An_row%20%3D%20len(tasks)%0Astatus%20%3D%20%5B%22%E2%98%90%22%5D%20*%20n_row%0Adata%20%3D%20%7B%22Status%22%3A%20status%2C%20%22Task%22%3A%20tasks%2C%20%22Notes%22%3A%20notes%7D%0A%0Adf%20%3D%20pl.DataFrame(data)\n\n\n    \n    \n    \n    status_widget%20%3D%20mo.ui.switch()%0Astatus_widgets%20%3D%20mo.ui.array(%5Bstatus_widget%5D%20*%20n_row)\n\n\n    \n    \n    \n    def%20create_bar(%0A%20%20%20%20x%3A%20float%2C%0A%20%20%20%20max_width%3A%20int%2C%0A%20%20%20%20height%3A%20int%2C%0A%20%20%20%20background_color1%3A%20str%2C%0A%20%20%20%20background_color2%3A%20str%2C%0A)%20-%3E%20str%3A%0A%20%20%20%20width%20%3D%20round(max_width%20*%20x%2C%202)%0A%20%20%20%20px_width%20%3D%20f%22%7Bwidth%7Dpx%22%0A%20%20%20%20return%20f%22%22%22%5C%0A%20%20%20%20%3Cdiv%20style%3D%22width%3A%20%7Bmax_width%7Dpx%3B%20background-color%3A%20%7Bbackground_color1%7D%3B%22%3E%5C%0A%20%20%20%20%20%20%20%20%3Cdiv%20style%3D%22height%3A%7Bheight%7Dpx%3Bwidth%3A%7Bpx_width%7D%3Bbackground-color%3A%7Bbackground_color2%7D%3B%22%3E%3C%2Fdiv%3E%5C%0A%20%20%20%20%3C%2Fdiv%3E%5C%0A%20%20%20%20%22%22%22\n\n\n    \n    \n    \n    done_count%20%3D%20sum(s.value%20for%20s%20in%20status_widgets)%0A%0Agt%20%3D%20(%0A%20%20%20%20GT(%0A%20%20%20%20%20%20%20%20df.with_columns(%0A%20%20%20%20%20%20%20%20%20%20%20%20pl.Series(%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Bstatus._repr_html_()%20for%20status%20in%20status_widgets%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20).alias(%22Status%22)%0A%20%20%20%20%20%20%20%20)%0A%20%20%20%20)%0A%20%20%20%20.tab_source_note(f%22%7Bdone_count%7D%20%2F%20%7Bn_row%7D%22)%0A%20%20%20%20.tab_source_note(%0A%20%20%20%20%20%20%20%20html(%0A%20%20%20%20%20%20%20%20%20%20%20%20create_bar(%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20done_count%20%2F%20n_row%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20max_width%3D750%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20height%3D20%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20background_color1%3D%22lightgray%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20background_color2%3D%22%2366CDAA%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20)%0A%20%20%20%20%20%20%20%20)%0A%20%20%20%20)%0A%20%20%20%20.tab_header(%22%E2%9C%85%20Django%20Deployment%20Checklist%22)%0A%20%20%20%20.opt_stylize(color%3D%22cyan%22%2C%20style%3D4)%0A)%0Agt\n\nCheck out the full marimo code below or view it on molab.\n\n\nShow full code\nimport marimo\n\n__generated_with = \"0.14.7\"\napp = marimo.App(width=\"medium\")\n\n\n@app.cell\ndef _():\n    import marimo as mo\n\n    return (mo,)\n\n\n@app.cell\ndef _():\n    import polars as pl\n    from great_tables import GT, html, md\n\n    return GT, html, pl\n\n\n@app.cell\ndef _(pl):\n    tasks = [\n        \"Set DEBUG = False\",\n        \"Configure ALLOWED_HOSTS\",\n        \"Set up a secret key\",\n        \"Collect static files\",\n        \"Apply database migrations\",\n        \"Set up gunicorn or uWSGI\",\n        \"Configure reverse proxy (e.g., Nginx)\",\n        \"Secure the database\",\n        \"Set up HTTPS (SSL)\",\n        \"Configure logging & monitoring\",\n    ]\n\n    notes = [\n        \"Never deploy with DEBUG = True ⚠️\",\n        \"Include your domain(s) or IP address 🌐\",\n        \"Use a strong, secure key from an environment variable 🔐\",\n        \"Run `python manage.py collectstatic` 📦\",\n        \"Run `python manage.py migrate` 🗃️\",\n        \"Use as a WSGI server in production 🔄\",\n        \"Serve static/media files and forward to WSGI server 🧭\",\n        \"Use strong credentials, disable remote root login 🛡️\",\n        \"Use Let's Encrypt or your own certificate 🔒\",\n        \"Track errors and app performance 📊\",\n    ]\n\n    n_row = len(tasks)\n    status = [\"☐\"] * n_row\n    data = {\"Status\": status, \"Task\": tasks, \"Notes\": notes}\n\n    df = pl.DataFrame(data)\n    return df, n_row\n\n\n@app.cell\ndef _(mo, n_row):\n    status_widget = mo.ui.switch()\n    status_widgets = mo.ui.array([status_widget] * n_row)\n    return (status_widgets,)\n\n\n@app.function\ndef create_bar(\n    x: float,\n    max_width: int,\n    height: int,\n    background_color1: str,\n    background_color2: str,\n) -&gt; str:\n    width = round(max_width * x, 2)\n    px_width = f\"{width}px\"\n    return f\"\"\"\\\n    &lt;div style=\"width: {max_width}px; background-color: {background_color1};\"&gt;\\\n        &lt;div style=\"height:{height}px;width:{px_width};background-color:{background_color2};\"&gt;&lt;/div&gt;\\\n    &lt;/div&gt;\\\n    \"\"\"\n\n\n@app.cell\ndef _(GT, df, html, n_row, pl, status_widgets):\n    done_count = sum(s.value for s in status_widgets)\n\n    gt = (\n        GT(\n            df.with_columns(\n                pl.Series(\n                    [status._repr_html_() for status in status_widgets]\n                ).alias(\"Status\")\n            )\n        )\n        .tab_source_note(f\"{done_count} / {n_row}\")\n        .tab_source_note(\n            html(\n                create_bar(\n                    done_count / n_row,\n                    max_width=750,\n                    height=20,\n                    background_color1=\"lightgray\",\n                    background_color2=\"#66CDAA\",\n                )\n            )\n        )\n        .tab_header(\"✅ Django Deployment Checklist\")\n        .opt_stylize(color=\"cyan\", style=4)\n    )\n    gt\n    return\n\n\nif __name__ == \"__main__\":\n    app.run()\n\n\n\n\n\n\n\n\nDisclaimer\n\n\n\n\nThis table is for demonstration purposes only. You should customize it based on your own needs.\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/resend-via-marimo/20250625.html",
    "href": "posts/resend-via-marimo/20250625.html",
    "title": "Send Email via marimo",
    "section": "",
    "text": "This post demonstrates how to send emails using Resend from within a marimo app.\n\n\n\n\n\nIt seems the app runs fine locally but doesn’t work in a WASM environment. It’ll be interesting to explore where the boundaries of WASM lie.\nCheck out the full marimo code below or view it on molab.\n\n\nShow full code\nimport marimo\n\n__generated_with = \"0.14.7\"\napp = marimo.App(width=\"medium\")\n\n\n@app.cell\ndef _():\n    import marimo as mo\n    import os\n    from html import escape\n    import polars as pl\n    import resend\n\n    return escape, mo, resend\n\n\n@app.cell\ndef _(escape, resend):\n    def send_email(d: dict[str, str]) -&gt; None:\n        \"\"\"\n        https://resend.com/docs/send-with-python\n        \"\"\"\n        resend.api_key = d[\"RESEND_API_KEY\"]\n        from_ = d[\"from_\"]\n        to = [mail.strip() for mail in d[\"to\"].split(\",\")]\n        subject = d[\"subject\"]\n        html_ = escape(d[\"content\"]).replace(\"\\n\", \"&lt;br&gt;\")\n\n        params: resend.Emails.SendParams = {\n            \"from\": from_,\n            \"to\": to,\n            \"subject\": subject,\n            \"html\": html_,\n        }\n\n        email = resend.Emails.send(params)\n\n    return (send_email,)\n\n\n@app.cell\ndef _(mo, send_email):\n    # Create a form with multiple eleme\n    form = (\n        mo.md(\n            \"\"\"\n        **marimo mail**\n        {RESEND_API_KEY}\n\n        {from_}\n\n        {to}\n\n        {subject}\n\n        {content}\n    \"\"\"\n        )\n        .batch(\n            RESEND_API_KEY=mo.ui.text(\n                label=\"RESEND_API_KEY\", kind=\"password\", full_width=True\n            ),\n            from_=mo.ui.text(label=\"From\", kind=\"email\", full_width=True),\n            to=mo.ui.text(label=\"To\", kind=\"email\", full_width=True),\n            subject=mo.ui.text(label=\"Subject\", full_width=True),\n            content=mo.ui.text_area(full_width=True),\n        )\n        .form(show_clear_button=True, on_change=send_email)\n    )\n    form\n    return\n\n\nif __name__ == \"__main__\":\n    app.run()\n\n\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/marimo-in-quarto/20250607.html",
    "href": "posts/marimo-in-quarto/20250607.html",
    "title": "marimo in Quarto",
    "section": "",
    "text": "This post demonstrates that Polars, Great Tables, and marimo can successfully run within a Quarto environment (as shown in this post). The example uses a table styler selector from Great Tables—and I’m honestly surprised it works!"
  },
  {
    "objectID": "posts/marimo-in-quarto/20250607.html#marimo",
    "href": "posts/marimo-in-quarto/20250607.html#marimo",
    "title": "marimo in Quarto",
    "section": "marimo",
    "text": "marimo\n\n\n\n\n\n\nGive It a Sec – WASM Magic Happening\n\n\n\nThe widgets may take a few moments to load, as they rely on WebAssembly under the hood.\n\n\n\n    \n    \n    \n    import%20marimo%20as%20mo%0Aimport%20polars%20as%20pl%0Afrom%20great_tables%20import%20GT%2C%20loc%2C%20style\n\n\n    \n    \n    \n    data%20%3D%20%7B%0A%20%20%20%20%22col1%22%3A%20%5B2%2C%205%2C%207%2C%2010%2C%2015%5D%2C%0A%20%20%20%20%22col2%22%3A%20%5B%22x%22%2C%20%22y%22%2C%20%22y%22%2C%20%22z%22%2C%20%22z%22%5D%2C%0A%20%20%20%20%22color%22%3A%20%5B%22lightgrey%22%2C%20%22lightblue%22%2C%20%22lightblue%22%2C%20%22papayawhip%22%2C%20%22papayawhip%22%5D%2C%0A%7D%0Adf%20%3D%20pl.DataFrame(data)%0Aprint(df)\n\n\n    \n    \n    \n    style_widget%20%3D%20mo.ui.slider(1%2C%206%2C%20label%3D%22Select%20Style%20Number%22)%0Amo.output.append(style_widget)%0A%0A_colors%20%3D%20%5B%22blue%22%2C%20%22cyan%22%2C%20%22pink%22%2C%20%22green%22%2C%20%22red%22%2C%20%22gray%22%5D%0Acolor_widget%20%3D%20mo.ui.radio(%0A%20%20%20%20options%3D_colors%2C%20value%3D_colors%5B0%5D%2C%20label%3D%22Select%20Style%20Color%22%0A)%0Amo.output.append(color_widget)%0A%0Arow_striping_widget%20%3D%20mo.ui.switch(value%3DTrue%2C%20label%3D%22Add%20Row%20Striping%3F%22)%0Amo.output.append(row_striping_widget)\n\n\n    \n    \n    \n    GT(df).opt_stylize(%0A%20%20%20%20style%3Dstyle_widget.value%2C%0A%20%20%20%20color%3Dcolor_widget.value%2C%0A%20%20%20%20add_row_striping%3Drow_striping_widget.value%2C%0A)\n\nCheck out the full marimo code below or view it on molab.\n\n\nShow full code\nimport marimo\n\n__generated_with = \"0.13.15\"\napp = marimo.App(width=\"medium\")\n\n\n@app.cell\ndef _():\n    import marimo as mo\n    import polars as pl\n    from great_tables import GT, loc, style\n\n    return GT, mo, pl\n\n\n@app.cell\ndef _(pl):\n    data = {\n        \"col1\": [2, 5, 7, 10, 15],\n        \"col2\": [\"x\", \"y\", \"y\", \"z\", \"z\"],\n        \"color\": [\"lightgrey\", \"lightblue\", \"lightblue\", \"papayawhip\", \"papayawhip\"],\n    }\n    df = pl.DataFrame(data)\n    return (df,)\n\n\n@app.cell\ndef _(mo):\n    style_widget = mo.ui.slider(1, 6, label=\"Select Style Number\")\n    mo.output.append(style_widget)\n\n    _colors = [\"blue\", \"cyan\", \"pink\", \"green\", \"red\", \"gray\"]\n    color_widget = mo.ui.radio(\n        options=_colors, value=_colors[0], label=\"Select Style Color\"\n    )\n    mo.output.append(color_widget)\n\n    row_striping_widget = mo.ui.switch(value=True, label=\"Add Row Striping?\")\n    mo.output.append(row_striping_widget)\n    return color_widget, row_striping_widget, style_widget\n\n\n@app.cell\ndef _(GT, color_widget, df, row_striping_widget, style_widget):\n    GT(df).opt_stylize(\n        style=style_widget.value,\n        color=color_widget.value,\n        add_row_striping=row_striping_widget.value,\n    )\n    return\n\n\nif __name__ == \"__main__\":\n    app.run()\n\n\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/marimo-gt-ui-reference/20250704.html",
    "href": "posts/marimo-gt-ui-reference/20250704.html",
    "title": "Creating an Integrated marimo UI Explorer with Great Tables",
    "section": "",
    "text": "While working with marimo widgets, I often find myself wanting a quick glance at what each widget looks like or which parameters it accepts. That’s when I realized—this was a perfect opportunity to build an interactive UI cheatsheet using Great Tables inside a marimo notebook.\n\n\n\n\n\n\n\n\n\n\n\nGive It a Sec – WASM Magic Happening\n\n\n\nThe widgets may take a few moments to load, as they rely on WebAssembly under the hood.\n\n\nThis interactive table includes four columns:\n\nA link to the documentation.\nA live widget preview.\nIts current reactive value.\nA code snippet with an accordion that reveals the widget’s signature.\n\nTo keep things playful, I added a touch of randomness—so the table appears slightly different each time it loads.\n\n    \n    \n    \n    import%20marimo%20as%20mo%0A%0Aimport%20random%0Afrom%20collections.abc%20import%20Iterable%0A%0Aimport%20pandas%20as%20pd%0Afrom%20great_tables%20import%20GT%2C%20html\n\n\n    \n    \n    \n    def%20render_widget(widget)%3A%0A%20%20%20%20if%20hasattr(widget%2C%20%22_display_%22)%3A%0A%20%20%20%20%20%20%20%20render_method%20%3D%20%22_display_%22%0A%20%20%20%20elif%20hasattr(widget%2C%20%22_repr_html_%22)%3A%0A%20%20%20%20%20%20%20%20render_method%20%3D%20%22_repr_html_%22%0A%20%20%20%20elif%20hasattr(widget%2C%20%22_mime_%22)%3A%0A%20%20%20%20%20%20%20%20render_method%20%3D%20%22_mime_%22%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20raise%20ValueError(%22The%20object%20does%20not%20have%20a%20valid%20render%20method.%22)%0A%20%20%20%20return%20getattr(widget%2C%20render_method)()%0A%0Adef%20render_widgets(widgets)%3A%0A%20%20%20%20if%20not%20isinstance(widgets%2C%20Iterable)%3A%0A%20%20%20%20%20%20%20%20widgets%20%3D%20%5Bwidgets%5D%0A%20%20%20%20return%20%5Brender_widget(widget)%20for%20widget%20in%20widgets%5D%0A%0Adef%20strify_widget_value(widget)%3A%0A%20%20%20%20return%20str(widget.value)%0A%0Adef%20strify_widget_values(widgets)%3A%0A%20%20%20%20if%20not%20isinstance(widgets%2C%20Iterable)%3A%0A%20%20%20%20%20%20%20%20widgets%20%3D%20%5Bwidgets%5D%0A%20%20%20%20return%20%5Bstrify_widget_value(w)%20for%20w%20in%20widgets%5D\n\n\n    \n    \n    \n    switch%20%3D%20mo.ui.switch()%0Acheckbox%20%3D%20mo.ui.checkbox(label%3D%22check%20me%22)%0Adate%20%3D%20mo.ui.date()%0Arun_botton%20%3D%20mo.ui.run_button(label%3D%22Run%22)%0Abutton%20%3D%20mo.ui.button(%0A%20%20%20%20value%3D0%2C%20on_click%3Dlambda%20value%3A%20value%20%2B%201%2C%20label%3D%22increment%22%0A)%0Anumber%20%3D%20mo.ui.number(1%2C%2010)%0Aslider%20%3D%20mo.ui.slider(1%2C%2010%2C%201)%0Arange_slider%20%3D%20mo.ui.range_slider(1%2C%2010%2C%202%2C%20value%3D%5B2%2C%206%5D)%0Aradio%20%3D%20mo.ui.radio(options%3D%5B%22Apples%22%2C%20%22Oranges%22%5D%2C%20value%3D%22Apples%22)%0Adropdown%20%3D%20mo.ui.dropdown(options%3D%5B%22Apples%22%2C%20%22Oranges%22%5D%2C%20value%3D%22Apples%22)%0Amultiselect%20%3D%20mo.ui.multiselect(options%3D%5B%22Apples%22%2C%20%22Oranges%22%5D)%0Atext%20%3D%20mo.ui.text(placeholder%3D%22placeholder...%22%2C%20debounce%3DFalse)%0Atext_area%20%3D%20mo.ui.text_area(placeholder%3D%22placeholder...%22%2C%20debounce%3DFalse)%0A%0Awidgets%20%3D%20mo.ui.array(%0A%20%20%20%20%5B%0A%20%20%20%20%20%20%20%20switch%2C%0A%20%20%20%20%20%20%20%20checkbox%2C%0A%20%20%20%20%20%20%20%20date%2C%0A%20%20%20%20%20%20%20%20run_botton%2C%0A%20%20%20%20%20%20%20%20button%2C%0A%20%20%20%20%20%20%20%20number%2C%0A%20%20%20%20%20%20%20%20slider%2C%0A%20%20%20%20%20%20%20%20range_slider%2C%0A%20%20%20%20%20%20%20%20radio%2C%0A%20%20%20%20%20%20%20%20dropdown%2C%0A%20%20%20%20%20%20%20%20multiselect%2C%0A%20%20%20%20%20%20%20%20text%2C%0A%20%20%20%20%20%20%20%20text_area%2C%0A%20%20%20%20%5D%0A)%0A%0Acol_widget_link%20%3D%20%5B%0A%20%20%20%20mo.md(%22%5BSwitch%5D(https%3A%2F%2Fdocs.marimo.io%2Fapi%2Finputs%2Fswitch%2F)%22)%2C%0A%20%20%20%20mo.md(%22%5BCheckBox%5D(https%3A%2F%2Fdocs.marimo.io%2Fapi%2Finputs%2Fcheckbox%2F)%22)%2C%0A%20%20%20%20mo.md(%22%5BDate%5D(https%3A%2F%2Fdocs.marimo.io%2Fapi%2Finputs%2Fdates%2F)%22)%2C%0A%20%20%20%20mo.md(%22%5BRun%20Button%5D(https%3A%2F%2Fdocs.marimo.io%2Fapi%2Finputs%2Frun_button%2F)%22)%2C%0A%20%20%20%20mo.md(%22%5BButton%5D(https%3A%2F%2Fdocs.marimo.io%2Fapi%2Finputs%2Fbutton%2F)%22)%2C%0A%20%20%20%20mo.md(%22%5BNumber%5D(https%3A%2F%2Fdocs.marimo.io%2Fapi%2Finputs%2Fnumber%2F)%22)%2C%0A%20%20%20%20mo.md(%22%5BSlider%5D(https%3A%2F%2Fdocs.marimo.io%2Fapi%2Finputs%2Fslider%2F)%22)%2C%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20%22%5BRange%20Slider%5D(https%3A%2F%2Fdocs.marimo.io%2Fapi%2Finputs%2Frange_slider%2F)%22%0A%20%20%20%20)%2C%0A%20%20%20%20mo.md(%22%5BRadio%5D(https%3A%2F%2Fdocs.marimo.io%2Fapi%2Finputs%2Fradio%2F)%22)%2C%0A%20%20%20%20mo.md(%22%5BDropdown%5D(https%3A%2F%2Fdocs.marimo.io%2Fapi%2Finputs%2Fdropdown%2F)%22)%2C%0A%20%20%20%20mo.md(%22%5BMultiSelect%5D(https%3A%2F%2Fdocs.marimo.io%2Fapi%2Finputs%2Fmultiselect%2F)%22)%2C%0A%20%20%20%20mo.md(%22%5BText%5D(https%3A%2F%2Fdocs.marimo.io%2Fapi%2Finputs%2Ftext%2F)%22)%2C%0A%20%20%20%20mo.md(%22%5BText%20Area%5D(https%3A%2F%2Fdocs.marimo.io%2Fapi%2Finputs%2Ftext_area%2F)%22)%2C%0A%5D%0A%0Acol_code%20%3D%20%5B%0A%20%20%20%20mo.accordion(%0A%20%20%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%22switch%20%3D%20mo.ui.switch()%22%3A%20%22%60switch(value%3A%20bool%20%3D%20False%2C%20*%2C%20label%3A%20str%20%3D%20''%2C%20disabled%3A%20bool%20%3D%20False%2C%20on_change%3A%20Optional%5BCallable%5B%5Bbool%5D%2C%20None%5D%5D%20%3D%20None)%60%22%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20)%2C%0A%20%20%20%20mo.accordion(%0A%20%20%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20'checkbox%20%3D%20mo.ui.checkbox(label%3D%22check%20me%22)'%3A%20%22%60checkbox(value%3A%20bool%20%3D%20False%2C%20*%2C%20label%3A%20str%20%3D%20''%2C%20disabled%3A%20bool%20%3D%20False%2C%20on_change%3A%20Optional%5BCallable%5B%5Bbool%5D%2C%20None%5D%5D%20%3D%20None)%60%22%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20)%2C%0A%20%20%20%20mo.accordion(%0A%20%20%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%22date%20%3D%20mo.ui.date()%22%3A%20%22%60date(start%3A%20Optional%5Bdate%20%7C%20str%5D%20%3D%20None%2C%20stop%3A%20Optional%5Bdate%20%7C%20str%5D%20%3D%20None%2C%20value%3A%20Optional%5Bdate%20%7C%20str%5D%20%3D%20None%2C%20*%2C%20label%3A%20str%20%3D%20''%2C%20on_change%3A%20Optional%5BCallable%5B%5Bdate%5D%2C%20None%5D%5D%20%3D%20None%2C%20full_width%3A%20bool%20%3D%20False%2C%20disabled%3A%20bool%20%3D%20False)%60%22%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20)%2C%0A%20%20%20%20mo.accordion(%0A%20%20%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20'run_botton%20%3D%20mo.ui.run_button(label%3D%22Run%22)'%3A%20%22%60run_button(kind%3A%20Literal%5B'neutral'%2C%20'success'%2C%20'warn'%2C%20'danger'%5D%20%3D%20'neutral'%2C%20disabled%3A%20bool%20%3D%20False%2C%20tooltip%3A%20Optional%5Bstr%5D%20%3D%20None%2C%20*%2C%20label%3A%20str%20%3D%20'click%20to%20run'%2C%20on_change%3A%20Optional%5BCallable%5B%5BAny%5D%2C%20None%5D%5D%20%3D%20None%2C%20full_width%3A%20bool%20%3D%20False%2C%20keyboard_shortcut%3A%20Optional%5Bstr%5D%20%3D%20None)%60%22%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20)%2C%0A%20%20%20%20mo.accordion(%0A%20%20%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20'button%20%3D%20mo.ui.button(value%3D0%2C%20on_click%3Dlambda%20value%3A%20value%20%2B%201%2C%20label%3D%22increment%22)'%3A%20%22%60button(on_click%3A%20Optional%5BCallable%5B%5BAny%5D%2C%20Any%5D%5D%20%3D%20None%2C%20value%3A%20Optional%5BAny%5D%20%3D%20None%2C%20kind%3A%20Literal%5B'neutral'%2C%20'success'%2C%20'warn'%2C%20'danger'%5D%20%3D%20'neutral'%2C%20disabled%3A%20bool%20%3D%20False%2C%20tooltip%3A%20Optional%5Bstr%5D%20%3D%20None%2C%20*%2C%20label%3A%20str%20%3D%20'click%20here'%2C%20on_change%3A%20Optional%5BCallable%5B%5BAny%5D%2C%20None%5D%5D%20%3D%20None%2C%20full_width%3A%20bool%20%3D%20False%2C%20keyboard_shortcut%3A%20Optional%5Bstr%5D%20%3D%20None)%60%22%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20)%2C%0A%20%20%20%20mo.accordion(%0A%20%20%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%22number%20%3D%20mo.ui.number(1%2C%2010)%22%3A%20%22%60number(start%3A%20Optional%5Bfloat%5D%20%3D%20None%2C%20stop%3A%20Optional%5Bfloat%5D%20%3D%20None%2C%20step%3A%20Optional%5Bfloat%5D%20%3D%20None%2C%20value%3A%20Optional%5Bfloat%5D%20%3D%20None%2C%20debounce%3A%20bool%20%3D%20False%2C%20*%2C%20label%3A%20str%20%3D%20''%2C%20on_change%3A%20Optional%5BCallable%5B%5BOptional%5BNumeric%5D%5D%2C%20None%5D%5D%20%3D%20None%2C%20full_width%3A%20bool%20%3D%20False%2C%20disabled%3A%20bool%20%3D%20False)%60%22%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20)%2C%0A%20%20%20%20mo.accordion(%0A%20%20%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%22slider%20%3D%20mo.ui.slider(1%2C%2010%2C%201)%22%3A%20%22%60slider(start%3A%20Optional%5BNumeric%5D%20%3D%20None%2C%20stop%3A%20Optional%5BNumeric%5D%20%3D%20None%2C%20step%3A%20Optional%5BNumeric%5D%20%3D%20None%2C%20value%3A%20Optional%5BNumeric%5D%20%3D%20None%2C%20debounce%3A%20bool%20%3D%20False%2C%20disabled%3A%20bool%20%3D%20False%2C%20orientation%3A%20Literal%5B'horizontal'%2C%20'vertical'%5D%20%3D%20'horizontal'%2C%20show_value%3A%20bool%20%3D%20False%2C%20include_input%3A%20bool%20%3D%20False%2C%20steps%3A%20Optional%5BSequence%5BNumeric%5D%5D%20%3D%20None%2C%20*%2C%20label%3A%20str%20%3D%20''%2C%20on_change%3A%20Optional%5BCallable%5B%5BOptional%5BNumeric%5D%5D%2C%20None%5D%5D%20%3D%20None%2C%20full_width%3A%20bool%20%3D%20False)%60%22%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20)%2C%0A%20%20%20%20mo.accordion(%0A%20%20%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%22range_slider%20%3D%20mo.ui.range_slider(1%2C%2010%2C%202%2C%20value%3D%5B2%2C%206%5D)%22%3A%20%22%60range_slider(start%3A%20Optional%5BNumeric%5D%20%3D%20None%2C%20stop%3A%20Optional%5BNumeric%5D%20%3D%20None%2C%20step%3A%20Optional%5BNumeric%5D%20%3D%20None%2C%20value%3A%20Optional%5BSequence%5BNumeric%5D%5D%20%3D%20None%2C%20debounce%3A%20bool%20%3D%20False%2C%20orientation%3A%20Literal%5B'horizontal'%2C%20'vertical'%5D%20%3D%20'horizontal'%2C%20show_value%3A%20bool%20%3D%20False%2C%20steps%3A%20Optional%5BSequence%5BNumeric%5D%5D%20%3D%20None%2C%20*%2C%20label%3A%20str%20%3D%20''%2C%20on_change%3A%20Optional%5BCallable%5B%5BSequence%5BNumeric%5D%5D%2C%20None%5D%5D%20%3D%20None%2C%20full_width%3A%20bool%20%3D%20False%2C%20disabled%3A%20bool%20%3D%20False)%60%22%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20)%2C%0A%20%20%20%20mo.accordion(%0A%20%20%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20'radio%20%3D%20mo.ui.radio(options%3D%5B%22Apples%22%2C%20%22Oranges%22%5D%2C%20value%3D%22Apples%22)'%3A%20%22%60radio(options%3A%20Sequence%5Bstr%5D%20%7C%20dict%5Bstr%2C%20Any%5D%2C%20value%3A%20Optional%5Bstr%5D%20%3D%20None%2C%20inline%3A%20bool%20%3D%20False%2C%20*%2C%20label%3A%20str%20%3D%20''%2C%20on_change%3A%20Optional%5BCallable%5B%5BAny%5D%2C%20None%5D%5D%20%3D%20None%2C%20disabled%3A%20bool%20%3D%20False)%60%22%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20)%2C%0A%20%20%20%20mo.accordion(%0A%20%20%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20'dropdown%20%3D%20mo.ui.dropdown(options%3D%5B%22Apples%22%2C%20%22Oranges%22%5D%2C%20value%3D%22Apples%22)'%3A%20%22%60dropdown(options%3A%20Sequence%5BAny%5D%20%7C%20dict%5Bstr%2C%20Any%5D%2C%20value%3A%20Optional%5BAny%5D%20%3D%20None%2C%20allow_select_none%3A%20Optional%5Bbool%5D%20%3D%20None%2C%20searchable%3A%20bool%20%3D%20False%2C%20*%2C%20label%3A%20str%20%3D%20''%2C%20on_change%3A%20Optional%5BCallable%5B%5BAny%5D%2C%20None%5D%5D%20%3D%20None%2C%20full_width%3A%20bool%20%3D%20False)%60%22%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20)%2C%0A%20%20%20%20mo.accordion(%0A%20%20%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20'multiselect%20%3D%20mo.ui.multiselect(options%3D%5B%22Apples%22%2C%20%22Oranges%22%5D)'%3A%20%22%60multiselect(options%3A%20Sequence%5BAny%5D%20%7C%20dict%5Bstr%2C%20Any%5D%2C%20value%3A%20Optional%5BSequence%5BAny%5D%5D%20%3D%20None%2C%20*%2C%20label%3A%20str%20%3D%20''%2C%20on_change%3A%20Optional%5BCallable%5B%5Blist%5Bobject%5D%5D%2C%20None%5D%5D%20%3D%20None%2C%20full_width%3A%20bool%20%3D%20False%2C%20max_selections%3A%20Optional%5Bint%5D%20%3D%20None)%60%22%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20)%2C%0A%20%20%20%20mo.accordion(%0A%20%20%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20'text%20%3D%20mo.ui.text(placeholder%3D%22placeholder...%22%2C%20debounce%3DFalse)'%3A%20%22%60text(value%3A%20str%20%3D%20''%2C%20placeholder%3A%20str%20%3D%20''%2C%20kind%3A%20Literal%5B'text'%2C%20'password'%2C%20'email'%2C%20'url'%5D%20%3D%20'text'%2C%20max_length%3A%20Optional%5Bint%5D%20%3D%20None%2C%20disabled%3A%20bool%20%3D%20False%2C%20debounce%3A%20bool%20%7C%20int%20%3D%20True%2C%20*%2C%20label%3A%20str%20%3D%20''%2C%20on_change%3A%20Optional%5BCallable%5B%5Bstr%5D%2C%20None%5D%5D%20%3D%20None%2C%20full_width%3A%20bool%20%3D%20False)%60%22%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20)%2C%0A%20%20%20%20mo.accordion(%0A%20%20%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20'text_area%20%3D%20mo.ui.text_area(placeholder%3D%22placeholder...%22%2C%20debounce%3DFalse)'%3A%20%22%60text_area(value%3A%20str%20%3D%20''%2C%20placeholder%3A%20str%20%3D%20''%2C%20max_length%3A%20Optional%5Bint%5D%20%3D%20None%2C%20disabled%3A%20bool%20%3D%20False%2C%20debounce%3A%20bool%20%7C%20int%20%3D%20True%2C%20rows%3A%20Optional%5Bint%5D%20%3D%20None%2C%20*%2C%20label%3A%20str%20%3D%20''%2C%20on_change%3A%20Optional%5BCallable%5B%5Bstr%5D%2C%20None%5D%5D%20%3D%20None%2C%20full_width%3A%20bool%20%3D%20False)%60%22%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20)%2C%0A%5D%0A%0A%0A%23%20table%20styling%0A_style_number_start%2C%20_style_number_end%20%3D%201%2C%206%0Astyle_widget%20%3D%20mo.ui.slider(%0A%20%20%20%20_style_number_start%2C%0A%20%20%20%20_style_number_end%2C%0A%20%20%20%20value%3Drandom.randint(_style_number_start%2C%20_style_number_end)%2C%0A%20%20%20%20label%3D%22Style%20Number%22%2C%0A)%0A%0A_colors%20%3D%20%5B%22blue%22%2C%20%22cyan%22%2C%20%22pink%22%2C%20%22green%22%2C%20%22red%22%2C%20%22gray%22%5D%0Acolor_widget%20%3D%20mo.ui.radio(%0A%20%20%20%20options%3D_colors%2C%0A%20%20%20%20value%3Drandom.choice(_colors)%2C%0A%20%20%20%20label%3D%22Style%20Color%22%2C%0A%20%20%20%20inline%3DTrue%2C%0A)\n\n\n    \n    \n    \n    col_widget%20%3D%20render_widgets(widgets)%0Acol_value%20%3D%20strify_widget_values(widgets)%0A%0Adata%20%3D%20%7B%0A%20%20%20%20%22link%22%3A%20col_widget_link%2C%0A%20%20%20%20%22widget%22%3A%20col_widget%2C%0A%20%20%20%20%22value%22%3A%20col_value%2C%0A%20%20%20%20%22code%22%3A%20col_code%2C%0A%7D%0A%0Adf%20%3D%20pd.DataFrame(data)\n\n\n    \n    \n    \n    gt%20%3D%20(%0A%20%20%20%20GT(df)%0A%20%20%20%20.cols_align(%22left%22)%0A%20%20%20%20.opt_all_caps()%0A%20%20%20%20.tab_header(html(style_widget)%2C%20html(color_widget))%0A)\n\n\n    \n    \n    \n    (%0A%20%20%20%20gt.opt_stylize(style%3Dstyle_widget.value%2C%20color%3Dcolor_widget.value)%0A%20%20%20%20.opt_align_table_header(%22left%22)%0A%20%20%20%20.cols_width(%7B%22widget%22%3A%20%2220%25%22%7D)%0A)\n\nOne interesting discovery: the new state of the mo.ui.run_button doesn’t persist as expected. This may be resolved by more effectively using marimo’s reactive state, which I plan to explore further.\nCheck out the full marimo code below or view it on molab.\n\n\nShow full code\nimport marimo\n\n__generated_with = \"0.14.10\"\napp = marimo.App(width=\"medium\")\n\n\n@app.cell\ndef _():\n    import marimo as mo\n\n    return (mo,)\n\n\n@app.cell\ndef _():\n    import random\n    from collections.abc import Iterable\n\n    import pandas as pd\n    from great_tables import GT, html\n\n    return GT, Iterable, html, pd, random\n\n\n@app.cell\ndef _(Iterable):\n    def render_widget(widget):\n        if hasattr(widget, \"_display_\"):\n            render_method = \"_display_\"\n        elif hasattr(widget, \"_repr_html_\"):\n            render_method = \"_repr_html_\"\n        elif hasattr(widget, \"_mime_\"):\n            render_method = \"_mime_\"\n        else:\n            raise ValueError(\"The object does not have a valid render method.\")\n        return getattr(widget, render_method)()\n\n    def render_widgets(widgets):\n        if not isinstance(widgets, Iterable):\n            widgets = [widgets]\n        return [render_widget(widget) for widget in widgets]\n\n    def strify_widget_value(widget):\n        return str(widget.value)\n\n    def strify_widget_values(widgets):\n        if not isinstance(widgets, Iterable):\n            widgets = [widgets]\n        return [strify_widget_value(w) for w in widgets]\n\n    return render_widgets, strify_widget_values\n\n\n@app.cell\ndef _(mo, random):\n    switch = mo.ui.switch()\n    checkbox = mo.ui.checkbox(label=\"check me\")\n    date = mo.ui.date()\n    run_botton = mo.ui.run_button(label=\"Run\")\n    button = mo.ui.button(\n        value=0, on_click=lambda value: value + 1, label=\"increment\"\n    )\n    number = mo.ui.number(1, 10)\n    slider = mo.ui.slider(1, 10, 1)\n    range_slider = mo.ui.range_slider(1, 10, 2, value=[2, 6])\n    radio = mo.ui.radio(options=[\"Apples\", \"Oranges\"], value=\"Apples\")\n    dropdown = mo.ui.dropdown(options=[\"Apples\", \"Oranges\"], value=\"Apples\")\n    multiselect = mo.ui.multiselect(options=[\"Apples\", \"Oranges\"])\n    text = mo.ui.text(placeholder=\"placeholder...\", debounce=False)\n    text_area = mo.ui.text_area(placeholder=\"placeholder...\", debounce=False)\n\n    widgets = mo.ui.array(\n        [\n            switch,\n            checkbox,\n            date,\n            run_botton,\n            button,\n            number,\n            slider,\n            range_slider,\n            radio,\n            dropdown,\n            multiselect,\n            text,\n            text_area,\n        ]\n    )\n\n    col_widget_link = [\n        mo.md(\"[Switch](https://docs.marimo.io/api/inputs/switch/)\"),\n        mo.md(\"[CheckBox](https://docs.marimo.io/api/inputs/checkbox/)\"),\n        mo.md(\"[Date](https://docs.marimo.io/api/inputs/dates/)\"),\n        mo.md(\"[Run Button](https://docs.marimo.io/api/inputs/run_button/)\"),\n        mo.md(\"[Button](https://docs.marimo.io/api/inputs/button/)\"),\n        mo.md(\"[Number](https://docs.marimo.io/api/inputs/number/)\"),\n        mo.md(\"[Slider](https://docs.marimo.io/api/inputs/slider/)\"),\n        mo.md(\n            \"[Range Slider](https://docs.marimo.io/api/inputs/range_slider/)\"\n        ),\n        mo.md(\"[Radio](https://docs.marimo.io/api/inputs/radio/)\"),\n        mo.md(\"[Dropdown](https://docs.marimo.io/api/inputs/dropdown/)\"),\n        mo.md(\"[MultiSelect](https://docs.marimo.io/api/inputs/multiselect/)\"),\n        mo.md(\"[Text](https://docs.marimo.io/api/inputs/text/)\"),\n        mo.md(\"[Text Area](https://docs.marimo.io/api/inputs/text_area/)\"),\n    ]\n\n    col_code = [\n        mo.accordion(\n            {\n                \"switch = mo.ui.switch()\": \"`switch(value: bool = False, *, label: str = '', disabled: bool = False, on_change: Optional[Callable[[bool], None]] = None)`\"\n            }\n        ),\n        mo.accordion(\n            {\n                'checkbox = mo.ui.checkbox(label=\"check me\")': \"`checkbox(value: bool = False, *, label: str = '', disabled: bool = False, on_change: Optional[Callable[[bool], None]] = None)`\"\n            }\n        ),\n        mo.accordion(\n            {\n                \"date = mo.ui.date()\": \"`date(start: Optional[date | str] = None, stop: Optional[date | str] = None, value: Optional[date | str] = None, *, label: str = '', on_change: Optional[Callable[[date], None]] = None, full_width: bool = False, disabled: bool = False)`\"\n            }\n        ),\n        mo.accordion(\n            {\n                'run_botton = mo.ui.run_button(label=\"Run\")': \"`run_button(kind: Literal['neutral', 'success', 'warn', 'danger'] = 'neutral', disabled: bool = False, tooltip: Optional[str] = None, *, label: str = 'click to run', on_change: Optional[Callable[[Any], None]] = None, full_width: bool = False, keyboard_shortcut: Optional[str] = None)`\",\n            }\n        ),\n        mo.accordion(\n            {\n                'button = mo.ui.button(value=0, on_click=lambda value: value + 1, label=\"increment\")': \"`button(on_click: Optional[Callable[[Any], Any]] = None, value: Optional[Any] = None, kind: Literal['neutral', 'success', 'warn', 'danger'] = 'neutral', disabled: bool = False, tooltip: Optional[str] = None, *, label: str = 'click here', on_change: Optional[Callable[[Any], None]] = None, full_width: bool = False, keyboard_shortcut: Optional[str] = None)`\"\n            }\n        ),\n        mo.accordion(\n            {\n                \"number = mo.ui.number(1, 10)\": \"`number(start: Optional[float] = None, stop: Optional[float] = None, step: Optional[float] = None, value: Optional[float] = None, debounce: bool = False, *, label: str = '', on_change: Optional[Callable[[Optional[Numeric]], None]] = None, full_width: bool = False, disabled: bool = False)`\"\n            }\n        ),\n        mo.accordion(\n            {\n                \"slider = mo.ui.slider(1, 10, 1)\": \"`slider(start: Optional[Numeric] = None, stop: Optional[Numeric] = None, step: Optional[Numeric] = None, value: Optional[Numeric] = None, debounce: bool = False, disabled: bool = False, orientation: Literal['horizontal', 'vertical'] = 'horizontal', show_value: bool = False, include_input: bool = False, steps: Optional[Sequence[Numeric]] = None, *, label: str = '', on_change: Optional[Callable[[Optional[Numeric]], None]] = None, full_width: bool = False)`\"\n            }\n        ),\n        mo.accordion(\n            {\n                \"range_slider = mo.ui.range_slider(1, 10, 2, value=[2, 6])\": \"`range_slider(start: Optional[Numeric] = None, stop: Optional[Numeric] = None, step: Optional[Numeric] = None, value: Optional[Sequence[Numeric]] = None, debounce: bool = False, orientation: Literal['horizontal', 'vertical'] = 'horizontal', show_value: bool = False, steps: Optional[Sequence[Numeric]] = None, *, label: str = '', on_change: Optional[Callable[[Sequence[Numeric]], None]] = None, full_width: bool = False, disabled: bool = False)`\"\n            }\n        ),\n        mo.accordion(\n            {\n                'radio = mo.ui.radio(options=[\"Apples\", \"Oranges\"], value=\"Apples\")': \"`radio(options: Sequence[str] | dict[str, Any], value: Optional[str] = None, inline: bool = False, *, label: str = '', on_change: Optional[Callable[[Any], None]] = None, disabled: bool = False)`\"\n            }\n        ),\n        mo.accordion(\n            {\n                'dropdown = mo.ui.dropdown(options=[\"Apples\", \"Oranges\"], value=\"Apples\")': \"`dropdown(options: Sequence[Any] | dict[str, Any], value: Optional[Any] = None, allow_select_none: Optional[bool] = None, searchable: bool = False, *, label: str = '', on_change: Optional[Callable[[Any], None]] = None, full_width: bool = False)`\"\n            }\n        ),\n        mo.accordion(\n            {\n                'multiselect = mo.ui.multiselect(options=[\"Apples\", \"Oranges\"])': \"`multiselect(options: Sequence[Any] | dict[str, Any], value: Optional[Sequence[Any]] = None, *, label: str = '', on_change: Optional[Callable[[list[object]], None]] = None, full_width: bool = False, max_selections: Optional[int] = None)`\"\n            }\n        ),\n        mo.accordion(\n            {\n                'text = mo.ui.text(placeholder=\"placeholder...\", debounce=False)': \"`text(value: str = '', placeholder: str = '', kind: Literal['text', 'password', 'email', 'url'] = 'text', max_length: Optional[int] = None, disabled: bool = False, debounce: bool | int = True, *, label: str = '', on_change: Optional[Callable[[str], None]] = None, full_width: bool = False)`\"\n            }\n        ),\n        mo.accordion(\n            {\n                'text_area = mo.ui.text_area(placeholder=\"placeholder...\", debounce=False)': \"`text_area(value: str = '', placeholder: str = '', max_length: Optional[int] = None, disabled: bool = False, debounce: bool | int = True, rows: Optional[int] = None, *, label: str = '', on_change: Optional[Callable[[str], None]] = None, full_width: bool = False)`\"\n            }\n        ),\n    ]\n\n    # table styling\n    _style_number_start, _style_number_end = 1, 6\n    style_widget = mo.ui.slider(\n        _style_number_start,\n        _style_number_end,\n        value=random.randint(_style_number_start, _style_number_end),\n        label=\"Style Number\",\n    )\n\n    _colors = [\"blue\", \"cyan\", \"pink\", \"green\", \"red\", \"gray\"]\n    color_widget = mo.ui.radio(\n        options=_colors,\n        value=random.choice(_colors),\n        label=\"Style Color\",\n        inline=True,\n    )\n    return col_code, col_widget_link, color_widget, style_widget, widgets\n\n\n@app.cell\ndef _(\n    col_code,\n    col_widget_link,\n    pd,\n    render_widgets,\n    strify_widget_values,\n    widgets,\n):\n    col_widget = render_widgets(widgets)\n    col_value = strify_widget_values(widgets)\n\n    data = {\n        \"link\": col_widget_link,\n        \"widget\": col_widget,\n        \"value\": col_value,\n        \"code\": col_code,\n    }\n\n    df = pd.DataFrame(data)\n    return (df,)\n\n\n@app.cell\ndef _(GT, color_widget, df, html, style_widget):\n    gt = (\n        GT(df)\n        .cols_align(\"left\")\n        .opt_all_caps()\n        .tab_header(html(style_widget), html(color_widget))\n    )\n    return (gt,)\n\n\n@app.cell\ndef _(color_widget, gt, style_widget):\n    (\n        gt.opt_stylize(style=style_widget.value, color=color_widget.value)\n        .opt_align_table_header(\"left\")\n        .cols_width({\"widget\": \"20%\"})\n    )\n    return\n\n\nif __name__ == \"__main__\":\n    app.run()\n\n\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/clone-reciprocal-tariffs-table/20250403.html",
    "href": "posts/clone-reciprocal-tariffs-table/20250403.html",
    "title": "Clone the Reciprocal Tariffs Table Using Great Tables",
    "section": "",
    "text": "This post demonstrates how to clone the Reciprocal Tariffs table that President Donald Trump announced on April 2 on Truth Social.\nSince the code is largely self-explanatory, I will highlight some tricks and caveats I encountered while building the table:\nShow full code\nimport polars as pl\nfrom great_tables import GT, google_font, html, loc, style, vals\n\n# source1: https://truthsocial.com/@realDonaldTrump/114270398531479278\n# source2:\n# \"https://upload.wikimedia.org/wikipedia/commons/\n# thumb/3/36/Seal_of_the_President_of_the_United_States.svg/\n# 800px-Seal_of_the_President_of_the_United_States.svg.png\"\nlogo = vals.fmt_image(\"logo.png\", height=150)[0]\n\ndata = {\n    \"country\": [\n        \"China\",\n        \"European Union\",\n        \"Vietnam\",\n        \"Taiwan\",\n        \"Japan\",\n        \"India\",\n        \"South Korea\",\n        \"Thailand\",\n        \"Switzerland\",\n        \"Indonesia\",\n        \"Malaysia\",\n        \"Cambodia\",\n        \"United Kingdom\",\n        \"South Africa\",\n        \"Brazil\",\n        \"Bangladesh\",\n        \"Singapore\",\n        \"Israel\",\n        \"Philippines\",\n        \"Chile\",\n        \"Australia\",\n        \"Pakistan\",\n        \"Turkey\",\n        \"Sri Lanka\",\n        \"Colombia\",\n    ],\n    \"tariffs_charged\": [\n        \"67%\",\n        \"39%\",\n        \"90%\",\n        \"64%\",\n        \"46%\",\n        \"52%\",\n        \"50%\",\n        \"72%\",\n        \"61%\",\n        \"64%\",\n        \"47%\",\n        \"97%\",\n        \"10%\",\n        \"60%\",\n        \"10%\",\n        \"74%\",\n        \"10%\",\n        \"33%\",\n        \"34%\",\n        \"10%\",\n        \"10%\",\n        \"58%\",\n        \"10%\",\n        \"88%\",\n        \"10%\",\n    ],\n    \"reciprocal_tariffs\": [\n        \"34%\",\n        \"20%\",\n        \"46%\",\n        \"32%\",\n        \"24%\",\n        \"26%\",\n        \"25%\",\n        \"36%\",\n        \"31%\",\n        \"32%\",\n        \"24%\",\n        \"49%\",\n        \"10%\",\n        \"30%\",\n        \"10%\",\n        \"37%\",\n        \"10%\",\n        \"17%\",\n        \"17%\",\n        \"10%\",\n        \"10%\",\n        \"29%\",\n        \"10%\",\n        \"44%\",\n        \"10%\",\n    ],\n}\n\ndark_navy_blue = \"#0B162A\"  # background\nlight_blue = \"#B5D3E7\"  # row\nwhite = \"#FFFFFF\"  # row\nyellow = \"#F6D588\"  # \"reciprocal_tariffs\" column\ngold = \"#FFF8DE\"  # logo\n\n\ndef change_border_radius(\n    x: str, border_radius: str, background_color1: str, background_color2: str\n) -&gt; str:\n    return f\"\"\"\\\n    &lt;div style=\"background-color: {background_color1};border: None\"&gt;\\\n        &lt;div style=\"border-radius: {border_radius};\\\n                    background-color:{background_color2};\"&gt;\\\n            &nbsp;{x}\\\n        &lt;/div&gt;\\\n    &lt;/div&gt;\\\n    \"\"\"\n\n\ndef change_border_radius_expr(\n    cols: pl.Expr,\n    return_dtype: pl.DataType,\n    border_radius: str,\n    background_color1: str,\n    background_color2: str,\n) -&gt; pl.Expr:\n    return cols.map_elements(\n        lambda x: change_border_radius(\n            x, border_radius, background_color1, background_color2\n        ),\n        return_dtype=return_dtype,\n    )\n\n\ndf = (\n    pl.DataFrame(data)\n    .with_row_index(\"mod\")\n    .with_columns(pl.col(\"mod\").mod(2), *[pl.lit(\"\").alias(str(i)) for i in range(4)])\n    .with_columns(\n        # \"country\" and \"tariffs_charged\" columns\n        pl.when(pl.col(\"mod\").eq(0))\n        .then(\n            change_border_radius_expr(\n                pl.col(\"country\", \"tariffs_charged\"),\n                pl.String,\n                \"5px\",\n                dark_navy_blue,\n                light_blue,\n            )\n        )\n        .otherwise(\n            change_border_radius_expr(\n                pl.col(\"country\", \"tariffs_charged\"),\n                pl.String,\n                \"5px\",\n                dark_navy_blue,\n                white,\n            )\n        ),\n        # \"reciprocal_tariffs\" column\n        change_border_radius_expr(\n            pl.col(\"reciprocal_tariffs\"), pl.String, \"5px\", dark_navy_blue, yellow\n        ),\n    )\n    .select([\"0\", \"country\", \"1\", \"tariffs_charged\", \"2\", \"reciprocal_tariffs\", \"3\"])\n    # add a row at the end of the table\n    .pipe(\n        lambda df_: pl.concat(\n            [df_, pl.DataFrame({col: \"\" for col in df_.columns})], how=\"vertical\"\n        )\n    )\n)\n\n# inner_ring_style, inner_ring_width, inner_ring_color = \"dashed\", \"3px\", \"orange\"\n\n(\n    GT(df)\n    .cols_align(\n        \"center\", columns=[\"tariffs_charged\", \"reciprocal_tariffs\"]\n    )\n    .cols_label(\n        {\n            \"country\": html(\n                f\"\"\"\\\n                &lt;br&gt;\\\n                &lt;div&gt;\\\n                    {logo}&nbsp;\\\n                    &lt;span style=\"color: {gold}; font-size: 40px;\"&gt;\\\n                        &nbsp&nbsp;Reciprocal Tariffs\\\n                    &lt;/span&gt;\\\n                &lt;/div&gt;\\\n                &lt;br&gt;\\\n                &lt;b&gt;Country&lt;/b&gt;\\\n                \"\"\"\n            ),\n            \"tariffs_charged\": html(\n                \"\"\"\\\n                &lt;b&gt;Tariffs Charged&lt;br&gt;to the U.S.A.&lt;/b&gt;\\\n                &lt;br&gt;\\\n                &lt;span style=\"font-size: 12px;\"&gt;\\\n                    Including&lt;br&gt;Currency Manipulation&lt;br&gt;and Trade Barriers\\\n                &lt;/span&gt;\\\n                \"\"\"\n            ),\n            \"reciprocal_tariffs\": html(\n                \"&lt;b&gt;U.S.A. Discounted&lt;br&gt;Reciprocal Tariffs&lt;/b&gt;\"\n            ),\n            \"0\": \"\",\n            \"1\": \"\",\n            \"2\": \"\",\n            \"3\": \"\",\n        }\n    )\n    .cols_width(\n        {\n            \"country\": \"50%\",\n            \"0\": \"3%\",\n            \"1\": \"7%\",\n            \"2\": \"7%\",\n            \"3\": \"3%\",\n            \"tariffs_charged\": \"18%\",\n            \"reciprocal_tariffs\": \"18%\",\n        }\n    )\n    # For labels and body:\n    # set the background color of the labels and body to `dark_navy_blue`\n    .tab_style(\n        style=style.fill(color=dark_navy_blue),\n        locations=[loc.column_labels(), loc.body()],\n    )\n    # For body:\n    # set the border color of the body to `dark_navy_blue`\n    # set the weight and size\n    .tab_style(\n        style=[\n            style.borders(sides=\"all\", color=dark_navy_blue),\n            style.text(weight=\"bold\", size=\"xx-large\"),\n        ],\n        locations=loc.body(),\n    )\n    # For labels:\n    # set the font, weight, size and color\n    # center-align the labels\n    .tab_style(\n        style=[\n            style.text(\n                font=google_font(name=\"Georgia\"),\n                weight=\"bold\",\n                size=\"large\",\n                color=white,\n            ),\n            style.css(\"text-align: center;\"),\n        ],\n        locations=loc.column_labels(),\n    )\n    # hide the bottom line of the label section\n    .tab_options(column_labels_border_bottom_style=\"hidden\")\n    # set the body background color to `dark_navy_blue` for the last row\n    .tab_style(\n        style=style.fill(color=dark_navy_blue),\n        locations=loc.body(rows=[-1]),\n    )\n    # .opt_table_outline(\n    #     style=inner_ring_style,\n    #     width=inner_ring_width,\n    #     color=inner_ring_color,\n    # )\n    # need to adjust `window_size` to obtain a higher-quality figure\n    # .save(\"reciprocal_tariffs_gt.png\", web_driver=\"firefox\", window_size=(1200, 1000))\n)"
  },
  {
    "objectID": "posts/clone-reciprocal-tariffs-table/20250403.html#remark",
    "href": "posts/clone-reciprocal-tariffs-table/20250403.html#remark",
    "title": "Clone the Reciprocal Tariffs Table Using Great Tables",
    "section": "Remark",
    "text": "Remark\nAdded on July 11, 2025\nI’ve been actively developing the Turtle Island library and found this example to be a great opportunity to test its usability.\nI was genuinely surprised by how well ti.case_when() and ti.is_every_nth_row() worked together to refactor the code into a more concise and expressive form. Since ti.is_every_nth_row() returns an expression, we aren’t actually creating a new column in the DataFrame—it’s more like adding a virtual column.\nThis experience has further strengthened my confidence in the design and practical value of Turtle Island.\n\n\nIf using Turtle Island\nimport turtle_island as ti\n\n# \"country\" and \"tariffs_charged\" columns\ncountry_tariffs_charged_expr = ti.case_when(\n    caselist=[\n        (\n            ti.is_every_nth_row(2),\n            change_border_radius_expr(\n                pl.col(\"country\", \"tariffs_charged\"),\n                pl.String,\n                \"5px\",\n                dark_navy_blue,\n                light_blue,\n            ),\n        )\n    ],\n    otherwise=change_border_radius_expr(\n        pl.col(\"country\", \"tariffs_charged\"),\n        pl.String,\n        \"5px\",\n        dark_navy_blue,\n        white,\n    ),\n)\n\n# \"reciprocal_tariffs\" column\nreciprocal_tariffs_expr = change_border_radius_expr(\n    pl.col(\"reciprocal_tariffs\"),\n    pl.String,\n    \"5px\",\n    dark_navy_blue,\n    yellow,\n)\n\ndf = (\n    pl.DataFrame(data)\n    .with_columns(\n        country_tariffs_charged_expr,\n        reciprocal_tariffs_expr,\n        *[pl.lit(\"\").alias(str(i)) for i in range(4)],\n    )\n    .select([\"0\", \"country\", \"1\", \"tariffs_charged\", \"2\", \"reciprocal_tariffs\", \"3\"])\n    # add a row at the end of the table\n    .pipe(\n        lambda df_: pl.concat(\n            [df_, pl.DataFrame({col: \"\" for col in df_.columns})], how=\"vertical\"\n        )\n    )\n)\n\n\n\n\n\n\n\n\nDisclaimer\n\n\n\n\nThis table is intended as a self-practice project, and the data in the table may not be 100% accurate. Please refer to the original source if you require verified data.\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/turtle-island-intro/20250706.html",
    "href": "posts/turtle-island-intro/20250706.html",
    "title": "Turtle Island: A Utility Kit for Polars Expressions",
    "section": "",
    "text": "This weekend, I started building a Python package called Turtle Island, which collects some of my ideas for helper functions aimed at reducing boilerplate when writing Polars expressions.\nCurrently, Turtle Island offers the following nine utilities:\n\ncase_when() – A cleaner and more readable way to construct chained conditional logic in Polars.\nmake_index() – Creates a virtual row index as a Polars expression, without materializing it as a column.\nbucketize_lit() – Assigns literal values to rows in a round-robin pattern based on their index.\nbucketize() – A more general version of bucketize_lit() that cycles through multiple Polars expressions, enabling advanced use cases with dynamic column values.\nis_every_nth_row() – Identifies every n-th row using a modulo operation on the row index.\nmove_cols_to_start() – Reorders selected columns to appear at the beginning of the DataFrame.\nmove_cols_to_end() – Reorders selected columns to appear at the end of the DataFrame.\nmake_hyperlink() – Generates HTML anchor (&lt;a&gt;) tags from text and url columns for rendering clickable links.\nmake_tooltip() – Creates HTML tooltips from label and tooltip columns for hoverable text display.\n\nHere’s a quick example that uses ti.is_every_nth_row() to build a Polars expression suitable for styling tables interactively with Great Tables:\n\nimport polars as pl\nfrom great_tables import GT, loc, style\nfrom great_tables.data import countrypops\n\nimport turtle_island as ti\n\ndf_pd = countrypops.sample(10).loc[:, [\"country_name\", \"year\", \"population\"]]\ndf_pl = pl.from_pandas(df_pd)\nrow_expr = ti.is_every_nth_row(3)\n\n(\n    GT(df_pl)\n    .tab_style(style=style.fill(\"lightblue\"), locations=loc.body(rows=row_expr))\n    .tab_style(style=style.fill(\"papayawhip\"), locations=loc.body(rows=~row_expr))\n    .opt_stylize(style=3, color=\"pink\")\n)\n\n\n\n\n\n\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/polars-custom-expr-namespace/20250417.html",
    "href": "posts/polars-custom-expr-namespace/20250417.html",
    "title": "Polars Custom Expression Namespace",
    "section": "",
    "text": "Today I explored how to register a custom expression namespace in Polars. This feature turned out to be super helpful for solving a common problem I run into when building tables or plots—colorizing rows based on their row index.\nHere is the code snippet:\nShow full code\nfrom typing import Any\n\nimport polars as pl\nfrom great_tables import GT, loc, style\n\n\n@pl.api.register_expr_namespace(\"spt\")\nclass DiscreteSplitter:\n    def __init__(self, expr: pl.Expr) -&gt; None:\n        self._expr = expr\n\n    def _mod_expr(self, n: int) -&gt; pl.Expr:\n        return pl.int_range(pl.len(), dtype=pl.UInt32).mod(n)\n\n    def binarize(\n        self, lit1: str, lit2: str, name: str = \"binarized\"\n    ) -&gt; pl.Expr:\n        mod_expr = self._mod_expr(2)\n        return (\n            pl.when(mod_expr.eq(0))\n            .then(pl.lit(lit1))\n            .otherwise(pl.lit(lit2))\n            .alias(name)\n        )\n\n    def trinarize(\n        self, lit1: str, lit2: str, lit3: str, name: str = \"trinarized\"\n    ) -&gt; pl.Expr:\n        mod_expr = self._mod_expr(3)\n        return (\n            pl.when(mod_expr.eq(0))\n            .then(pl.lit(lit1))\n            .when(mod_expr.eq(1))\n            .then(pl.lit(lit2))\n            .otherwise(pl.lit(lit3))\n            .alias(name)\n        )\n\n    def bucketize(\n        self, lits: list[Any], name: str = \"bucketized\"\n    ) -&gt; pl.Expr:\n        mod_expr = self._mod_expr(len(lits))\n\n        # first\n        expr = pl.when(mod_expr.eq(0)).then(pl.lit(lits[0]))\n\n        # middles\n        for i, one_lit in enumerate(lits[1:-1], start=1):\n            expr = expr.when(mod_expr.eq(i)).then(pl.lit(one_lit))\n\n        # last\n        expr = expr.otherwise(pl.lit(lits[-1]))\n        return expr.alias(name)\n\n\ndf = (\n    pl.DataFrame({\"n\": [100, 50, 72, 83, 97, 42, 20, 51, 77]})\n    .with_row_index(offset=1)\n    .with_columns(\n        pl.col(\"\").spt.binarize(\"lightblue\", \"papayawhip\"),\n        pl.col(\"\").spt.trinarize(\"one\", \"two\", \"three\"),\n        pl.col(\"\").spt.bucketize([1, 2, 3, 4]),\n    )\n)\n\n(\n    GT(df)\n    .tab_style(style=style.fill(pl.col(\"binarized\")), locations=loc.body())\n    .opt_stylize(style=6)\n)"
  },
  {
    "objectID": "posts/polars-custom-expr-namespace/20250417.html#step-by-step-breakdown",
    "href": "posts/polars-custom-expr-namespace/20250417.html#step-by-step-breakdown",
    "title": "Polars Custom Expression Namespace",
    "section": "Step-by-Step Breakdown",
    "text": "Step-by-Step Breakdown\n\nRegistering the Namespace\nWe use pl.api.register_expr_namespace() to attach our class to the spt namespace. Once registered, we can call our methods like this: pl.col(\"any\").spt.binarize(...).\n@pl.api.register_expr_namespace(\"spt\")\nclass DiscreteSplitter:\n    def __init__(self, expr: pl.Expr) -&gt; None:\n        self._expr = expr\n\n\nHelper: Row-Index Based Modulo Expression\nTo assign values based on row position, we need a way to refer to the row index inside an expression. Polars provides a trick using pl.int_range(pl.len()), as shown in pl.DataFrame.with_row_index().\n@pl.api.register_expr_namespace(\"spt\")\nclass DiscreteSplitter:\n    def _mod_expr(self, n: int) -&gt; pl.Expr:\n        return pl.int_range(pl.len(), dtype=pl.UInt32).mod(n)\n\n\nbinarize: Two Groups\nThis method maps alternating rows into two categories using pl.when().then().otherwise().\n@pl.api.register_expr_namespace(\"spt\")\nclass DiscreteSplitter:\n    def binarize(\n        self, lit1: str, lit2: str, name: str = \"binarized\"\n    ) -&gt; pl.Expr:\n        mod_expr = self._mod_expr(2)\n        return (\n            pl.when(mod_expr.eq(0))\n            .then(pl.lit(lit1))\n            .otherwise(pl.lit(lit2))\n            .alias(name)\n        )\n\n\ntrinarize: Three Groups\nSimilar to binarize, but splits the rows into three groups using two when().then() branches before the final otherwise().\n@pl.api.register_expr_namespace(\"spt\")\nclass DiscreteSplitter:\n    def trinarize(\n        self, lit1: str, lit2: str, lit3: str, name: str = \"trinarized\"\n    ) -&gt; pl.Expr:\n        mod_expr = self._mod_expr(3)\n        return (\n            pl.when(mod_expr.eq(0))\n            .then(pl.lit(lit1))\n            .when(mod_expr.eq(1))\n            .then(pl.lit(lit2))\n            .otherwise(pl.lit(lit3))\n            .alias(name)\n        )\n\n\nbucketize: N Groups\nA generalized version of the above, which dynamically assigns values from a list across n groups:\n@pl.api.register_expr_namespace(\"spt\")\nclass DiscreteSplitter:\n    def bucketize(\n        self, lits: list[Any], name: str = \"bucketized\"\n    ) -&gt; pl.Expr:\n        mod_expr = self._mod_expr(len(lits))\n\n        # first\n        expr = pl.when(mod_expr.eq(0)).then(pl.lit(lits[0]))\n\n        # middles\n        for i, one_lit in enumerate(lits[1:-1], start=1):\n            expr = expr.when(mod_expr.eq(i)).then(pl.lit(one_lit))\n\n        # last\n        expr = expr.otherwise(pl.lit(lits[-1]))\n        return expr.alias(name)\n\n\nExample Usage\nHere’s a simple example that demonstrates how the custom namespace works in practice:\ndf = (\n    pl.DataFrame({\"n\": [100, 50, 72, 83, 97, 42, 20, 51, 77]})\n    .with_row_index(offset=1)\n    .with_columns(\n        pl.col(\"\").spt.binarize(\"lightblue\", \"papayawhip\"),\n        pl.col(\"\").spt.trinarize(\"one\", \"two\", \"three\"),\n        pl.col(\"\").spt.bucketize([1, 2, 3, 4]),\n    )\n)\nThis produces the following DataFrame:\nshape: (9, 5)\n┌───────┬─────┬────────────┬────────────┬────────────┐\n│ index ┆ n   ┆ binarized  ┆ trinarized ┆ bucketized │\n│ ---   ┆ --- ┆ ---        ┆ ---        ┆ ---        │\n│ u32   ┆ i64 ┆ str        ┆ str        ┆ i32        │\n╞═══════╪═════╪════════════╪════════════╪════════════╡\n│ 1     ┆ 100 ┆ lightblue  ┆ one        ┆ 1          │\n│ 2     ┆ 50  ┆ papayawhip ┆ two        ┆ 2          │\n│ 3     ┆ 72  ┆ lightblue  ┆ three      ┆ 3          │\n│ 4     ┆ 83  ┆ papayawhip ┆ one        ┆ 4          │\n│ 5     ┆ 97  ┆ lightblue  ┆ two        ┆ 1          │\n│ 6     ┆ 42  ┆ papayawhip ┆ three      ┆ 2          │\n│ 7     ┆ 20  ┆ lightblue  ┆ one        ┆ 3          │\n│ 8     ┆ 51  ┆ papayawhip ┆ two        ┆ 4          │\n│ 9     ┆ 77  ┆ lightblue  ┆ three      ┆ 1          │\n└───────┴─────┴────────────┴────────────┴────────────┘\nNote: Since the custom logic is based on the row index rather than actual column values, you can safely use pl.col(\"\") as a placeholder when calling the namespace methods.\nEach new column shows how rows are grouped using the row index modulo 2, 3, or 4—useful for highlighting patterns or applying styling.\nFor instance, you can use the binarized column with Great Tables like this:\n(\n    GT(df)\n    .tab_style(style=style.fill(pl.col(\"binarized\")), locations=loc.body())\n    .opt_stylize(style=6)\n)\n\n\n\n\n\n\n\nConclusion\nRegistering a custom expression namespace in Polars is a powerful way to encapsulate and reuse logic across your codebase. In this post, we created a DiscreteSplitter class to simplify index-based grouping, enabling operations like binarize, trinarize, and bucketize. This approach keeps your expressions clean and composable, especially when generating tables or plots that require styling based on row position.\nIt’s also worth noting that Polars supports similar registration for Series, LazyFrame, and DataFrame objects—check out the official documentation for more details.\n\n\nRemark\nHere’s a rough draft showing how to achieve a similar effect using the DataFrame namespace. I might revisit and refine this approach in the future.\n\n\nShow full code\nfrom typing import Any\n\nimport polars as pl\nfrom great_tables import GT, loc, style\n\n\n@pl.api.register_dataframe_namespace(\"spt\")\nclass DiscreteSplitter:\n    def __init__(self, df: pl.DataFrame) -&gt; None:\n        self._df = df\n        self._mod_colname = \"mod\"\n        self._mod_col = pl.col(self._mod_colname)\n        self._idx_colname = \"index\"\n        self._idx_col = pl.col(self._idx_colname)\n\n    def _get_df(self, n: int) -&gt; pl.DataFrame:\n        return self._df.with_row_index(self._idx_colname).with_columns(\n            self._idx_col.mod(n).alias(self._mod_colname)\n        )\n\n    def _get_final_df(self, n: int, expr: pl.Expr) -&gt; pl.DataFrame:\n        return (\n            self._get_df(n)\n            .with_columns(expr)\n            .drop([self._idx_colname, self._mod_colname])\n        )\n\n    def binarize(\n        self, lit1: str, lit2: str, name: str = \"binarized\"\n    ) -&gt; pl.DataFrame:\n        n = 2\n\n        expr = (\n            pl.when(self._mod_col.eq(0))\n            .then(pl.lit(lit1))\n            .otherwise(pl.lit(lit2))\n            .alias(name)\n        )\n\n        self._df = self._get_final_df(n, expr)\n        return self._df\n\n    def trinarize(\n        self, lit1: str, lit2: str, lit3: str, name: str = \"trinarized\"\n    ) -&gt; pl.DataFrame:\n        n = 3\n\n        expr = (\n            pl.when(self._mod_col.eq(0))\n            .then(pl.lit(lit1))\n            .when(self._mod_col.eq(1))\n            .then(pl.lit(lit2))\n            .otherwise(pl.lit(lit3))\n            .alias(name)\n        )\n\n        self._df = self._get_final_df(n, expr)\n        return self._df\n\n    def bucketize(\n        self, lits: list[Any], name: str = \"bucketized\"\n    ) -&gt; pl.DataFrame:\n        n = len(lits)\n\n        # first\n        expr = pl.when(self._mod_col.eq(0)).then(pl.lit(lits[0]))\n\n        # middles\n        for i, one_lit in enumerate(lits[1:-1], start=1):\n            expr = expr.when(self._mod_col.eq(i)).then(pl.lit(one_lit))\n\n        # last\n        expr = expr.otherwise(pl.lit(lits[-1]))\n\n        # alias\n        expr = expr.alias(name)\n\n        self._df = self._get_final_df(n, expr)\n        return self._df\n\n\ndf = (\n    pl.DataFrame({\"n\": [100, 50, 72, 83, 97, 42, 20, 51, 77]})\n    .spt.binarize(\"lightblue\", \"papayawhip\")\n    .spt.trinarize(\"one\", \"two\", \"three\")\n    .spt.bucketize([1, 2, 3, 4])\n    .with_row_index(offset=1)\n)\n\n(\n    GT(df)\n    .tab_style(style=style.fill(pl.col(\"binarized\")), locations=loc.body())\n    .opt_stylize(style=6)\n)\n\n\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/gt-marimo-in-quarto/20250612.html",
    "href": "posts/gt-marimo-in-quarto/20250612.html",
    "title": "Great Tables with marimo in Quarto",
    "section": "",
    "text": "This is a follow-up to my previous post."
  },
  {
    "objectID": "posts/gt-marimo-in-quarto/20250612.html#marimo",
    "href": "posts/gt-marimo-in-quarto/20250612.html#marimo",
    "title": "Great Tables with marimo in Quarto",
    "section": "marimo",
    "text": "marimo\n\n\n\n\n\n\nGive It a Sec – WASM Magic Happening\n\n\n\nThe widgets may take a few moments to load, as they rely on WebAssembly under the hood.\n\n\nHere, I demonstrate how marimo widgets can be embedded in Great Tables by wrapping them with the html() function provided by the library. This allows interactive widgets to control the table’s appearance in a Quarto environment via WASM — a surprisingly powerful capability, in my opinion.\n\n    \n    \n    \n    import%20marimo%20as%20mo%0Aimport%20polars%20as%20pl%0Afrom%20great_tables%20import%20GT%2C%20html\n\n\n    \n    \n    \n    data%20%3D%20%7B%0A%20%20%20%20%22col1%22%3A%20%5B2%2C%205%2C%207%2C%2010%2C%2015%5D%2C%0A%20%20%20%20%22col2%22%3A%20%5B%22x%22%2C%20%22y%22%2C%20%22y%22%2C%20%22z%22%2C%20%22z%22%5D%2C%0A%20%20%20%20%22color%22%3A%20%5B%0A%20%20%20%20%20%20%20%20%22lightgrey%22%2C%0A%20%20%20%20%20%20%20%20%22lightblue%22%2C%0A%20%20%20%20%20%20%20%20%22lightblue%22%2C%0A%20%20%20%20%20%20%20%20%22papayawhip%22%2C%0A%20%20%20%20%20%20%20%20%22papayawhip%22%2C%0A%20%20%20%20%5D%2C%0A%7D%0Adf%20%3D%20pl.DataFrame(data)%0Aprint(df)\n\n\n    \n    \n    \n    style_widget%20%3D%20mo.ui.slider(1%2C%206%2C%20label%3D%22Style%20Number%22)%0A%0A_colors%20%3D%20%5B%22blue%22%2C%20%22cyan%22%2C%20%22pink%22%2C%20%22green%22%2C%20%22red%22%2C%20%22gray%22%5D%0Acolor_widget%20%3D%20mo.ui.radio(%0A%20%20%20%20options%3D_colors%2C%20value%3D_colors%5B0%5D%2C%20label%3D%22Style%20Color%22%2C%20inline%3DTrue%0A)%0A%0Arow_striping_widget%20%3D%20mo.ui.switch(value%3DTrue%2C%20label%3D%22Row%20Striping%3F%22)%0A%0Agt%20%3D%20(%0A%20%20%20%20GT(df)%0A%20%20%20%20.tab_header(html(style_widget)%2C%20html(color_widget))%0A%20%20%20%20.tab_source_note(html(row_striping_widget))%0A%20%20%20%20.opt_align_table_header(%22left%22)%0A)\n\n\n    \n    \n    \n    gt.opt_stylize(%0A%20%20%20%20style%3Dstyle_widget.value%2C%0A%20%20%20%20color%3Dcolor_widget.value%2C%0A%20%20%20%20add_row_striping%3Drow_striping_widget.value%2C%0A)\n\nCheck out the full marimo code below or view it on molab.\n\n\nShow full code\nimport marimo\n\n__generated_with = \"0.13.15\"\napp = marimo.App(width=\"medium\")\n\n\n@app.cell\ndef _():\n    import marimo as mo\n    import polars as pl\n    from great_tables import GT, html\n\n    return GT, html, mo, pl\n\n\n@app.cell\ndef _(pl):\n    data = {\n        \"col1\": [2, 5, 7, 10, 15],\n        \"col2\": [\"x\", \"y\", \"y\", \"z\", \"z\"],\n        \"color\": [\n            \"lightgrey\",\n            \"lightblue\",\n            \"lightblue\",\n            \"papayawhip\",\n            \"papayawhip\",\n        ],\n    }\n    df = pl.DataFrame(data)\n    return (df,)\n\n\n@app.cell\ndef _(GT, df, html, mo):\n    style_widget = mo.ui.slider(1, 6, label=\"Style Number\")\n\n    _colors = [\"blue\", \"cyan\", \"pink\", \"green\", \"red\", \"gray\"]\n    color_widget = mo.ui.radio(\n        options=_colors, value=_colors[0], label=\"Style Color\", inline=True\n    )\n\n    row_striping_widget = mo.ui.switch(value=True, label=\"Row Striping?\")\n\n    gt = (\n        GT(df)\n        .tab_header(html(style_widget), html(color_widget))\n        .tab_source_note(html(row_striping_widget))\n        .opt_align_table_header(\"left\")\n    )\n    return color_widget, gt, row_striping_widget, style_widget\n\n\n@app.cell\ndef _(color_widget, gt, row_striping_widget, style_widget):\n    gt.opt_stylize(\n        style=style_widget.value,\n        color=color_widget.value,\n        add_row_striping=row_striping_widget.value,\n    )\n    return\n\n\nif __name__ == \"__main__\":\n    app.run()\n\n\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/styling-tricks-table-body/20250526.html",
    "href": "posts/styling-tricks-table-body/20250526.html",
    "title": "Styling tricks in Great Tables",
    "section": "",
    "text": "This post highlights a powerful yet underused feature in Great Tables: using existing columns to style the table body via from_column().\nLet’s say you have the following Polars DataFrame df:\n\nimport polars as pl\nfrom great_tables import GT, from_column, loc, style\nfrom great_tables.data import films\n\n\ndf_style = pl.DataFrame(\n    {\n        \"color\": [\"papayawhip\", \"lightblue\", \"lightgreen\"],\n        \"size\": [\"small\", \"x-large\", \"medium\"],\n        \"weight\": [\"normal\", \"bold\", \"lighter\"],\n        \"align\": [\"right\", \"center\", \"left\"],\n    }\n)\n\ncolumns = [\"year\", \"title\", \"run_time\"]\n\ndf = pl.concat(\n    [\n        pl.from_pandas(films.head(3).loc[:, columns]),\n        df_style,\n    ],\n    how=\"horizontal\",\n)\n\nprint(df)\n\nshape: (3, 7)\n┌──────┬───────────────────────────┬──────────┬────────────┬─────────┬─────────┬────────┐\n│ year ┆ title                     ┆ run_time ┆ color      ┆ size    ┆ weight  ┆ align  │\n│ ---  ┆ ---                       ┆ ---      ┆ ---        ┆ ---     ┆ ---     ┆ ---    │\n│ i64  ┆ str                       ┆ str      ┆ str        ┆ str     ┆ str     ┆ str    │\n╞══════╪═══════════════════════════╪══════════╪════════════╪═════════╪═════════╪════════╡\n│ 1946 ┆ The Lovers                ┆ 1h 30m   ┆ papayawhip ┆ small   ┆ normal  ┆ right  │\n│ 1946 ┆ Anna and the King of Siam ┆ 2h 8m    ┆ lightblue  ┆ x-large ┆ bold    ┆ center │\n│ 1946 ┆ Blood and Fire            ┆ 1h 40m   ┆ lightgreen ┆ medium  ┆ lighter ┆ left   │\n└──────┴───────────────────────────┴──────────┴────────────┴─────────┴─────────┴────────┘\n\n\nThe color, size, weight, and align columns contain style-related metadata. We can use from_column() to map this metadata to four styling options provided by Great Tables—style.fill(), style.text(), style.borders(), and style.css()—all of which are built on the internal CellStyle class.\n\n(\n    GT(df)\n    .tab_style(\n        style=[\n            style.fill(color=from_column(\"color\")),\n            style.text(\n                size=from_column(\"size\"),\n                weight=from_column(\"weight\"),\n                align=from_column(\"align\"),\n            ),\n        ],\n        locations=loc.body(columns),\n    )\n    .cols_hide(df_style.columns)\n    .opt_stylize(style=6, color=\"gray\")\n)\n\n\n\n\n\n\n\n  year\n  title\n  run_time\n\n\n\n  \n    1946\n    The Lovers\n    1h 30m\n  \n  \n    1946\n    Anna and the King of Siam\n    2h 8m\n  \n  \n    1946\n    Blood and Fire\n    1h 40m\n  \n\n\n\n\n\n\n        \n\n\nOne last note: from_column() works with both Pandas and Polars DataFrames. For Polars users, you can also pass expressions directly without wrapping them in from_column(). The following code produces the same styled table as shown above:\n\n(\n    GT(df)\n    .tab_style(\n        style=[\n            style.fill(color=pl.col(\"color\")),\n            style.text(\n                size=pl.col(\"size\"), weight=pl.col(\"weight\"), align=pl.col(\"align\")\n            ),\n        ],\n        locations=loc.body(columns),\n    )\n    .cols_hide(df_style.columns)\n    .opt_stylize(style=6, color=\"gray\")\n)\n\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/table-body-custom-palette/20250225.html",
    "href": "posts/table-body-custom-palette/20250225.html",
    "title": "Applying Custom Color Palettes to the Table Body in Great Tables",
    "section": "",
    "text": "This post provides a concise guide on styling the table body with custom colors using Pandas and Polars.\nThere are two primary methods for applying a color palette: one leverages a pre-existing column containing color values, while the other determines colors dynamically based on conditions. I’ll walk you through both approaches.\nSince all the generated tables will have the same appearance, I’ll display the final result just once:"
  },
  {
    "objectID": "posts/table-body-custom-palette/20250225.html#preparations",
    "href": "posts/table-body-custom-palette/20250225.html#preparations",
    "title": "Applying Custom Color Palettes to the Table Body in Great Tables",
    "section": "Preparations",
    "text": "Preparations\nWe’ll start by creating a data dictionary, which will be used with Pandas or Polars later. Additionally, we’ll define a color_mapping dictionary to store the palette information for styling.\n\nimport pandas as pd\nimport polars as pl\nfrom great_tables import GT, from_column, loc, style\nfrom polars import selectors as cs\n\ndata = {\n    \"col1\": [2, 5, 7, 10, 15],\n    \"col2\": [\"x\", \"y\", \"y\", \"z\", \"z\"],\n    \"color\": [\"lightgrey\", \"lightblue\", \"lightblue\", \"papayawhip\", \"papayawhip\"],\n}\n\ncolor_mapping = {\"x\": \"lightgrey\", \"y\": \"lightblue\", \"z\": \"papayawhip\"}"
  },
  {
    "objectID": "posts/table-body-custom-palette/20250225.html#pandas",
    "href": "posts/table-body-custom-palette/20250225.html#pandas",
    "title": "Applying Custom Color Palettes to the Table Body in Great Tables",
    "section": "Pandas",
    "text": "Pandas\nFirst, we create a Pandas DataFrame called df_pd using data as the input:\n\n\nCode\ndf_pd = pd.DataFrame(data)\nprint(df_pd)\n\n\n   col1 col2       color\n0     2    x   lightgrey\n1     5    y   lightblue\n2     7    y   lightblue\n3    10    z  papayawhip\n4    15    z  papayawhip\n\n\n\nUsing an Existing Column\nIn this straightforward scenario, the DataFrame already contains a predefined column with color names for each row. You can use the from_column() function provided by Great Tables to apply colors to the table body:\n\n(\n    GT(df_pd)\n    .tab_style(style=style.fill(color=from_column(\"color\")), locations=loc.body())\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)\n\n\n\nUsing Functions\nIn cases where colors need to be determined dynamically based on conditions, the pd.Series.case_when() function can be very useful. The following example categorizes the values of the col1 column into three different colors:\n\ndef color_selector(df_):\n    return df_[\"col1\"].case_when(\n        [\n            (df_[\"col1\"].lt(3), \"lightgrey\"),  # &lt;3\n            (df_[\"col1\"].lt(10), \"lightblue\"),  # &lt;10\n            (df_[\"col1\"].ge(10), \"papayawhip\"),  # &gt;=10\n        ]\n    )\n\n\n(\n    GT(df_pd)\n    .tab_style(style=style.fill(color=color_selector), locations=loc.body())\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)\n\nFor categorical-like columns (e.g., col2), a simple value-to-color mapping may be sufficient. In such cases, a predefined dictionary can be used with pd.Series.map() or pd.Series.replace():\n\npd.Series.map()pd.Series.replace()\n\n\n\n(\n    GT(df_pd)\n    .tab_style(\n        style=style.fill(color=lambda df_: df_[\"col2\"].map(color_mapping)),\n        locations=loc.body(),\n    )\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)\n\n\n\n\n(\n    GT(df_pd)\n    .tab_style(\n        style=style.fill(color=lambda df_: df_[\"col2\"].replace(color_mapping)),\n        locations=loc.body(),\n    )\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)\n\n\n\n\nAlternatively, if you prefer sticking with the same approach, pd.Series.case_when() still works:\n\ndef color_selector(df_):\n    return df_[\"col2\"].case_when(\n        [\n            (df_[\"col2\"].eq(\"x\"), \"lightgrey\"),\n            (df_[\"col2\"].eq(\"y\"), \"lightblue\"),\n            (df_[\"col2\"].eq(\"z\"), \"papayawhip\"),\n        ]\n    )\n\n\n(\n    GT(df_pd)\n    .tab_style(style=style.fill(color=color_selector), locations=loc.body())\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)"
  },
  {
    "objectID": "posts/table-body-custom-palette/20250225.html#polars",
    "href": "posts/table-body-custom-palette/20250225.html#polars",
    "title": "Applying Custom Color Palettes to the Table Body in Great Tables",
    "section": "Polars",
    "text": "Polars\nJust like before, let’s start by creating a Polars DataFrame named df_pl using data as input:\n\n\nCode\ndf_pl= pl.DataFrame(data)\nprint(df_pl)\n\n\nshape: (5, 3)\n┌──────┬──────┬────────────┐\n│ col1 ┆ col2 ┆ color      │\n│ ---  ┆ ---  ┆ ---        │\n│ i64  ┆ str  ┆ str        │\n╞══════╪══════╪════════════╡\n│ 2    ┆ x    ┆ lightgrey  │\n│ 5    ┆ y    ┆ lightblue  │\n│ 7    ┆ y    ┆ lightblue  │\n│ 10   ┆ z    ┆ papayawhip │\n│ 15   ┆ z    ┆ papayawhip │\n└──────┴──────┴────────────┘\n\n\n\nUsing an Existing Column\nIf the DataFrame already contains a column specifying colors, we can apply them directly with from_column():\n\n(\n    GT(df_pl)\n    .tab_style(style=style.fill(color=from_column(\"color\")), locations=loc.body())\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)\n\nAs another option, we can reference the color column using a Polars expression:\n\n(\n    GT(df_pl)\n    .tab_style(style=style.fill(color=pl.col(\"color\")), locations=loc.body())\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)\n\n\n\nUsing Conditional Logic with Polars Expressions\nFor cases where colors need to be assigned dynamically, pl.when() provides a structured way to define conditions. The example below assigns colors based on the values in col1:\n\ncolor_selector_expr = (\n    pl.when(pl.col(\"col1\").lt(3))  # &lt;3\n    .then(pl.lit(\"lightgrey\"))\n    .when(pl.col(\"col1\").lt(10))  # &lt;10\n    .then(pl.lit(\"lightblue\"))\n    .when(pl.col(\"col1\").ge(10))  # &gt;=10\n    .then(pl.lit(\"papayawhip\"))\n)\n\n(\n    GT(df_pl)\n    .tab_style(style=style.fill(color=color_selector_expr), locations=loc.body())\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)\n\nFor categorical-like columns (e.g., col2), predefined mappings can be applied efficiently using pl.Expr.replace():\n\n(\n    GT(df_pl)\n    .tab_style(\n        style=style.fill(color=pl.col(\"col2\").replace(color_mapping)),\n        locations=loc.body(),\n    )\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)\n\nAlternatively, if you prefer the conditional approach, pl.when() can still be used:\n\ncolor_selector_expr = (\n    pl.when(pl.col(\"col2\").eq(pl.lit(\"x\")))\n    .then(pl.lit(\"lightgrey\"))\n    .when(pl.col(\"col2\").eq(pl.lit(\"y\")))\n    .then(pl.lit(\"lightblue\"))\n    .when(pl.col(\"col2\").eq(pl.lit(\"z\")))\n    .then(pl.lit(\"papayawhip\"))\n)\n\n\n(\n    GT(df_pl)\n    .tab_style(style=style.fill(color=color_selector_expr), locations=loc.body())\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)"
  },
  {
    "objectID": "posts/table-body-custom-palette/20250225.html#final-notes",
    "href": "posts/table-body-custom-palette/20250225.html#final-notes",
    "title": "Applying Custom Color Palettes to the Table Body in Great Tables",
    "section": "Final Notes",
    "text": "Final Notes\nIn this post, we explored how to use a custom color palette to style table backgrounds with style.fill(). The same approach can be applied to customize text color using style.text() or adjust border color with style.borders().\nLastly, remember that loc.body() allows you to target specific columns and rows, giving you precise control over table styling.\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  }
]