[
  {
    "objectID": "posts/table-body-custom-palette/20250225.html",
    "href": "posts/table-body-custom-palette/20250225.html",
    "title": "Applying Custom Color Palettes to the Table Body in Great Tables",
    "section": "",
    "text": "This post provides a concise guide on styling the table body with custom colors using Pandas and Polars.\nThere are two primary methods for applying a color palette: one leverages a pre-existing column containing color values, while the other determines colors dynamically based on conditions. I’ll walk you through both approaches.\nSince all the generated tables will have the same appearance, I’ll display the final result just once:"
  },
  {
    "objectID": "posts/table-body-custom-palette/20250225.html#preparations",
    "href": "posts/table-body-custom-palette/20250225.html#preparations",
    "title": "Applying Custom Color Palettes to the Table Body in Great Tables",
    "section": "Preparations",
    "text": "Preparations\nWe’ll start by creating a data dictionary, which will be used with Pandas or Polars later. Additionally, we’ll define a color_mapping dictionary to store the palette information for styling.\n\nimport pandas as pd\nimport polars as pl\nfrom great_tables import GT, from_column, loc, style\nfrom polars import selectors as cs\n\ndata = {\n    \"col1\": [2, 5, 7, 10, 15],\n    \"col2\": [\"x\", \"y\", \"y\", \"z\", \"z\"],\n    \"color\": [\"lightgrey\", \"lightblue\", \"lightblue\", \"papayawhip\", \"papayawhip\"],\n}\n\ncolor_mapping = {\"x\": \"lightgrey\", \"y\": \"lightblue\", \"z\": \"papayawhip\"}"
  },
  {
    "objectID": "posts/table-body-custom-palette/20250225.html#pandas",
    "href": "posts/table-body-custom-palette/20250225.html#pandas",
    "title": "Applying Custom Color Palettes to the Table Body in Great Tables",
    "section": "Pandas",
    "text": "Pandas\nFirst, we create a Pandas DataFrame called df_pd using data as the input:\n\n\nCode\ndf_pd = pd.DataFrame(data)\nprint(df_pd)\n\n\n   col1 col2       color\n0     2    x   lightgrey\n1     5    y   lightblue\n2     7    y   lightblue\n3    10    z  papayawhip\n4    15    z  papayawhip\n\n\n\nUsing an Existing Column\nIn this straightforward scenario, the DataFrame already contains a predefined column with color names for each row. You can use the from_column() function provided by Great Tables to apply colors to the table body:\n\n(\n    GT(df_pd)\n    .tab_style(style=style.fill(color=from_column(\"color\")), locations=loc.body())\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)\n\n\n\nUsing Functions\nIn cases where colors need to be determined dynamically based on conditions, the pd.Series.case_when() function can be very useful. The following example categorizes the values of the col1 column into three different colors:\n\ndef color_selector(df_):\n    return df_[\"col1\"].case_when(\n        [\n            (df_[\"col1\"].lt(3), \"lightgrey\"),  # &lt;3\n            (df_[\"col1\"].lt(10), \"lightblue\"),  # &lt;10\n            (df_[\"col1\"].ge(10), \"papayawhip\"),  # &gt;=10\n        ]\n    )\n\n\n(\n    GT(df_pd)\n    .tab_style(style=style.fill(color=color_selector), locations=loc.body())\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)\n\nFor categorical-like columns (e.g., col2), a simple value-to-color mapping may be sufficient. In such cases, a predefined dictionary can be used with pd.Series.map() or pd.Series.replace():\n\npd.Series.map()pd.Series.replace()\n\n\n\n(\n    GT(df_pd)\n    .tab_style(\n        style=style.fill(color=lambda df_: df_[\"col2\"].map(color_mapping)),\n        locations=loc.body(),\n    )\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)\n\n\n\n\n(\n    GT(df_pd)\n    .tab_style(\n        style=style.fill(color=lambda df_: df_[\"col2\"].replace(color_mapping)),\n        locations=loc.body(),\n    )\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)\n\n\n\n\nAlternatively, if you prefer sticking with the same approach, pd.Series.case_when() still works:\n\ndef color_selector(df_):\n    return df_[\"col2\"].case_when(\n        [\n            (df_[\"col2\"].eq(\"x\"), \"lightgrey\"),\n            (df_[\"col2\"].eq(\"y\"), \"lightblue\"),\n            (df_[\"col2\"].eq(\"z\"), \"papayawhip\"),\n        ]\n    )\n\n\n(\n    GT(df_pd)\n    .tab_style(style=style.fill(color=color_selector), locations=loc.body())\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)"
  },
  {
    "objectID": "posts/table-body-custom-palette/20250225.html#polars",
    "href": "posts/table-body-custom-palette/20250225.html#polars",
    "title": "Applying Custom Color Palettes to the Table Body in Great Tables",
    "section": "Polars",
    "text": "Polars\nJust like before, let’s start by creating a Polars DataFrame named df_pl using data as input:\n\n\nCode\ndf_pl= pl.DataFrame(data)\nprint(df_pl)\n\n\nshape: (5, 3)\n┌──────┬──────┬────────────┐\n│ col1 ┆ col2 ┆ color      │\n│ ---  ┆ ---  ┆ ---        │\n│ i64  ┆ str  ┆ str        │\n╞══════╪══════╪════════════╡\n│ 2    ┆ x    ┆ lightgrey  │\n│ 5    ┆ y    ┆ lightblue  │\n│ 7    ┆ y    ┆ lightblue  │\n│ 10   ┆ z    ┆ papayawhip │\n│ 15   ┆ z    ┆ papayawhip │\n└──────┴──────┴────────────┘\n\n\n\nUsing an Existing Column\nIf the DataFrame already contains a column specifying colors, we can apply them directly with from_column():\n\n(\n    GT(df_pl)\n    .tab_style(style=style.fill(color=from_column(\"color\")), locations=loc.body())\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)\n\nAs another option, we can reference the color column using a Polars expression:\n\n(\n    GT(df_pl)\n    .tab_style(style=style.fill(color=pl.col(\"color\")), locations=loc.body())\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)\n\n\n\nUsing Conditional Logic with Polars Expressions\nFor cases where colors need to be assigned dynamically, pl.when() provides a structured way to define conditions. The example below assigns colors based on the values in col1:\n\ncolor_selector_expr = (\n    pl.when(pl.col(\"col1\").lt(3))  # &lt;3\n    .then(pl.lit(\"lightgrey\"))\n    .when(pl.col(\"col1\").lt(10))  # &lt;10\n    .then(pl.lit(\"lightblue\"))\n    .when(pl.col(\"col1\").ge(10))  # &gt;=10\n    .then(pl.lit(\"papayawhip\"))\n)\n\n(\n    GT(df_pl)\n    .tab_style(style=style.fill(color=color_selector_expr), locations=loc.body())\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)\n\nFor categorical-like columns (e.g., col2), predefined mappings can be applied efficiently using pl.Expr.replace():\n\n(\n    GT(df_pl)\n    .tab_style(\n        style=style.fill(color=pl.col(\"col2\").replace(color_mapping)),\n        locations=loc.body(),\n    )\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)\n\nAlternatively, if you prefer the conditional approach, pl.when() can still be used:\n\ncolor_selector_expr = (\n    pl.when(pl.col(\"col2\").eq(pl.lit(\"x\")))\n    .then(pl.lit(\"lightgrey\"))\n    .when(pl.col(\"col2\").eq(pl.lit(\"y\")))\n    .then(pl.lit(\"lightblue\"))\n    .when(pl.col(\"col2\").eq(pl.lit(\"z\")))\n    .then(pl.lit(\"papayawhip\"))\n)\n\n\n(\n    GT(df_pl)\n    .tab_style(style=style.fill(color=color_selector_expr), locations=loc.body())\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)"
  },
  {
    "objectID": "posts/table-body-custom-palette/20250225.html#final-notes",
    "href": "posts/table-body-custom-palette/20250225.html#final-notes",
    "title": "Applying Custom Color Palettes to the Table Body in Great Tables",
    "section": "Final Notes",
    "text": "Final Notes\nIn this post, we explored how to use a custom color palette to style table backgrounds with style.fill(). The same approach can be applied to customize text color using style.text() or adjust border color with style.borders().\nLastly, remember that loc.body() allows you to target specific columns and rows, giving you precise control over table styling.\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/django-allauth-resend/20241223.html",
    "href": "posts/django-allauth-resend/20241223.html",
    "title": "Exploring Resend SMTP Service with Django",
    "section": "",
    "text": "This post demonstrates how to integrate Resend with django-allauth seamlessly in a Django project. If you’re looking to use Resend for sending emails via Django, refer to the repo provided by Resend."
  },
  {
    "objectID": "posts/django-allauth-resend/20241223.html#preparations-for-django",
    "href": "posts/django-allauth-resend/20241223.html#preparations-for-django",
    "title": "Exploring Resend SMTP Service with Django",
    "section": "Preparations for Django",
    "text": "Preparations for Django\n\nCreate a Virtual Environment\nStart by creating a virtual environment using uv and activating it:\nuv venv venv\nsource venv/bin/activate\n\n\nInstall Required Packages\nCreate a requirements.txt file and add the necessary dependencies:\ndjango\nenvirons[django]\ndjango-allauth\nInstall the packages via uv:\nuv pip install -r requirements.txt\n\n\nSet Up a Django Project\nUse the django-admin command to create a project named core:\ndjango-admin startproject core .\n\n\nConfigure Environment Variables\nCreate a .env file with the following content:\nDEFAULT_FROM_EMAIL=\nRESEND_SMTP_HOST=smtp.resend.com\nRESEND_SMTP_USERNAME=resend\nRESEND_API_KEY=\nRESEND_SMTP_PORT=587\nRESEND_USE_TLS=True\nThe next sections explain how to obtain DEFAULT_FROM_EMAIL and RESEND_API_KEY."
  },
  {
    "objectID": "posts/django-allauth-resend/20241223.html#preparations-for-resend",
    "href": "posts/django-allauth-resend/20241223.html#preparations-for-resend",
    "title": "Exploring Resend SMTP Service with Django",
    "section": "Preparations for Resend",
    "text": "Preparations for Resend\n\nVerify Your Domain\nFollow the Resend documentation to verify your domain. Once verified, you can send emails using an address like user@send.yourdomain.com.\n\nYou control the prefix before @, as ownership of the domain has been confirmed.\n\nAdd your chosen email to DEFAULT_FROM_EMAIL in the .env file.\n\n\n\nObtain an API Key\nGenerate an API key via the Resend API Keys page and add it to the RESEND_API_KEY field in your .env file."
  },
  {
    "objectID": "posts/django-allauth-resend/20241223.html#django-scaffold",
    "href": "posts/django-allauth-resend/20241223.html#django-scaffold",
    "title": "Exploring Resend SMTP Service with Django",
    "section": "Django Scaffold",
    "text": "Django Scaffold\nFollow the quick start guide from django-allauth to configure the project with minimal setup.\n\nModify core/urls.py\nInclude django-allauth routes and define a homepage route:\n# core/urls.py\n\nfrom django.contrib import admin\nfrom django.urls import path, include\nfrom . import views\n\nurlpatterns = [\n    path(\"admin/\", admin.site.urls),\n    path(\"accounts/\", include(\"allauth.urls\")),  # added\n    path(\"\", views.index, name=\"home\"),  # added\n]\n\n\nAdd core/views.py\nDefine the homepage with a link to the signup URL provided by django-allauth:\nfrom django.http import HttpResponse\nfrom django.urls import reverse\n\n\ndef index(request):\n    signup_url = reverse(\"account_signup\")\n    return HttpResponse(f'&lt;a href=\"{signup_url}\"&gt;Hello, please Sign Up here!&lt;/a&gt;')\n\n\nModify core/settings.py\n\nRead Environment Variables\n# core/settings.py\n\nfrom environs import Env\n\nenv = Env()\nenv.read_env()\n\n\nUpdate INSTALLED_APPS\n# core/settings.py\n\nINSTALLED_APPS = [\n    ...\n    \"allauth\",  # added\n    \"allauth.account\",  # added\n]\n\n\nUpdate MIDDLEWARE\n# core/settings.py\n\nMIDDLEWARE = [\n    \"django.middleware.security.SecurityMiddleware\",\n    \"django.contrib.sessions.middleware.SessionMiddleware\",\n    \"django.middleware.common.CommonMiddleware\",\n    \"django.middleware.csrf.CsrfViewMiddleware\",\n    \"django.contrib.auth.middleware.AuthenticationMiddleware\",\n    \"django.contrib.messages.middleware.MessageMiddleware\",\n    \"allauth.account.middleware.AccountMiddleware\",  # added\n    ...\n]\n\n\nConfigure Email Backend and Authentication Backends\n# core/settings.py\n\nEMAIL_BACKEND = \"django.core.mail.backends.smtp.EmailBackend\"\n\nAUTHENTICATION_BACKENDS = [\n    \"django.contrib.auth.backends.ModelBackend\",\n    \"allauth.account.auth_backends.AuthenticationBackend\",\n]\n\n\nDefine Login and Logout Redirect URLs\nHere, we define only ACCOUNT_LOGOUT_REDIRECT_URL because django-allauth overwrites LOGOUT_REDIRECT_URL.\nLOGIN_REDIRECT_URL = \"home\"\nACCOUNT_LOGOUT_REDIRECT_URL = \"home\"\n\n\nOptional Preference Settings\nOpinionated configurations for a simplified signup and email-based login:\nACCOUNT_SIGNUP_PASSWORD_ENTER_TWICE = False\nACCOUNT_USERNAME_REQUIRED = False\nACCOUNT_AUTHENTICATION_METHOD = \"email\"\nACCOUNT_EMAIL_REQUIRED = True\nACCOUNT_UNIQUE_EMAIL = True\n\n\nDefine Resend Variables\nDEFAULT_FROM_EMAIL = env(\"DEFAULT_FROM_EMAIL\")\nRESEND_SMTP_HOST = env(\"RESEND_SMTP_HOST\")\nRESEND_SMTP_USERNAME = env(\"RESEND_SMTP_USERNAME\")\nRESEND_API_KEY = env(\"RESEND_API_KEY\")\nRESEND_SMTP_PORT = env.int(\"RESEND_SMTP_PORT\")\nRESEND_USE_TLS = env.bool(\"RESEND_USE_TLS\")\n\n\nMap Resend Variables to Django Email Variables\nDelegate Django email settings to Resend environment variables:\nEMAIL_HOST = RESEND_SMTP_HOST\nEMAIL_HOST_USER = RESEND_SMTP_USERNAME\nEMAIL_HOST_PASSWORD = RESEND_API_KEY\nEMAIL_PORT = RESEND_SMTP_PORT\nEMAIL_USE_TLS = RESEND_USE_TLS"
  },
  {
    "objectID": "posts/django-allauth-resend/20241223.html#tryout",
    "href": "posts/django-allauth-resend/20241223.html#tryout",
    "title": "Exploring Resend SMTP Service with Django",
    "section": "Tryout",
    "text": "Tryout\nMigrate the database and run the development server with the following commands:\npython manage.py migrate\npython manage.py runserver\nNow, go to http://127.0.0.1:8000/ and click the sign-up link. You should see the signup page. After submitting the form, you will be redirected to the homepage.\nNext, check your inbox for an email with the subject [127.0.0.1:8000] Please Confirm Your Email Address.\nThe email will contain a confirmation link. Click the link, then click the confirmation button, and you’re all set for user registration!\n\n\n\n\n\n\nTip\n\n\n\nIf you encounter issues during configuration, the Resend logs can be a helpful resource, as they provide the request body, response body, and status code."
  },
  {
    "objectID": "posts/django-allauth-resend/20241223.html#final-words",
    "href": "posts/django-allauth-resend/20241223.html#final-words",
    "title": "Exploring Resend SMTP Service with Django",
    "section": "Final Words",
    "text": "Final Words\nThe configuration is straightforward, and it’s great that Resend offers SMTP services. The modern dashboard operates smoothly, and the well-documented resources make it easy for developers to find needed information. So far, the user experience has been positive, and I look forward to using it in real projects.\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/clone-reciprocal-tariffs-table/20250403.html",
    "href": "posts/clone-reciprocal-tariffs-table/20250403.html",
    "title": "Clone the Reciprocal Tariffs Table Using Great Tables",
    "section": "",
    "text": "This post demonstrates how to clone the Reciprocal Tariffs table that President Donald Trump announced on April 2 on Truth Social.\nSince the code is largely self-explanatory, I will highlight some tricks and caveats I encountered while building the table:\n\nThe reciprocal_tariffs dictionary was extracted with the help of AI.\nThe border radius was one of the trickiest aspects of the table—it took some time to figure out how to fill the gap between the rounded corners and the rectangle. Fortunately, I drew inspiration from the Great Tables example, Highest Paid Athletes in 2023. The solution was to use two &lt;div&gt; tags, which allowed me to assign distinct colors to the inside and outside of the border.\nI created four empty columns—[\"0\", \"1\", \"2\", \"3\"]—to serve as borders. This allowed for easier adjustment of border properties such as color and width. An interesting feature of GT.cols_width() is that you can set column widths using percentages, and the total doesn’t need to add up to exactly 100%—it just works. This is especially handy when experimenting with different table designs, as it lets you estimate widths without worrying about precise calculations.\nI added a “mod” column to help distinguish whether a row’s index is odd or even. This made it possible to combine pl.when().then().otherwise() with pl.Expr.map_elements(). Although pl.Expr.map_elements() is generally considered an anti-pattern in Polars, I believe it fits my use case well.\nThe column_labels_border_bottom_style= parameter in GT.tab_options() is key to hiding the line between the column labels and the table body.\nLogo embedding might seem a bit tricky if you’re new to Great Tables; I suggest reading the blog post that details how to render images anywhere in Great Tables.\nTo enhance the overall visual effect, I added a row at the end of the table and filled it with the same background color.\nThe original table featured two rings, but I was only able to implement the inner one. Ultimately, I chose to present the table without it. If you’re interested in how I implemented the ring, the code is available in the comments below.\nWhile the color codes and font properties could be further enhanced, Great Tables successfully replicates the table’s structure and style with only minor differences.\n\n\n\n\n\n\n\n\nShow full code\nimport polars as pl\nfrom great_tables import GT, google_font, html, loc, style, vals\n\n# source1: https://truthsocial.com/@realDonaldTrump/114270398531479278\n# source2:\n# \"https://upload.wikimedia.org/wikipedia/commons/\n# thumb/3/36/Seal_of_the_President_of_the_United_States.svg/\n# 800px-Seal_of_the_President_of_the_United_States.svg.png\"\nlogo = vals.fmt_image(\"logo.png\", height=150)[0]\n\nreciprocal_tariffs = {\n    \"country\": [\n        \"China\",\n        \"European Union\",\n        \"Vietnam\",\n        \"Taiwan\",\n        \"Japan\",\n        \"India\",\n        \"South Korea\",\n        \"Thailand\",\n        \"Switzerland\",\n        \"Indonesia\",\n        \"Malaysia\",\n        \"Cambodia\",\n        \"United Kingdom\",\n        \"South Africa\",\n        \"Brazil\",\n        \"Bangladesh\",\n        \"Singapore\",\n        \"Israel\",\n        \"Philippines\",\n        \"Chile\",\n        \"Australia\",\n        \"Pakistan\",\n        \"Turkey\",\n        \"Sri Lanka\",\n        \"Colombia\",\n    ],\n    \"tariffs_charged\": [\n        \"67%\",\n        \"39%\",\n        \"90%\",\n        \"64%\",\n        \"46%\",\n        \"52%\",\n        \"50%\",\n        \"72%\",\n        \"61%\",\n        \"64%\",\n        \"47%\",\n        \"97%\",\n        \"10%\",\n        \"60%\",\n        \"10%\",\n        \"74%\",\n        \"10%\",\n        \"33%\",\n        \"34%\",\n        \"10%\",\n        \"10%\",\n        \"58%\",\n        \"10%\",\n        \"88%\",\n        \"10%\",\n    ],\n    \"reciprocal_tariffs\": [\n        \"34%\",\n        \"20%\",\n        \"46%\",\n        \"32%\",\n        \"24%\",\n        \"26%\",\n        \"25%\",\n        \"36%\",\n        \"31%\",\n        \"32%\",\n        \"24%\",\n        \"49%\",\n        \"10%\",\n        \"30%\",\n        \"10%\",\n        \"37%\",\n        \"10%\",\n        \"17%\",\n        \"17%\",\n        \"10%\",\n        \"10%\",\n        \"29%\",\n        \"10%\",\n        \"44%\",\n        \"10%\",\n    ],\n}\n\ndark_navy_blue = \"#0B162A\"  # background\nlight_blue = \"#B5D3E7\"  # row\nwhite = \"#FFFFFF\"  # row\nyellow = \"#F6D588\"  # \"reciprocal_tariffs\" column\ngold = \"#FFF8DE\"  # logo\n\n\ndef change_border_radius(\n    x: str, border_radius: int, background_color1: str, background_color2: str\n) -&gt; str:\n    return f\"\"\"\\\n    &lt;div style=\"background-color: {background_color1};border: None\"&gt;\\\n        &lt;div style=\"border-radius: {border_radius};\\\n                    background-color:{background_color2};\"&gt;\\\n            &nbsp;{x}\\\n        &lt;/div&gt;\\\n    &lt;/div&gt;\\\n    \"\"\"\n\n\ndef change_border_radius_expr(\n    cols: pl.Expr,\n    return_dtype: pl.DataType,\n    border_radius: int,\n    background_color1: str,\n    background_color2: str,\n) -&gt; pl.Expr:\n    return cols.map_elements(\n        lambda x: change_border_radius(\n            x, border_radius, background_color1, background_color2\n        ),\n        return_dtype=return_dtype,\n    )\n\n\ndf = (\n    pl.DataFrame(reciprocal_tariffs)\n    .with_row_index(\"mod\")\n    .with_columns(pl.col(\"mod\").mod(2), *[pl.lit(\"\").alias(str(i)) for i in range(4)])\n    .with_columns(\n        # \"country\" and \"tariffs_charged\" columns\n        pl.when(pl.col(\"mod\").eq(0))\n        .then(\n            change_border_radius_expr(\n                pl.col(\"country\", \"tariffs_charged\"),\n                pl.String,\n                \"5px\",\n                dark_navy_blue,\n                light_blue,\n            )\n        )\n        .otherwise(\n            change_border_radius_expr(\n                pl.col(\"country\", \"tariffs_charged\"),\n                pl.String,\n                \"5px\",\n                dark_navy_blue,\n                white,\n            )\n        ),\n        # \"reciprocal_tariffs\" column\n        change_border_radius_expr(\n            pl.col(\"reciprocal_tariffs\"), pl.String, \"5px\", dark_navy_blue, yellow\n        ),\n    )\n    .select([\"0\", \"country\", \"1\", \"tariffs_charged\", \"2\", \"reciprocal_tariffs\", \"3\"])\n    # add a row at the end of the table\n    .pipe(\n        lambda df_: pl.concat(\n            [df_, pl.DataFrame({col: \"\" for col in df_.columns})], how=\"vertical\"\n        )\n    )\n)\n\n# inner_ring_color, inner_ring_style, inner_ring_weight = \"orange\", \"dashed\", \"3px\"\n\n(\n    GT(df)\n    .cols_align(\"center\", columns=[\"tariffs_charged\", \"reciprocal_tariffs\"])\n    .cols_label(\n        {\n            \"country\": html(\n                f\"\"\"\\\n                &lt;br&gt;\\\n                &lt;div&gt;\\\n                    {logo}&nbsp;\\\n                    &lt;span style=\"color: {gold}; font-size: 40px;\"&gt;\\\n                        &nbsp&nbsp;Reciprocal Tariffs\\\n                    &lt;/span&gt;\\\n                &lt;/div&gt;\\\n                &lt;br&gt;\\\n                &lt;b&gt;Country&lt;/b&gt;\\\n                \"\"\"\n            ),\n            \"tariffs_charged\": html(\n                \"\"\"\\\n                &lt;b&gt;Tariffs Charged&lt;br&gt;to the U.S.A.&lt;/b&gt;\\\n                &lt;br&gt;\\\n                &lt;span style=\"font-size: 12px;\"&gt;\\\n                    Including&lt;br&gt;Currency Manipulation&lt;br&gt;and Trade Barriers\\\n                &lt;/span&gt;\\\n                \"\"\"\n            ),\n            \"reciprocal_tariffs\": html(\n                \"&lt;b&gt;U.S.A. Discounted&lt;br&gt;Reciprocal Tariffs&lt;/b&gt;\"\n            ),\n            \"0\": \"\",\n            \"1\": \"\",\n            \"2\": \"\",\n            \"3\": \"\",\n        }\n    )\n    .cols_width(\n        {\n            \"country\": \"50%\",\n            \"0\": \"3%\",\n            \"1\": \"7%\",\n            \"2\": \"7%\",\n            \"3\": \"3%\",\n            \"tariffs_charged\": \"18%\",\n            \"reciprocal_tariffs\": \"18%\",\n        }\n    )\n    # set the background color of the labels and body to `dark_navy_blue`\n    .tab_style(\n        style=style.fill(color=dark_navy_blue),\n        locations=[loc.column_labels(), loc.body()],\n    )\n    # set the border color of the body to `dark_navy_blue`\n    .tab_style(\n        style=style.borders(sides=\"all\", color=dark_navy_blue),\n        locations=loc.body(),\n    )\n    # set the font for the body text\n    .tab_style(\n        style=style.text(\n            font=google_font(name=\"Trajan Pro\"), weight=\"bold\", size=\"xx-large\"\n        ),\n        locations=loc.body(),\n    )\n    # set the font for the labels\n    .tab_style(\n        style=style.text(font=google_font(name=\"Georgia\"), weight=\"bold\", size=\"large\"),\n        locations=loc.column_labels(),\n    )\n    # set the text color of the labels to `white`\n    .tab_style(style=style.text(color=white), locations=loc.column_labels())\n    # center-align the labels\n    .tab_style(style=style.css(\"text-align: center;\"), locations=loc.column_labels())\n    # hide the bottom line of the label section\n    .tab_options(column_labels_border_bottom_style=\"hidden\")\n    # set the body background color to `dark_navy_blue` for the last row\n    .tab_style(style=style.fill(color=dark_navy_blue), locations=loc.body(rows=[-1]))\n    # need to adjust `window_size` to obtain a higher-quality figure\n    # .save(\"reciprocal_tariffs_gt.png\", web_driver=\"firefox\", window_size=(1200, 1000))\n    #\n    # =========================\n    # inner ring\n    # =========================\n    #\n    # .tab_style(\n    #     style=style.borders(\n    #         sides=\"bottom\",\n    #         color=inner_ring_color,\n    #         style=inner_ring_style,\n    #         weight=inner_ring_weight,\n    #     ),\n    #     locations=loc.body(rows=[-1]),\n    # )\n    # .tab_style(\n    #     style=style.borders(\n    #         sides=\"left\",\n    #         color=inner_ring_color,\n    #         style=inner_ring_style,\n    #         weight=inner_ring_weight,\n    #     ),\n    #     locations=loc.body(columns=[\"0\"]),\n    # )\n    # .tab_style(\n    #     style=style.borders(\n    #         sides=\"right\",\n    #         color=inner_ring_color,\n    #         style=inner_ring_style,\n    #         weight=inner_ring_weight,\n    #     ),\n    #     locations=loc.body(columns=[\"3\"]),\n    # )\n    # .tab_style(\n    #     style=style.borders(\n    #         sides=\"top\",\n    #         color=inner_ring_color,\n    #         style=inner_ring_style,\n    #         weight=inner_ring_weight,\n    #     ),\n    #     locations=loc.column_labels(),\n    # )\n    # .tab_style(\n    #     style=style.borders(\n    #         sides=\"left\",\n    #         color=inner_ring_color,\n    #         style=inner_ring_style,\n    #         weight=inner_ring_weight,\n    #     ),\n    #     locations=loc.column_labels(columns=[\"0\"]),\n    # )\n    # .tab_style(\n    #     style=style.borders(\n    #         sides=\"right\",\n    #         color=inner_ring_color,\n    #         style=inner_ring_style,\n    #         weight=inner_ring_weight,\n    #     ),\n    #     locations=loc.column_labels(columns=[\"3\"]),\n    # )\n)\n\n\n\n\n\n\n\n\nDisclaimer\n\n\n\n\nThis table is intended as a self-practice project, and the data in the table may not be 100% accurate. Please refer to the original source if you require verified data.\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html",
    "href": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html",
    "title": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib",
    "section": "",
    "text": "It was an honor to be one of the reviewers for Matt Harrison’s new book, Effective Visualization. If you’re looking to deepen your understanding of how to use Pandas and Matplotlib to craft compelling data stories, this book is a must-read.\nLast weekend, I decided to convert some of the Pandas code from the book into Polars just for fun, and I’d like to share an example in this post. You can find the original Pandas code in the repo (empty link for now).\nThe final figure, shown below, visualizes temperature trends for the ski season in Alta over the past few decades.\nShow full code\nfrom functools import partial\n\nimport matplotlib.pyplot as plt\nimport polars as pl\nimport polars.selectors as cs\nfrom highlight_text import ax_text\nfrom matplotlib import colormaps\n\n# https://github.com/mattharrison/datasets/raw/refs/heads/master/data/alta-noaa-1980-2019.csv\ndata_path = \"alta-noaa-1980-2019.csv\"\ncolumns = [\"DATE\", \"TOBS\"]\ndf = pl.scan_csv(data_path).select(columns).collect()\n\n\ndef get_season_expr(col: str = \"DATE\", alias: str = \"SEASON\") -&gt; pl.expr:\n    return (\n        (\n            pl.when((pl.col(col).dt.month().is_between(5, 10, closed=\"both\")))\n            .then(pl.lit(\"Summer \"))\n            .otherwise(pl.lit(\"Ski \"))\n        )\n        .add(\n            pl.when(pl.col(col).dt.month() &lt; 11)\n            .then(pl.col(col).dt.year().cast(pl.String))\n            .otherwise(pl.col(col).dt.year().add(1).cast(pl.String))\n        )\n        .alias(alias)\n    )\n\n\ndef add_day_of_season_expr(\n    col: str = \"DATE\", group_col: str = \"SEASON\", alias: str = \"DAY_OF_SEASON\"\n) -&gt; pl.expr:\n    return (\n        (pl.col(col) - pl.col(col).min()).dt.total_days().over(group_col).alias(alias)\n    )\n\n\ndef plot_temps(df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\") -&gt; pl.DataFrame:\n    plt.rcParams[\"font.family\"] = \"Roboto\"\n    figsize = (160, 165)  # pts\n\n    def points_to_inches(points):\n        return points / 72\n\n    figsize_inches = [points_to_inches(dim) for dim in figsize]\n\n    heading_fontsize = 9.5\n    heading_fontweight = \"bold\"\n    subheading_fontsize = 8\n    subheading_fontweight = \"normal\"\n    source_fontsize = 6.5\n    source_fontweight = \"light\"\n    axis_fontsize = 7\n    axis_fontweight = \"normal\"\n\n    grey = \"#aaaaaa\"\n    red = \"#e3120b\"\n    blue = \"#0000ff\"\n    cmap = colormaps.get_cmap(\"Grays\")\n\n    layout = [[\"title\"], [\"plot\"], [\"notes\"]]\n    fig, axs = plt.subplot_mosaic(\n        layout,\n        gridspec_kw={\"height_ratios\": [6, 12, 1]},\n        figsize=figsize_inches,\n        dpi=300,\n        constrained_layout=True,\n    )\n\n    # ----- Title -----\n    ax_title = axs[\"title\"]\n    ax_title.axis(\"off\")\n    sub_props = {\"fontsize\": subheading_fontsize, \"fontweight\": subheading_fontweight}\n    ax_text(\n        s=\"&lt;Alta Ski Resort&gt;\\n&lt;Temperature trends by &gt;\\n&lt;decade&gt;&lt; and &gt;&lt;2019&gt;\",\n        x=0,\n        y=0,\n        fontsize=heading_fontsize,\n        ax=ax_title,\n        va=\"bottom\",\n        ha=\"left\",\n        zorder=5,\n        highlight_textprops=[\n            {\"fontsize\": heading_fontsize, \"fontweight\": heading_fontweight},\n            sub_props,\n            {\"color\": blue, **sub_props},\n            sub_props,\n            {\"color\": red, **sub_props},\n        ],\n    )\n\n    # ----- Plot -----\n    ax = axs[\"plot\"]\n    season_temps = df_.filter(pl.col(\"SEASON\").str.contains(\"Ski\")).pivot(\n        \"SEASON\", index=idx_colname, values=\"TMEAN\", aggregate_function=\"first\"\n    )\n    season_temps_index = season_temps[idx_colname]\n\n    columns = season_temps.columns\n    columns.remove(idx_colname)\n    columns.remove(\"Ski 2019\")\n    for i, column in enumerate(columns):\n        color = cmap(i / len(columns))\n        ax.plot(\n            season_temps_index,\n            season_temps[column],\n            color=color,\n            linewidth=1,\n            alpha=0.2,\n            zorder=1,\n        )\n\n    # # ---- Decade Averages ----\n    decades = [1980, 1990, 2000, 2010]\n    blues = [\"#0055EE\", \"#0033CC\", \"#0011AA\", \"#3377FF\"]\n    for decade, color in zip(decades, blues):\n        match = str(decade)[:-1]  # 1980 -&gt; \"198\", 2010 -&gt; \"201\"\n        decade_temps = season_temps.select(cs.contains(match)).mean_horizontal()\n        ax.plot(season_temps_index, decade_temps, color=color, linewidth=1)\n\n        # add label to right of line\n        last_y_label = decade_temps.last()\n\n        if decade == 2000:\n            last_y_label -= 3\n        elif decade == 2010:\n            last_y_label -= 0.3\n\n        ax.text(\n            185,\n            last_y_label,\n            f\"{decade}\",\n            va=\"center\",\n            ha=\"left\",\n            fontsize=axis_fontsize,\n            fontweight=axis_fontweight,\n            color=color,\n        )\n        # # add dot to start and end of each line\n        ax.plot(\n            season_temps_index.first(),\n            decade_temps.first(),\n            marker=\"o\",\n            color=color,\n            markersize=1,\n            zorder=2,\n        )\n        ax.plot(\n            season_temps_index.last(),\n            decade_temps.last(),\n            marker=\"o\",\n            color=color,\n            markersize=1,\n            zorder=2,\n        )\n\n    # # ------ Ski 2019 ------\n    # # plot `Ski 2019` in red\n    ski_2019 = season_temps.select(idx_colname, cs.by_name(\"Ski 2019\")).drop_nulls()\n    ski_2019_index = ski_2019[idx_colname]\n    ski_2019 = ski_2019.drop([idx_colname]).to_series()\n    ax.plot(ski_2019_index, ski_2019, color=\"red\", linewidth=1)\n\n    # add dot to start and end of each line\n    ax.plot(\n        ski_2019_index.first(),\n        ski_2019.first(),\n        marker=\"o\",\n        color=\"red\",\n        markersize=2,\n        zorder=2,\n    )\n    ax.plot(\n        ski_2019_index.last(),\n        ski_2019.last(),\n        marker=\"o\",\n        color=\"red\",\n        markersize=2,\n        zorder=2,\n    )\n\n    # # ------ Ticks & Lines ------\n    # # remove spines\n    for side in [\"top\", \"left\", \"right\"]:\n        ax.spines[side].set_visible(False)\n\n    # # add horizontal line at 32F\n    ax.axhline(32, color=\"black\", linestyle=\"--\", linewidth=1, zorder=1)\n\n    # # set y ticks\n    ax.set_yticks(ticks=[10, 32, 40])\n\n    # # set y limit\n    ax.set_ylim([10, 55])\n\n    # # set x label\n    ax.set_xlabel(\"Day of season\", fontsize=axis_fontsize, fontweight=axis_fontweight)\n\n    # # ------ Source ------\n    ax_notes = axs[\"notes\"]\n    # add source\n    ax_notes.axis(\"off\")\n    ax_notes.text(\n        0,\n        0,\n        \"Source: NOAA\",\n        fontsize=source_fontsize,\n        fontweight=source_fontweight,\n        color=grey,\n    )\n    return df_\n\n\nidx_colname = \"DAY_OF_SEASON\"\n\ndata = (\n    df.with_columns(\n        pl.col(\"DATE\").str.to_datetime(),\n        pl.col(\"TOBS\").interpolate(),\n    )\n    .sort(\"DATE\")\n    .with_columns(\n        # Caveat: Cannot be placed in the previous `with_columns()`\n        # due to different statuses of `TOBS`.\n        pl.col(\"TOBS\").rolling_mean(window_size=28, center=True).alias(\"TMEAN\"),\n        get_season_expr(col=\"DATE\", alias=\"SEASON\"),\n    )\n    .with_columns(\n        add_day_of_season_expr(col=\"DATE\", group_col=\"SEASON\", alias=idx_colname)\n    )\n    .pipe(partial(plot_temps, idx_colname=idx_colname))\n)"
  },
  {
    "objectID": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#loading-the-data",
    "href": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#loading-the-data",
    "title": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib",
    "section": "Loading the Data",
    "text": "Loading the Data\nTo begin, we load the dataset, focusing on two key columns:\n\nDATE: The dates.\nTOBS: The recorded temperature in Fahrenheit.\n\n\nfrom functools import partial\n\nimport matplotlib.pyplot as plt\nimport polars as pl\nimport polars.selectors as cs\nfrom highlight_text import ax_text\nfrom matplotlib import colormaps\n\ndata_path = \"alta-noaa-1980-2019.csv\"\ncolumns = [\"DATE\", \"TOBS\"]\ndf = pl.scan_csv(data_path).select(columns).collect()\nprint(df.head())\n\nshape: (5, 2)\n┌────────────┬──────┐\n│ DATE       ┆ TOBS │\n│ ---        ┆ ---  │\n│ str        ┆ i64  │\n╞════════════╪══════╡\n│ 1980-01-01 ┆ 25   │\n│ 1980-01-02 ┆ 18   │\n│ 1980-01-03 ┆ 18   │\n│ 1980-01-04 ┆ 27   │\n│ 1980-01-05 ┆ 34   │\n└────────────┴──────┘"
  },
  {
    "objectID": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#data-processing-pipeline",
    "href": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#data-processing-pipeline",
    "title": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib",
    "section": "Data Processing Pipeline",
    "text": "Data Processing Pipeline\nHere’s the pipeline for generating the final figure:\nidx_colname = \"DAY_OF_SEASON\"\n\ndata = (\n    df.with_columns(\n1        pl.col(\"DATE\").str.to_datetime(),\n2        pl.col(\"TOBS\").interpolate(),\n    )\n    .sort(\"DATE\")\n    .with_columns(\n        # Caveat: Cannot be placed in the previous `with_columns()`\n        # due to different statuses of `TOBS`.\n3        pl.col(\"TOBS\").rolling_mean(window_size=28, center=True).alias(\"TMEAN\"),\n4        get_season_expr(col=\"DATE\", alias=\"SEASON\"),\n    )\n    .with_columns(\n5        add_day_of_season_expr(col=\"DATE\", group_col=\"SEASON\", alias=idx_colname)\n    ) \n6    .pipe(partial(plot_temps, idx_colname=idx_colname))\n)\n\n1\n\nConvert the DATE column to a datetime format.\n\n\n2\n\nPerform interpolation on the TOBS column.\n\n\n3\n\nCompute a 28-day rolling average for TOBS.\n\n\n4\n\nUse get_season_expr() to categorize each date into a SEASON.\n\n\n5\n\nApply add_day_of_season_expr() to calculate DAY_OF_SEASON, representing days elapsed since the start of the season.\n\n\n6\n\nUse plot_temps() to generate the final visualization with Matplotlib.\n\n\nThe first three steps involve straightforward Polars expressions. In the following sections, we’ll dive deeper into steps 4 to 6."
  },
  {
    "objectID": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#categorizing-dates-into-summer-and-ski-seasons",
    "href": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#categorizing-dates-into-summer-and-ski-seasons",
    "title": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib",
    "section": "Categorizing Dates into Summer and Ski Seasons",
    "text": "Categorizing Dates into Summer and Ski Seasons\nTo analyze seasonal trends, we classify dates into two categories:\n\nSummer: Covers May through October.\n\nSki: Covers November through April.\n\nIf a date falls in November or December, it is assigned to the following year’s season. For example, 2015-10-31 is categorized as Summer 2015, while 2015-11-01 belongs to Ski 2016.\nTo implement this logic, we define get_season_expr(), which leverages Polars’ when-then-otherwise expressions to determine the season and year.\ndef get_season_expr(col: str = \"DATE\", alias: str = \"SEASON\") -&gt; pl.expr:\n    return (\n        (\n            pl.when((pl.col(col).dt.month().is_between(5, 10, closed=\"both\")))\n            .then(pl.lit(\"Summer \"))\n            .otherwise(pl.lit(\"Ski \"))\n        )\n        .add(\n            pl.when(pl.col(col).dt.month() &lt; 11)\n            .then(pl.col(col).dt.year().cast(pl.String))\n            .otherwise(pl.col(col).dt.year().add(1).cast(pl.String))\n        )\n        .alias(alias)\n    )\nIn this function:\n\nIf the month is between May and October, the function assigns \"Summer \". Otherwise, it assigns \"Ski \" (with a trailing space for concatenation).\n\nThe year is determined based on the month: dates from January to October retain their current year, while those in November and December are shifted to the next year.\n\nBy applying this function, we can add a SEASON column to a Polars DataFrame, ensuring each date is categorized correctly."
  },
  {
    "objectID": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#calculating-the-total-days-for-each-season",
    "href": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#calculating-the-total-days-for-each-season",
    "title": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib",
    "section": "Calculating the Total Days for Each Season",
    "text": "Calculating the Total Days for Each Season\nOnce we have the seasonal categories, we calculate DAY_OF_SEASON, which tracks the number of days elapsed within each season. This is achieved using the pl.expr.over() expression, which operates similarly to Pandas’ groupby().transform(), applying transformations within groups.\ndef add_day_of_season_expr(\n    col: str = \"DATE\", group_col: str = \"SEASON\", alias: str = \"DAY_OF_SEASON\"\n) -&gt; pl.expr:\n    return (\n        (pl.col(col) - pl.col(col).min()).dt.total_days().over(group_col).alias(alias)\n    )"
  },
  {
    "objectID": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#visualizing-temperature-trends-with-matplotlib",
    "href": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#visualizing-temperature-trends-with-matplotlib",
    "title": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib",
    "section": "Visualizing Temperature Trends with Matplotlib",
    "text": "Visualizing Temperature Trends with Matplotlib\nWith the data prepared, we move on to plotting. Since plot_temps() is quite long, we’ll break it down into several parts for easier explanation\n\nSetting Up the Figure\nWe start by defining some parameters and using plt.subplot_mosaic() to create the figure layout. This provides structured axes for different elements of the visualization.\ndef plot_temps(df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\") -&gt; pl.DataFrame:\n    plt.rcParams[\"font.family\"] = \"Roboto\"\n    figsize = (160, 165)  # pts\n\n    def points_to_inches(points):\n        return points / 72\n\n    figsize_inches = [points_to_inches(dim) for dim in figsize]\n\n    heading_fontsize = 9.5\n    heading_fontweight = \"bold\"\n    subheading_fontsize = 8\n    subheading_fontweight = \"normal\"\n    source_fontsize = 6.5\n    source_fontweight = \"light\"\n    axis_fontsize = 7\n    axis_fontweight = \"normal\"\n\n    grey = \"#aaaaaa\"\n    red = \"#e3120b\"\n    blue = \"#0000ff\"\n    cmap = colormaps.get_cmap(\"Grays\")\n\n    layout = [[\"title\"], [\"plot\"], [\"notes\"]]\n    fig, axs = plt.subplot_mosaic(\n        layout,\n        gridspec_kw={\"height_ratios\": [6, 12, 1]},\n        figsize=figsize_inches,\n        dpi=300,\n        constrained_layout=True,\n    )\n    ...\n    \n\n\nAdding the Title\nFor the title, we use ax_text() from the HighlightText library, which allows selective styling of text enclosed in &lt; &gt;. This lets us highlight key parts of the title, such as &lt;Alta Ski Resort&gt;, &lt;Temperature trends by &gt;, &lt;decade&gt;, &lt; and &gt;, and &lt;2019&gt;, with custom formatting.\ndef plot_temps(\n    df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    ...\n\n    # ----- Title -----\n    ax_title = axs[\"title\"]\n    ax_title.axis(\"off\")\n    sub_props = {\"fontsize\": subheading_fontsize, \"fontweight\": subheading_fontweight}\n    ax_text(\n        s=\"&lt;Alta Ski Resort&gt;\\n&lt;Temperature trends by &gt;\\n&lt;decade&gt;&lt; and &gt;&lt;2019&gt;\",\n        x=0,\n        y=0,\n        fontsize=heading_fontsize,\n        ax=ax_title,\n        va=\"bottom\",\n        ha=\"left\",\n        zorder=5,\n        highlight_textprops=[\n            {\"fontsize\": heading_fontsize, \"fontweight\": heading_fontweight},\n            sub_props,\n            {\"color\": blue, **sub_props},\n            sub_props,\n            {\"color\": red, **sub_props},\n        ],\n    )\n\n\nPlotting Seasonal Trends\nNext, we generate the main plot by:\n\nFiltering the dataset for Ski seasons.\n\nPivoting the table to organize TMEAN values by DAY_OF_SEASON and SEASON.\n\nUsing ax.plot() to draw a separate line for each Ski season.\n\ndef plot_temps(\n    df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    ...\n\n    # ----- Plot -----\n    ax = axs[\"plot\"]\n    season_temps = df_.filter(pl.col(\"SEASON\").str.contains(\"Ski\")).pivot(\n        \"SEASON\", index=idx_colname, values=\"TMEAN\", aggregate_function=\"first\"\n    )\n    season_temps_index = season_temps[idx_colname]\n\n    columns = season_temps.columns\n    columns.remove(idx_colname)\n    columns.remove(\"Ski 2019\")\n    for i, column in enumerate(columns):\n        color = cmap(i / len(columns))\n        ax.plot(\n            season_temps_index,\n            season_temps[column],\n            color=color,\n            linewidth=1,\n            alpha=0.2,\n            zorder=1,\n        )\nTo illustrate long-term trends, we overlay four lines representing the average temperature trends for different decades, marking their start and end points with dots for emphasis.\ndef plot_temps(\n    df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    ...\n\n    # # ---- Decade Averages ----\n    decades = [1980, 1990, 2000, 2010]\n    blues = [\"#0055EE\", \"#0033CC\", \"#0011AA\", \"#3377FF\"]\n    for decade, color in zip(decades, blues):\n        match = str(decade)[:-1] # 1980 -&gt; \"198\", 2010 -&gt; \"201\"\n1        decade_temps = season_temps.select(cs.contains(match)).mean_horizontal()\n        ax.plot(season_temps_index, decade_temps, color=color, linewidth=1)\n\n        # add label to right of line\n        last_y_label = decade_temps.last()\n\n        if decade == 2000:\n            last_y_label -= 3\n        elif decade == 2010:\n            last_y_label -= 0.3\n\n        ax.text(\n            185,\n            last_y_label,\n            f\"{decade}\",\n            va=\"center\",\n            ha=\"left\",\n            fontsize=axis_fontsize,\n            fontweight=axis_fontweight,\n            color=color,\n        )\n        # # add dot to start and end of each line\n        ax.plot(\n            season_temps_index.first(),\n            decade_temps.first(),\n            marker=\"o\",\n            color=color,\n            markersize=1,\n            zorder=2,\n        )\n        ax.plot(\n            season_temps_index.last(),\n            decade_temps.last(),\n            marker=\"o\",\n            color=color,\n            markersize=1,\n            zorder=2,\n        )\n\n1\n\nWe leverage two powerful features of Polars: Polars selectors, which enable efficient column selection based on name patterns to extract data for each decade (cs.contains(match)), and df.mean_horizontal(), which performs vectorized operations across columns to compute the average temperature for each decade.\n\n\n\n\nHighlighting the 2019 Ski Season\nTo make Ski 2019 stand out, we plot its trend in red and highlight its start and end points with dots, similar to the decade lines.\ndef plot_temps(\n    df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    ...\n\n    # # ------ Ski 2019 ------\n    # # plot `Ski 2019` in red\n1    ski_2019 = season_temps.select(idx_colname, cs.by_name(\"Ski 2019\")).drop_nulls()\n    ski_2019_index = ski_2019[idx_colname]\n    ski_2019 = ski_2019.drop([idx_colname]).to_series()\n    ax.plot(ski_2019_index, ski_2019, color=\"red\", linewidth=1)\n\n    # add dot to start and end of each line\n    ax.plot(\n        ski_2019_index.first(),\n        ski_2019.first(),\n        marker=\"o\",\n        color=\"red\",\n        markersize=2,\n        zorder=2,\n    )\n    ax.plot(\n        ski_2019_index.last(),\n        ski_2019.last(),\n        marker=\"o\",\n        color=\"red\",\n        markersize=2,\n        zorder=2,\n    )\n\n1\n\nWe use the Polars selector (cs.by_name()) to isolate the Ski 2019 data.\n\n\n\n\nRefinements for Clarity\nTo enhance readability, we refine the visualization by adjusting:\n\nSpines: Removing unnecessary borders.\n\nReference Line: Adding a horizontal dashed line at 32°F for context.\n\nTicks & Limits: Setting appropriate y-axis ticks and limits.\n\nLabels: Customizing the x-axis label for clarity.\n\ndef plot_temps(\n    df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    ...\n\n    # # ------ Ticks & Lines ------\n    # # remove spines\n    for side in [\"top\", \"left\", \"right\"]:\n        ax.spines[side].set_visible(False)\n\n    # # add horizontal line at 32F\n    ax.axhline(32, color=\"black\", linestyle=\"--\", linewidth=1, zorder=1)\n\n    # # set y ticks\n    ax.set_yticks(ticks=[10, 32, 40])\n\n    # # set y limit\n    ax.set_ylim([10, 55])\n\n    # # set x label\n    ax.set_xlabel(\"Day of season\", fontsize=axis_fontsize, fontweight=axis_fontweight)\n\n\nAdding Notes\nFinally, we use Matplotlib’s ax.text() to annotate the source of the data.\ndef plot_temps(\n    df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    ...\n\n    # # ------ Source ------\n    ax_notes = axs[\"notes\"]\n    # add source\n    ax_notes.axis(\"off\")\n    ax_notes.text(\n        0,\n        0,\n        \"Source: NOAA\",\n        fontsize=source_fontsize,\n        fontweight=source_fontweight,\n        color=grey,\n    )\n    return df_"
  },
  {
    "objectID": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#wrapping-up",
    "href": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#wrapping-up",
    "title": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib",
    "section": "Wrapping Up",
    "text": "Wrapping Up\nRecreating this figure with Polars turned out to be more involved than I initially expected. However, the process was incredibly rewarding, as it deepened my understanding of Pandas, Polars, and Matplotlib. Switching between Pandas and Polars required a shift in mindset, but it also reinforced key concepts in both libraries. I look forward to exploring more of these challenges in the future.\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Posts",
    "section": "",
    "text": "Weekend Challenge – Recreating a Data Visualization with Polars and Plotnine\n\n\n\n\n\n\npython\n\n\npolars\n\n\nmatplotlib\n\n\nplotnine\n\n\n\n\n\n\n\n\n\nApr 12, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nHow to Access the Axes in Plotnine\n\n\n\n\n\n\npython\n\n\nmatplotlib\n\n\nplotnine\n\n\n\n\n\n\n\n\n\nApr 11, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nClone the Reciprocal Tariffs Table Using Great Tables\n\n\n\n\n\n\npython\n\n\npolars\n\n\ngt\n\n\n\n\n\n\n\n\n\nApr 3, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nApplying Custom Color Palettes to the Table Body in Great Tables\n\n\n\n\n\n\npython\n\n\npandas\n\n\npolars\n\n\ngt\n\n\n\n\n\n\n\n\n\nFeb 25, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nWeekend Challenge - Effective Data Visualization with Polars and Matplotlib\n\n\n\n\n\n\npython\n\n\npandas\n\n\npolars\n\n\nmatplotlib\n\n\n\n\n\n\n\n\n\nFeb 10, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nThree Approaches to Styling the Table Body in Great Tables\n\n\n\n\n\n\npython\n\n\npolars\n\n\ngt\n\n\n\n\n\n\n\n\n\nJan 24, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nExploring Resend SMTP Service with Django\n\n\n\n\n\n\npython\n\n\ndjango\n\n\nresend\n\n\n\n\n\n\n\n\n\nDec 23, 2024\n\n\nJerry Wu\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/p9-polars-alta-ski-resort/20250412.html",
    "href": "posts/p9-polars-alta-ski-resort/20250412.html",
    "title": "Weekend Challenge – Recreating a Data Visualization with Polars and Plotnine",
    "section": "",
    "text": "This post is a placeholder for a visualization recreation challenge using Polars and plotnine, inspired by my previous work.\nIt’s my first serious attempt at using plotnine—an impressive library, but one with a bit of a learning curve. After a few hours of tinkering, I’m still wrapping my head around the best ways to leverage it effectively. The plot itself could definitely be improved with more refinement and insight.\nFor now, I’m giving myself a break. I’ll just park the current code here and revisit the full write-up once my thoughts are clearer and ideas more distilled.\n\n\n\n\n\n\n\nShow full code\nfrom functools import partial\n\nimport polars as pl\nimport polars.selectors as cs\nfrom highlight_text import ax_text\nfrom plotnine import (\n    aes,\n    element_blank,\n    element_text,\n    geom_segment,\n    geom_line,\n    geom_text,\n    ggplot,\n    labs,\n    scale_color_cmap,\n    scale_x_continuous,\n    scale_y_continuous,\n    theme,\n    theme_classic,\n)\n\n\nheading_fontsize = 9.5\nheading_fontweight = \"bold\"\nsubheading_fontsize = 8\nsubheading_fontweight = \"normal\"\nsource_fontsize = 6.5\nsource_fontweight = \"light\"\naxis_fontsize = 7\naxis_fontweight = \"normal\"\n\ngrey = \"#aaaaaa\"\nred = \"#e3120b\"\nblue = \"#0000ff\"\n\n# https://github.com/mattharrison/datasets/raw/refs/heads/master/data/alta-noaa-1980-2019.csv\ndata_path = \"alta-noaa-1980-2019.csv\"\ncolumns = [\"DATE\", \"TOBS\"]\ndf = pl.scan_csv(data_path).select(columns).collect()\n\n\ndef get_season_expr(col: str = \"DATE\", alias: str = \"SEASON\") -&gt; pl.expr:\n    return (\n        (\n            pl.when((pl.col(col).dt.month().is_between(5, 10, closed=\"both\")))\n            .then(pl.lit(\"Summer \"))\n            .otherwise(pl.lit(\"Ski \"))\n        )\n        .add(\n            pl.when(pl.col(col).dt.month() &lt; 11)\n            .then(pl.col(col).dt.year().cast(pl.String))\n            .otherwise(pl.col(col).dt.year().add(1).cast(pl.String))\n        )\n        .alias(alias)\n    )\n\n\ndef add_day_of_season_expr(\n    col: str = \"DATE\", group_col: str = \"SEASON\", alias: str = \"DAY_OF_SEASON\"\n) -&gt; pl.expr:\n    return (\n        (pl.col(col) - pl.col(col).min()).dt.total_days().over(group_col).alias(alias)\n    )\n\n\ndef plot_temps_p9(\n    df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    season_temps = df_.filter(pl.col(\"SEASON\").str.contains(\"Ski\")).pivot(\n        \"SEASON\", index=idx_colname, values=\"TMEAN\", aggregate_function=\"first\"\n    )\n\n    columns = season_temps.columns\n    columns.remove(idx_colname)\n    columns.remove(\"Ski 2019\")\n\n    df0 = season_temps.unpivot(\n        (cs.starts_with(\"Ski\") - cs.by_name(\"Ski 2019\")),\n        index=idx_colname,\n        variable_name=\"year\",\n        value_name=\"temp\",\n    ).select(idx_colname, \"temp\", pl.col(\"year\").str.slice(-4).cast(pl.Int32))\n\n    # # ---- Decade Averages ----\n    decades = [1980, 1990, 2000, 2010]\n    blues = [\"#0055EE\", \"#0033CC\", \"#0011AA\", \"#3377FF\"]\n\n    df_decades = [\n        pl.concat(\n            [\n                season_temps.select(idx_colname),\n                season_temps.with_columns(\n                    pl.mean_horizontal(cs.contains(str(decade)[:-1])).alias(\"temp\")\n                ).select(\"temp\"),\n                season_temps.with_columns(\n                    pl.lit(int(str(decade)[:-1])).alias(\"DECADE\")\n                ).select(\n                    \"DECADE\",\n                ),\n                season_temps.with_columns(pl.lit(b).alias(\"color\")).select(\n                    \"color\",\n                ),\n            ],\n            how=\"horizontal\",\n        )\n        for b, decade in zip(blues, decades)\n    ]\n\n    df0_decade = pl.concat(df_decades, how=\"vertical\")\n\n    max_ys = [one_df.select(pl.col(\"temp\").max()).item() for one_df in df_decades]\n    max_ys_df = pl.DataFrame(\n        {\n            \"x\": [192] * len(max_ys),\n            \"y\": [max_ys[0] - 1, max_ys[1], max_ys[2] - 0.5, max_ys[3] + 1],\n            \"color\": blues,\n            \"label\": decades,\n        }\n    )\n\n    ski_2019 = (\n        season_temps.select(idx_colname, pl.col(\"Ski 2019\").alias(\"temp\"))\n        # .drop_nulls()\n        .with_columns(pl.lit(2019).alias(\"year\"))\n    )\n\n    fig = (\n        ggplot()\n        + geom_line(\n            df0, aes(x=idx_colname, y=\"temp\", color=\"factor(year)\"), alpha=0.2, size=1\n        )\n        + scale_color_cmap(\"Greys\", guide=None, labels=[10, 32, 50])\n        + geom_line(\n            data=df0_decade,\n            mapping=aes(x=idx_colname, y=\"temp\", fill=\"factor(DECADE)\"),\n            color=df0_decade[\"color\"],\n            size=1,\n        )\n        + geom_line(\n            data=ski_2019, mapping=aes(x=idx_colname, y=\"temp\"), color=red, size=1\n        )\n        + geom_segment(\n            aes(x=0, xend=183, y=32, yend=32),\n            color=\"black\",\n            size=1,\n            linetype=\"dashed\",\n        )\n        + labs(x=\"Day of season\", y=\"\")\n        + scale_x_continuous(\n            breaks=[0, 50, 100, 150], limits=(0, 200), expand=(0, 10, 0, 5)\n        )\n        + scale_y_continuous(breaks=[10, 32, 40], limits=(10, 55), expand=(0, 0))\n        + geom_text(\n            data=max_ys_df,\n            mapping=aes(x=\"x\", y=\"y\", label=\"label\"),\n            color=max_ys_df[\"color\"],\n            size=16,\n            ha=\"center\",\n        )\n        + theme_classic()\n        + theme(\n            axis_line_y=element_blank(),\n            axis_text_x=element_text(weight=\"bold\"),\n            axis_text_y=element_text(weight=\"bold\"),\n        )\n    ).draw(show=False)\n\n    return fig\n\nidx_colname = \"DAY_OF_SEASON\"\n\nfig = (\n    df.with_columns(\n        pl.col(\"DATE\").str.to_datetime(),\n        pl.col(\"TOBS\").interpolate(),\n    )\n    .sort(\"DATE\")\n    .with_columns(\n        # Caveat: Cannot be placed in the previous `with_columns()`\n        # due to different statuses of `TOBS`.\n        pl.col(\"TOBS\").rolling_mean(window_size=28, center=True).alias(\"TMEAN\"),\n        get_season_expr(col=\"DATE\", alias=\"SEASON\"),\n    )\n    .with_columns(\n        add_day_of_season_expr(col=\"DATE\", group_col=\"SEASON\", alias=idx_colname)\n    )\n    .pipe(partial(plot_temps_p9, idx_colname=idx_colname))\n)\n\n\nfig.set_size_inches(6, 5, forward=True)\nfig.set_dpi(300)\nax = fig.axes[0]\n\nsub_props = {\"fontsize\": subheading_fontsize, \"fontweight\": subheading_fontweight}\n\nax_text(\n    s=\"&lt;Alta Ski Resort&gt;\\n&lt;Temperature trends by &gt;\\n&lt;decade&gt;&lt; and &gt;&lt;2019&gt;\",\n    x=-5,\n    y=52,\n    fontsize=heading_fontsize,\n    ax=ax,\n    va=\"bottom\",\n    ha=\"left\",\n    zorder=5,\n    highlight_textprops=[\n        {\"fontsize\": heading_fontsize, \"fontweight\": heading_fontweight},\n        sub_props,\n        {\"color\": blue, **sub_props},\n        sub_props,\n        {\"color\": red, **sub_props},\n    ],\n)\n\nax.text(\n    0,\n    5,\n    \"Source: NOAA\",\n    fontsize=source_fontsize,\n    fontweight=source_fontweight,\n    color=grey,\n)\n\nfig\n\n\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/access-axes-in-plotnine/20250411.html",
    "href": "posts/access-axes-in-plotnine/20250411.html",
    "title": "How to Access the Axes in Plotnine",
    "section": "",
    "text": "This is a short post documenting my experience trying to retrieve the Axes from plotnine.\nThe idea was inspired by this code and this video I came across, but the original solution didn’t quite work for me. Fortunately, I found that we can access the list of Axes directly using either fig.axes or fig.get_axes().\nIn the example below, I adapt a snippet from the plotnine documentation to demonstrate how to highlight text in color using HighlightText.\n\n\n\n\n\n\nimport highlight_text as ht\nfrom plotnine import aes, geom_point, ggplot, labs, theme_matplotlib, theme_set\nfrom plotnine.data import mpg\n\ntheme_set(theme_matplotlib())\n\np = (\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\nfig = p.draw()\nax = fig.axes[0]  # or via fig.get_axes()[0]\nht_ax_text = 'Color highlighted by &lt;HighlightText::{\"color\": \"#E58606\"}&gt;'\nht.ax_text(4, 40, ht_ax_text, vsep=3, fontsize=9, va=\"top\", ax=ax)\nfig\n\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/style-table-body/20250124.html",
    "href": "posts/style-table-body/20250124.html",
    "title": "Three Approaches to Styling the Table Body in Great Tables",
    "section": "",
    "text": "This post demonstrates three approaches to styling the table body:\nLet’s dive in."
  },
  {
    "objectID": "posts/style-table-body/20250124.html#preparations",
    "href": "posts/style-table-body/20250124.html#preparations",
    "title": "Three Approaches to Styling the Table Body in Great Tables",
    "section": "Preparations",
    "text": "Preparations\nWe’ll use the built-in dataset gtcars to create a Polars DataFrame. First, we’ll select the columns mfr, drivetrain, year, and hp to create a small pivoted table named df_mini. Then, we’ll pass df_mini to the GT object and use GT.tab_stub(), setting drivetrain as rowname_col= and mfr as groupname_col= to create the table gt, as shown below:\n\n\nCode\nimport polars as pl\nfrom great_tables import GT, loc, style\nfrom great_tables.data import gtcars\nfrom polars import selectors as cs\n\nyear_cols = [\"2014\", \"2015\", \"2016\", \"2017\"]\ndf_mini = (\n    pl.from_pandas(gtcars)\n    .filter(pl.col(\"mfr\").is_in([\"Ferrari\", \"Lamborghini\", \"BMW\"]))\n    .sort(\"drivetrain\")\n    .pivot(on=\"year\", index=[\"mfr\", \"drivetrain\"], values=\"hp\", aggregate_function=\"mean\")\n    .select([\"mfr\", \"drivetrain\", *year_cols])\n)\n\ngt = GT(df_mini).tab_stub(rowname_col=\"drivetrain\", groupname_col=\"mfr\").opt_stylize()\ngt\n\n\n\n\n\n\n\n\n  \n  2014\n  2015\n  2016\n  2017\n\n\n\n  \n    Ferrari\n  \n  \n    awd\n    None\n    652.0\n    None\n    680.0\n  \n  \n    rwd\n    562.0\n    678.4\n    661.0\n    None\n  \n  \n    Lamborghini\n  \n  \n    awd\n    None\n    700.0\n    None\n    None\n  \n  \n    rwd\n    550.0\n    610.0\n    None\n    None\n  \n  \n    BMW\n  \n  \n    awd\n    None\n    None\n    357.0\n    None\n  \n  \n    rwd\n    None\n    None\n    465.0\n    None\n  \n\n\n\n\n\n\n        \n\n\nThe numbers in the cells represent the average horsepower for each combination of mfr and drivetrain for a specific year.\nIn the following section, we’ll demonstrate three different ways to highlight the cell text in red if the average horsepower exceeds 650."
  },
  {
    "objectID": "posts/style-table-body/20250124.html#using-a-for-loop-repeatedly-call-gt.tab_style-for-each-column",
    "href": "posts/style-table-body/20250124.html#using-a-for-loop-repeatedly-call-gt.tab_style-for-each-column",
    "title": "Three Approaches to Styling the Table Body in Great Tables",
    "section": "Using a For-Loop: Repeatedly Call GT.tab_style() for Each Column",
    "text": "Using a For-Loop: Repeatedly Call GT.tab_style() for Each Column\nThe most intuitive way is to call GT.tab_style() for each column. Here’s how:\n\n1gt1 = gt\nfor col in year_cols:\n    gt1 = gt1.tab_style(\n        style=style.text(color=\"red\"),\n        locations=loc.body(columns=col, rows=pl.col(col).gt(650))\n    )\ngt1\n\n\n1\n\nSince we want to keep gt intact for later use, we will modify gt1 in this approach instead.\n\n\n\n\n\n\n\n\n\n\n  \n  2014\n  2015\n  2016\n  2017\n\n\n\n  \n    Ferrari\n  \n  \n    awd\n    None\n    652.0\n    None\n    680.0\n  \n  \n    rwd\n    562.0\n    678.4\n    661.0\n    None\n  \n  \n    Lamborghini\n  \n  \n    awd\n    None\n    700.0\n    None\n    None\n  \n  \n    rwd\n    550.0\n    610.0\n    None\n    None\n  \n  \n    BMW\n  \n  \n    awd\n    None\n    None\n    357.0\n    None\n  \n  \n    rwd\n    None\n    None\n    465.0\n    None"
  },
  {
    "objectID": "posts/style-table-body/20250124.html#utilizing-the-locations-parameter-in-gt.tab_style-pass-a-list-of-loc.body-objects",
    "href": "posts/style-table-body/20250124.html#utilizing-the-locations-parameter-in-gt.tab_style-pass-a-list-of-loc.body-objects",
    "title": "Three Approaches to Styling the Table Body in Great Tables",
    "section": "Utilizing the locations= Parameter in GT.tab_style(): Pass a List of loc.body() Objects",
    "text": "Utilizing the locations= Parameter in GT.tab_style(): Pass a List of loc.body() Objects\nA more concise method is to pass a list of loc.body() objects to the locations= parameter in GT.tab_style(), as shown below:\n\n(\n    gt.tab_style(\n        style=style.text(color=\"red\"),\n        locations=[\n            loc.body(columns=col, rows=pl.col(col).gt(650))\n            for col in year_cols\n        ],\n    )\n)\n\n\n\n\n\n\n\n  \n  2014\n  2015\n  2016\n  2017\n\n\n\n  \n    Ferrari\n  \n  \n    awd\n    None\n    652.0\n    None\n    680.0\n  \n  \n    rwd\n    562.0\n    678.4\n    661.0\n    None\n  \n  \n    Lamborghini\n  \n  \n    awd\n    None\n    700.0\n    None\n    None\n  \n  \n    rwd\n    550.0\n    610.0\n    None\n    None\n  \n  \n    BMW\n  \n  \n    awd\n    None\n    None\n    357.0\n    None\n  \n  \n    rwd\n    None\n    None\n    465.0\n    None"
  },
  {
    "objectID": "posts/style-table-body/20250124.html#leveraging-the-mask-parameter-in-loc.body-use-polars-expressions-for-streamlined-styling",
    "href": "posts/style-table-body/20250124.html#leveraging-the-mask-parameter-in-loc.body-use-polars-expressions-for-streamlined-styling",
    "title": "Three Approaches to Styling the Table Body in Great Tables",
    "section": "Leveraging the mask= Parameter in loc.body(): Use Polars Expressions for Streamlined Styling",
    "text": "Leveraging the mask= Parameter in loc.body(): Use Polars Expressions for Streamlined Styling\nThe most modern approach (0.16.0) is to pass a Polars expression to the mask= parameter in loc.body(), as illustrated here:\n\n(\n    gt.tab_style(\n        style=style.text(color=\"red\"),\n        locations=loc.body(mask=cs.numeric().gt(650))\n    )\n)\n\n\n\n\n\n\n\n  \n  2014\n  2015\n  2016\n  2017\n\n\n\n  \n    Ferrari\n  \n  \n    awd\n    None\n    652.0\n    None\n    680.0\n  \n  \n    rwd\n    562.0\n    678.4\n    661.0\n    None\n  \n  \n    Lamborghini\n  \n  \n    awd\n    None\n    700.0\n    None\n    None\n  \n  \n    rwd\n    550.0\n    610.0\n    None\n    None\n  \n  \n    BMW\n  \n  \n    awd\n    None\n    None\n    357.0\n    None\n  \n  \n    rwd\n    None\n    None\n    465.0\n    None\n  \n\n\n\n\n\n\n        \n\n\nIn this example, loc.body() is smart enough to automatically target the rows where the cell value exceeds 650 for each numerical column. In general, you can think of mask= as a syntactic sugar that Great Tables provides to save you from having to manually loop through the columns."
  },
  {
    "objectID": "posts/style-table-body/20250124.html#final-words",
    "href": "posts/style-table-body/20250124.html#final-words",
    "title": "Three Approaches to Styling the Table Body in Great Tables",
    "section": "Final Words",
    "text": "Final Words\nThis post summarizes three approaches to styling the table body. Among them, the mask= parameter in loc.body() is definitely my favorite, inspired by #389 and implemented by me.\nSpecial thanks to @rich-iannone and @machow for their invaluable suggestions during development. Any remaining bugs are entirely on me.\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  }
]