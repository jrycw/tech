[
  {
    "objectID": "posts/casewhen-in-polars/20250525.html",
    "href": "posts/casewhen-in-polars/20250525.html",
    "title": "case_when() in Polars",
    "section": "",
    "text": "This is a follow-up to my previous post.\nWhile the conditional branching mechanism of pl.when().then().otherwise() is quite powerful, I often find it a bit verbose—especially when the conditions are complex. In those cases, it becomes harder to validate the correctness of each branch at a glance.\nOn the other hand, I find the pd.Series.case_when() pattern in Pandas slightly more concise and readable. However, I’ve always wished it supported a fallback mechanism like Polars’ .otherwise().\nIn the end, I thought it would be interesting to borrow the concept behind pd.Series.case_when() and implement it as a standalone utility function in Polars."
  },
  {
    "objectID": "posts/casewhen-in-polars/20250525.html#case_when",
    "href": "posts/casewhen-in-polars/20250525.html#case_when",
    "title": "case_when() in Polars",
    "section": "case_when()",
    "text": "case_when()\nThe case_when() function accepts two arguments:\n\ncaselist: A list of two-element tuples, where the first item is the condition (used in pl.when()), and the second is the corresponding result expression (used in .then()).\notherwise: A fallback expression used in .otherwise() if no conditions match.\n\nThe given example demonstrates how case_when() can simplify conditional logic compared to the more verbose pl.when().then().otherwise() chain.\n\nfrom functools import cache\nfrom typing import Any\n\nimport polars as pl\n\n\ndef case_when(\n    caselist: list[tuple[pl.Expr, pl.Expr]], otherwise: pl.Expr | None = None\n) -&gt; pl.Expr:\n    \"\"\"\n    Simplifies conditional logic in Polars by chaining multiple `when-then` expressions.\n\n    Parameters\n    ----------\n    caselist\n        A list of (condition, value) pairs. Each condition is evaluated in order,\n        and the corresponding value is returned when a condition is met.\n    otherwise\n        The fallback value to use if none of the conditions match.\n\n    Returns\n    -------\n    pl.Expr\n\n    Examples:\n    -------\n    ```python\n    import polars as pl\n\n    df = pl.DataFrame({\"x\": [1, 2, 3, 4]})\n\n    expr = case_when(\n        caselist=[\n            (pl.col(\"x\") &lt; 2, pl.lit(\"small\")),\n            (pl.col(\"x\") &lt; 4, pl.lit(\"medium\"))\n        ],\n        otherwise=pl.lit(\"large\"),\n    ).alias(\"size\")\n\n    # This is equivalent to writing:\n    # expr = (\n    #     pl.when(pl.col(\"x\") &lt; 2)\n    #       .then(pl.lit(\"small\"))\n    #       .when(pl.col(\"x\") &lt; 4)\n    #       .then(pl.lit(\"medium\"))\n    #       .otherwise(pl.lit(\"large\"))\n    #       .alias(\"size\")\n    # )\n\n    df.with_columns(expr)\n    ```\n    shape: (4, 2)\n    ┌─────┬────────┐\n    │ x   ┆ size   │\n    │ --- ┆ ---    │\n    │ i64 ┆ str    │\n    ├─────┼────────┤\n    │ 1   ┆ small  │\n    │ 2   ┆ medium │\n    │ 3   ┆ medium │\n    │ 4   ┆ large  │\n    └─────┴────────┘\n    \"\"\"\n    (first_when, first_then), *cases = caselist\n\n    # first\n    expr = pl.when(first_when).then(first_then)\n\n    # middles\n    for when, then in cases:\n        expr = expr.when(when).then(then)\n\n    # last\n    expr = expr.otherwise(otherwise)\n\n    return expr"
  },
  {
    "objectID": "posts/casewhen-in-polars/20250525.html#custom-expression-namespace",
    "href": "posts/casewhen-in-polars/20250525.html#custom-expression-namespace",
    "title": "case_when() in Polars",
    "section": "Custom Expression Namespace",
    "text": "Custom Expression Namespace\nWith case_when() in place, we can refactor the DiscreteSplitter expression namespace like this:\n\n@cache\ndef _mod_expr(n: int) -&gt; pl.Expr:\n    return pl.int_range(pl.len(), dtype=pl.UInt32).mod(n)\n\n\ndef _litify(lits: list[Any]) -&gt; list[pl.lit]:\n    return [pl.lit(lit) for lit in lits]\n\n\n@pl.api.register_expr_namespace(\"spt\")\nclass DiscreteSplitter:\n    def __init__(self, expr: pl.Expr) -&gt; None:\n        self._expr = expr\n\n    def _get_expr(self, lits: list[Any], name: str):\n        n = len(lits)\n        mod_expr = _mod_expr(n)\n        *litified, litified_otherwise = _litify(lits)\n        caselist = [(mod_expr.eq(i), lit) for i, lit in enumerate(litified)]\n        return case_when(caselist, litified_otherwise).alias(name)\n\n    def binarize(self, lit1: Any, lit2: Any, name: str = \"binarized\") -&gt; pl.Expr:\n        return self.bucketize([lit1, lit2], name)\n\n    def trinarize(\n        self, lit1: Any, lit2: Any, lit3: Any, name: str = \"trinarized\"\n    ) -&gt; pl.Expr:\n        return self.bucketize([lit1, lit2, lit3], name)\n\n    def bucketize(self, lits: list[Any], name: str = \"bucketized\") -&gt; pl.Expr:\n        return self._get_expr(lits, name)\n\nNow, bucketize() is the primary method that encapsulates the core logic for categorical mapping. binarize() and trinarize() are just convenient wrappers for common cases.\nHere’s a simple example of using the custom expression namespace:\ndf = (\n    pl.DataFrame({\"n\": [100, 50, 72, 83, 97, 42, 20, 51, 77]})\n    .with_row_index(offset=1)\n    .with_columns(\n        pl.col(\"\").spt.binarize(\"lightblue\", \"papayawhip\"),\n        pl.col(\"\").spt.trinarize(\"one\", \"two\", \"three\"),\n        pl.col(\"\").spt.bucketize([1, 2, 3, 4]),\n    )\n)\nshape: (9, 5)\n┌───────┬─────┬────────────┬────────────┬────────────┐\n│ index ┆ n   ┆ binarized  ┆ trinarized ┆ bucketized │\n│ ---   ┆ --- ┆ ---        ┆ ---        ┆ ---        │\n│ u32   ┆ i64 ┆ str        ┆ str        ┆ i32        │\n╞═══════╪═════╪════════════╪════════════╪════════════╡\n│ 1     ┆ 100 ┆ lightblue  ┆ one        ┆ 1          │\n│ 2     ┆ 50  ┆ papayawhip ┆ two        ┆ 2          │\n│ 3     ┆ 72  ┆ lightblue  ┆ three      ┆ 3          │\n│ 4     ┆ 83  ┆ papayawhip ┆ one        ┆ 4          │\n│ 5     ┆ 97  ┆ lightblue  ┆ two        ┆ 1          │\n│ 6     ┆ 42  ┆ papayawhip ┆ three      ┆ 2          │\n│ 7     ┆ 20  ┆ lightblue  ┆ one        ┆ 3          │\n│ 8     ┆ 51  ┆ papayawhip ┆ two        ┆ 4          │\n│ 9     ┆ 77  ┆ lightblue  ┆ three      ┆ 1          │\n└───────┴─────┴────────────┴────────────┴────────────┘"
  },
  {
    "objectID": "posts/casewhen-in-polars/20250525.html#custom-dataframe-namespace",
    "href": "posts/casewhen-in-polars/20250525.html#custom-dataframe-namespace",
    "title": "case_when() in Polars",
    "section": "Custom DataFrame Namespace",
    "text": "Custom DataFrame Namespace\nInstead of relying on pl.DataFrame.with_row_index(), we can also use _mod_expr() directly to enable similar categorization.\nHere’s how the DiscreteSplitter can be implemented as a custom DataFrame namespace:\n\n@pl.api.register_dataframe_namespace(\"spt\")\nclass DiscreteSplitter:\n    def __init__(self, df: pl.DataFrame) -&gt; None:\n        self._df = df\n\n    def _get_expr(self, lits: list[Any], name: str):\n        n = len(lits)\n        mod_expr = _mod_expr(n)\n        *litified, litified_otherwise = _litify(lits)\n        caselist = [(mod_expr.eq(i), lit) for i, lit in enumerate(litified)]\n        return case_when(caselist, litified_otherwise).alias(name)\n\n    def _get_final_df(self, lits: list[Any], name: str) -&gt; pl.DataFrame:\n        cls = type(self)\n        expr = self._get_expr(lits, name)\n        new_spt = cls(self._df.with_columns(expr))\n        return new_spt._df\n\n    def binarize(self, lit1: Any, lit2: Any, name: str = \"binarized\") -&gt; pl.DataFrame:\n        return self.bucketize([lit1, lit2], name=name)\n\n    def trinarize(\n        self, lit1: Any, lit2: Any, lit3: Any, name: str = \"trinarized\"\n    ) -&gt; pl.DataFrame:\n        return self.bucketize([lit1, lit2, lit3], name=name)\n\n    def bucketize(self, lits: list[Any], name: str = \"bucketized\") -&gt; pl.DataFrame:\n        return self._get_final_df(lits, name)\n\nExample usage:\ndf = (\n    pl.DataFrame({\"n\": [100, 50, 72, 83, 97, 42, 20, 51, 77]})\n    .spt.binarize(\"lightblue\", \"papayawhip\")\n    .spt.trinarize(\"one\", \"two\", \"three\")\n    .spt.bucketize([1, 2, 3, 4])\n    .with_row_index(offset=1)\n)\nshape: (9, 5)\n┌───────┬─────┬────────────┬────────────┬────────────┐\n│ index ┆ n   ┆ binarized  ┆ trinarized ┆ bucketized │\n│ ---   ┆ --- ┆ ---        ┆ ---        ┆ ---        │\n│ u32   ┆ i64 ┆ str        ┆ str        ┆ i32        │\n╞═══════╪═════╪════════════╪════════════╪════════════╡\n│ 1     ┆ 100 ┆ lightblue  ┆ one        ┆ 1          │\n│ 2     ┆ 50  ┆ papayawhip ┆ two        ┆ 2          │\n│ 3     ┆ 72  ┆ lightblue  ┆ three      ┆ 3          │\n│ 4     ┆ 83  ┆ papayawhip ┆ one        ┆ 4          │\n│ 5     ┆ 97  ┆ lightblue  ┆ two        ┆ 1          │\n│ 6     ┆ 42  ┆ papayawhip ┆ three      ┆ 2          │\n│ 7     ┆ 20  ┆ lightblue  ┆ one        ┆ 3          │\n│ 8     ┆ 51  ┆ papayawhip ┆ two        ┆ 4          │\n│ 9     ┆ 77  ┆ lightblue  ┆ three      ┆ 1          │\n└───────┴─────┴────────────┴────────────┴────────────┘"
  },
  {
    "objectID": "posts/casewhen-in-polars/20250525.html#conclusion",
    "href": "posts/casewhen-in-polars/20250525.html#conclusion",
    "title": "case_when() in Polars",
    "section": "Conclusion",
    "text": "Conclusion\nExtracting the conditional logic into a standalone case_when() function turned out to be both a practical and satisfying exercise—perfect for a rainy afternoon of coding. It not only improves readability but also makes the branching logic easier to reuse and reason about.\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/gt-row-selector/20250511.html",
    "href": "posts/gt-row-selector/20250511.html",
    "title": "Custom Row Selector in Great Tables",
    "section": "",
    "text": "This short post shows how we can create custom row selectors in Great Tables by leveraging the row index. While it may or may not be adopted by the team, I thought it would be fun to document it here on the blog.\nI recently created a utility called every_n_row(), designed to work with both Pandas and Polars DataFrames (support for pyarrow is still under investigation). With every_n_row(), we can easily target alternating rows—for example, select odd rows using every_n_row(2) and even rows using either every_n_row(2, 1) or ~every_n_row(2).\n\nimport polars as pl\n\nfrom great_tables import GT, every_n_row, loc, style\nfrom great_tables.data import countrypops\n\ndf_pd = countrypops.sample(5).loc[:, [\"country_name\", \"year\", \"population\"]]\ndf_pl = pl.from_pandas(df_pd)\n\n(\n    GT(df_pd)\n    .tab_style(style=style.fill(\"lightblue\"), locations=loc.body(rows=every_n_row(2)))\n    .tab_style(style=style.fill(\"papayawhip\"), locations=loc.body(rows=every_n_row(2, 1)))\n    .opt_stylize(style=3, color=\"pink\")\n)\n\n(\n    GT(df_pl)\n    .tab_style(style=style.fill(\"lightblue\"), locations=loc.body(rows=every_n_row(2)))\n    .tab_style(style=style.fill(\"papayawhip\"), locations=loc.body(rows=~every_n_row(2)))\n    .opt_stylize(style=3, color=\"pink\")\n)\n\n\n\n\n\n\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/clone-reciprocal-tariffs-table/20250403.html",
    "href": "posts/clone-reciprocal-tariffs-table/20250403.html",
    "title": "Clone the Reciprocal Tariffs Table Using Great Tables",
    "section": "",
    "text": "This post demonstrates how to clone the Reciprocal Tariffs table that President Donald Trump announced on April 2 on Truth Social.\nSince the code is largely self-explanatory, I will highlight some tricks and caveats I encountered while building the table:\n\nThe data dictionary was extracted with the help of AI.\nThe border radius was one of the trickiest aspects of the table—it took some time to figure out how to fill the gap between the rounded corners and the rectangle. Fortunately, I drew inspiration from the Great Tables example, Highest Paid Athletes in 2023. The solution was to use two &lt;div&gt; tags, which allowed me to assign distinct colors to the inside and outside of the border.\nI created four empty columns—[\"0\", \"1\", \"2\", \"3\"]—to serve as borders. This allowed for easier adjustment of border properties such as color and width. An interesting feature of GT.cols_width() is that you can set column widths using percentages, and the total doesn’t need to add up to exactly 100%—it just works. This is especially handy when experimenting with different table designs, as it lets you estimate widths without worrying about precise calculations.\nI added a “mod” column to help distinguish whether a row’s index is odd or even. This made it possible to combine pl.when().then().otherwise() with pl.Expr.map_elements(). Although pl.Expr.map_elements() is generally considered an anti-pattern in Polars, I believe it fits my use case well.\nThe column_labels_border_bottom_style= parameter in GT.tab_options() is key to hiding the line between the column labels and the table body.\nLogo embedding might seem a bit tricky if you’re new to Great Tables; I suggest reading the blog post that details how to render images anywhere in Great Tables.\nTo enhance the overall visual effect, I added a row at the end of the table and filled it with the same background color.\nThe original table featured two rings, but I was only able to implement the inner one using GT.opt_table_outline(). I decided to leave it out for a cleaner appearance.\nWhile the color codes and font properties could be further enhanced, Great Tables successfully replicates the table’s structure and style with only minor differences.\n\n\n\n\n\n\n\n\nShow full code\nimport polars as pl\nfrom great_tables import GT, google_font, html, loc, style, vals\n\n# source1: https://truthsocial.com/@realDonaldTrump/114270398531479278\n# source2:\n# \"https://upload.wikimedia.org/wikipedia/commons/\n# thumb/3/36/Seal_of_the_President_of_the_United_States.svg/\n# 800px-Seal_of_the_President_of_the_United_States.svg.png\"\nlogo = vals.fmt_image(\"logo.png\", height=150)[0]\n\ndata = {\n    \"country\": [\n        \"China\",\n        \"European Union\",\n        \"Vietnam\",\n        \"Taiwan\",\n        \"Japan\",\n        \"India\",\n        \"South Korea\",\n        \"Thailand\",\n        \"Switzerland\",\n        \"Indonesia\",\n        \"Malaysia\",\n        \"Cambodia\",\n        \"United Kingdom\",\n        \"South Africa\",\n        \"Brazil\",\n        \"Bangladesh\",\n        \"Singapore\",\n        \"Israel\",\n        \"Philippines\",\n        \"Chile\",\n        \"Australia\",\n        \"Pakistan\",\n        \"Turkey\",\n        \"Sri Lanka\",\n        \"Colombia\",\n    ],\n    \"tariffs_charged\": [\n        \"67%\",\n        \"39%\",\n        \"90%\",\n        \"64%\",\n        \"46%\",\n        \"52%\",\n        \"50%\",\n        \"72%\",\n        \"61%\",\n        \"64%\",\n        \"47%\",\n        \"97%\",\n        \"10%\",\n        \"60%\",\n        \"10%\",\n        \"74%\",\n        \"10%\",\n        \"33%\",\n        \"34%\",\n        \"10%\",\n        \"10%\",\n        \"58%\",\n        \"10%\",\n        \"88%\",\n        \"10%\",\n    ],\n    \"reciprocal_tariffs\": [\n        \"34%\",\n        \"20%\",\n        \"46%\",\n        \"32%\",\n        \"24%\",\n        \"26%\",\n        \"25%\",\n        \"36%\",\n        \"31%\",\n        \"32%\",\n        \"24%\",\n        \"49%\",\n        \"10%\",\n        \"30%\",\n        \"10%\",\n        \"37%\",\n        \"10%\",\n        \"17%\",\n        \"17%\",\n        \"10%\",\n        \"10%\",\n        \"29%\",\n        \"10%\",\n        \"44%\",\n        \"10%\",\n    ],\n}\n\ndark_navy_blue = \"#0B162A\"  # background\nlight_blue = \"#B5D3E7\"  # row\nwhite = \"#FFFFFF\"  # row\nyellow = \"#F6D588\"  # \"reciprocal_tariffs\" column\ngold = \"#FFF8DE\"  # logo\n\n\ndef change_border_radius(\n    x: str, border_radius: str, background_color1: str, background_color2: str\n) -&gt; str:\n    return f\"\"\"\\\n    &lt;div style=\"background-color: {background_color1};border: None\"&gt;\\\n        &lt;div style=\"border-radius: {border_radius};\\\n                    background-color:{background_color2};\"&gt;\\\n            &nbsp;{x}\\\n        &lt;/div&gt;\\\n    &lt;/div&gt;\\\n    \"\"\"\n\n\ndef change_border_radius_expr(\n    cols: pl.Expr,\n    return_dtype: pl.DataType,\n    border_radius: str,\n    background_color1: str,\n    background_color2: str,\n) -&gt; pl.Expr:\n    return cols.map_elements(\n        lambda x: change_border_radius(\n            x, border_radius, background_color1, background_color2\n        ),\n        return_dtype=return_dtype,\n    )\n\n\ndf = (\n    pl.DataFrame(data)\n    .with_row_index(\"mod\")\n    .with_columns(pl.col(\"mod\").mod(2), *[pl.lit(\"\").alias(str(i)) for i in range(4)])\n    .with_columns(\n        # \"country\" and \"tariffs_charged\" columns\n        pl.when(pl.col(\"mod\").eq(0))\n        .then(\n            change_border_radius_expr(\n                pl.col(\"country\", \"tariffs_charged\"),\n                pl.String,\n                \"5px\",\n                dark_navy_blue,\n                light_blue,\n            )\n        )\n        .otherwise(\n            change_border_radius_expr(\n                pl.col(\"country\", \"tariffs_charged\"),\n                pl.String,\n                \"5px\",\n                dark_navy_blue,\n                white,\n            )\n        ),\n        # \"reciprocal_tariffs\" column\n        change_border_radius_expr(\n            pl.col(\"reciprocal_tariffs\"), pl.String, \"5px\", dark_navy_blue, yellow\n        ),\n    )\n    .select([\"0\", \"country\", \"1\", \"tariffs_charged\", \"2\", \"reciprocal_tariffs\", \"3\"])\n    # add a row at the end of the table\n    .pipe(\n        lambda df_: pl.concat(\n            [df_, pl.DataFrame({col: \"\" for col in df_.columns})], how=\"vertical\"\n        )\n    )\n)\n\n# inner_ring_style, inner_ring_width, inner_ring_color = \"dashed\", \"3px\", \"orange\"\n\n(\n    GT(df)\n    .cols_align(\n        \"center\", columns=[\"tariffs_charged\", \"reciprocal_tariffs\"]\n    )\n    .cols_label(\n        {\n            \"country\": html(\n                f\"\"\"\\\n                &lt;br&gt;\\\n                &lt;div&gt;\\\n                    {logo}&nbsp;\\\n                    &lt;span style=\"color: {gold}; font-size: 40px;\"&gt;\\\n                        &nbsp&nbsp;Reciprocal Tariffs\\\n                    &lt;/span&gt;\\\n                &lt;/div&gt;\\\n                &lt;br&gt;\\\n                &lt;b&gt;Country&lt;/b&gt;\\\n                \"\"\"\n            ),\n            \"tariffs_charged\": html(\n                \"\"\"\\\n                &lt;b&gt;Tariffs Charged&lt;br&gt;to the U.S.A.&lt;/b&gt;\\\n                &lt;br&gt;\\\n                &lt;span style=\"font-size: 12px;\"&gt;\\\n                    Including&lt;br&gt;Currency Manipulation&lt;br&gt;and Trade Barriers\\\n                &lt;/span&gt;\\\n                \"\"\"\n            ),\n            \"reciprocal_tariffs\": html(\n                \"&lt;b&gt;U.S.A. Discounted&lt;br&gt;Reciprocal Tariffs&lt;/b&gt;\"\n            ),\n            \"0\": \"\",\n            \"1\": \"\",\n            \"2\": \"\",\n            \"3\": \"\",\n        }\n    )\n    .cols_width(\n        {\n            \"country\": \"50%\",\n            \"0\": \"3%\",\n            \"1\": \"7%\",\n            \"2\": \"7%\",\n            \"3\": \"3%\",\n            \"tariffs_charged\": \"18%\",\n            \"reciprocal_tariffs\": \"18%\",\n        }\n    )\n    # For labels and body:\n    # set the background color of the labels and body to `dark_navy_blue`\n    .tab_style(\n        style=style.fill(color=dark_navy_blue),\n        locations=[loc.column_labels(), loc.body()],\n    )\n    # For body:\n    # set the border color of the body to `dark_navy_blue`\n    # set the font, weight and size\n    .tab_style(\n        style=[\n            style.borders(sides=\"all\", color=dark_navy_blue),\n            style.text(\n                font=google_font(name=\"Trajan Pro\"),\n                weight=\"bold\",\n                size=\"xx-large\",\n            ),\n        ],\n        locations=loc.body(),\n    )\n    # For labels:\n    # set the font, weight, size and color\n    # center-align the labels\n    .tab_style(\n        style=[\n            style.text(\n                font=google_font(name=\"Georgia\"),\n                weight=\"bold\",\n                size=\"large\",\n                color=white,\n            ),\n            style.css(\"text-align: center;\"),\n        ],\n        locations=loc.column_labels(),\n    )\n    # hide the bottom line of the label section\n    .tab_options(column_labels_border_bottom_style=\"hidden\")\n    # set the body background color to `dark_navy_blue` for the last row\n    .tab_style(\n        style=style.fill(color=dark_navy_blue),\n        locations=loc.body(rows=[-1]),\n    )\n    # .opt_table_outline(\n    #     style=inner_ring_style,\n    #     width=inner_ring_width,\n    #     color=inner_ring_color,\n    # )\n    # need to adjust `window_size` to obtain a higher-quality figure\n    # .save(\"reciprocal_tariffs_gt.png\", web_driver=\"firefox\", window_size=(1200, 1000))\n)\n\n\n\n\n\n\n\n\nDisclaimer\n\n\n\n\nThis table is intended as a self-practice project, and the data in the table may not be 100% accurate. Please refer to the original source if you require verified data.\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/styling-tricks-table-body/20250526.html",
    "href": "posts/styling-tricks-table-body/20250526.html",
    "title": "Styling tricks in Great Tables",
    "section": "",
    "text": "This post highlights a powerful yet underused feature in Great Tables: using existing columns to style the table body via from_column().\nLet’s say you have the following Polars DataFrame df:\n\nimport polars as pl\nfrom great_tables import GT, from_column, loc, style\nfrom great_tables.data import films\n\n\ndf_style = pl.DataFrame(\n    {\n        \"color\": [\"papayawhip\", \"lightblue\", \"lightgreen\"],\n        \"size\": [\"small\", \"x-large\", \"medium\"],\n        \"weight\": [\"normal\", \"bold\", \"lighter\"],\n        \"align\": [\"right\", \"center\", \"left\"],\n    }\n)\n\ncolumns = [\"year\", \"title\", \"run_time\"]\n\ndf = pl.concat(\n    [\n        pl.from_pandas(films.head(3).loc[:, columns]),\n        df_style,\n    ],\n    how=\"horizontal\",\n)\n\nprint(df)\n\nshape: (3, 7)\n┌──────┬───────────────────────────┬──────────┬────────────┬─────────┬─────────┬────────┐\n│ year ┆ title                     ┆ run_time ┆ color      ┆ size    ┆ weight  ┆ align  │\n│ ---  ┆ ---                       ┆ ---      ┆ ---        ┆ ---     ┆ ---     ┆ ---    │\n│ i64  ┆ str                       ┆ str      ┆ str        ┆ str     ┆ str     ┆ str    │\n╞══════╪═══════════════════════════╪══════════╪════════════╪═════════╪═════════╪════════╡\n│ 1946 ┆ The Lovers                ┆ 1h 30m   ┆ papayawhip ┆ small   ┆ normal  ┆ right  │\n│ 1946 ┆ Anna and the King of Siam ┆ 2h 8m    ┆ lightblue  ┆ x-large ┆ bold    ┆ center │\n│ 1946 ┆ Blood and Fire            ┆ 1h 40m   ┆ lightgreen ┆ medium  ┆ lighter ┆ left   │\n└──────┴───────────────────────────┴──────────┴────────────┴─────────┴─────────┴────────┘\n\n\nThe color, size, weight, and align columns contain style-related metadata. We can use from_column() to map this metadata to four styling options provided by Great Tables—style.fill(), style.text(), style.borders(), and style.css()—all of which are built on the internal CellStyle class.\n\n(\n    GT(df)\n    .tab_style(\n        style=[\n            style.fill(color=from_column(\"color\")),\n            style.text(\n                size=from_column(\"size\"),\n                weight=from_column(\"weight\"),\n                align=from_column(\"align\"),\n            ),\n        ],\n        locations=loc.body(columns),\n    )\n    .cols_hide(df_style.columns)\n    .opt_stylize(style=6, color=\"gray\")\n)\n\n\n\n\n\n\n\n  year\n  title\n  run_time\n\n\n\n  \n    1946\n    The Lovers\n    1h 30m\n  \n  \n    1946\n    Anna and the King of Siam\n    2h 8m\n  \n  \n    1946\n    Blood and Fire\n    1h 40m\n  \n\n\n\n\n\n\n        \n\n\nOne last note: from_column() works with both Pandas and Polars DataFrames. For Polars users, you can also pass expressions directly without wrapping them in from_column(). The following code produces the same styled table as shown above:\n\n(\n    GT(df)\n    .tab_style(\n        style=[\n            style.fill(color=pl.col(\"color\")),\n            style.text(\n                size=pl.col(\"size\"), weight=pl.col(\"weight\"), align=pl.col(\"align\")\n            ),\n        ],\n        locations=loc.body(columns),\n    )\n    .cols_hide(df_style.columns)\n    .opt_stylize(style=6, color=\"gray\")\n)\n\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/access-axes-in-plotnine/20250411.html",
    "href": "posts/access-axes-in-plotnine/20250411.html",
    "title": "How to Access the Axes in Plotnine",
    "section": "",
    "text": "This is a short post documenting my experience trying to retrieve the Axes from plotnine.\nThe idea was inspired by this code and this video I came across, but the original solution didn’t quite work for me. Fortunately, I found that we can access the list of Axes directly using either fig.axes or fig.get_axes().\nIn the example below, I adapt a snippet from the plotnine documentation to demonstrate how to highlight text in color using HighlightText.\n\n\n\n\n\n\nimport highlight_text as ht\nfrom plotnine import aes, geom_point, ggplot, labs, theme_matplotlib, theme_set\nfrom plotnine.data import mpg\n\ntheme_set(theme_matplotlib())\n\np = (\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\nfig = p.draw()\nax = fig.axes[0]  # or via fig.get_axes()[0]\nht_ax_text = 'Color highlighted by &lt;HighlightText::{\"color\": \"#E58606\"}&gt;'\nht.ax_text(4, 40, ht_ax_text, vsep=3, fontsize=9, va=\"top\", ax=ax)\nfig\n\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html",
    "href": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html",
    "title": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib",
    "section": "",
    "text": "It was an honor to be one of the reviewers for Matt Harrison’s new book, Effective Visualization. If you’re looking to deepen your understanding of how to use Pandas and Matplotlib to craft compelling data stories, this book is a must-read.\nLast weekend, I decided to convert some of the Pandas code from the book into Polars just for fun, and I’d like to share an example in this post. You can find the original Pandas code in the repo (empty link for now).\nThe final figure, shown below, visualizes temperature trends for the ski season in Alta over the past few decades.\nShow full code\nimport matplotlib.pyplot as plt\nimport polars as pl\nimport polars.selectors as cs\nfrom highlight_text import ax_text\nfrom matplotlib import colormaps\n\n# https://github.com/mattharrison/datasets/raw/refs/heads/master/data/alta-noaa-1980-2019.csv\ndata_path = \"alta-noaa-1980-2019.csv\"\ncolumns = [\"DATE\", \"TOBS\"]\nidx_colname = \"DAY_OF_SEASON\"\n\n\ndef tweak_df(data_path: str, columns: list[str], idx_colname: str = \"DAY_OF_SEASON\"):\n    return (\n        pl.scan_csv(data_path)\n        .select(columns)\n        .with_columns(\n            pl.col(\"DATE\").str.to_datetime(),\n            pl.col(\"TOBS\").interpolate(),\n        )\n        .sort(\"DATE\")\n        .with_columns(\n            # Caveat: Cannot be placed in the previous `with_columns()`\n            # due to different statuses of `TOBS`.\n            pl.col(\"TOBS\").rolling_mean(window_size=28, center=True).alias(\"TMEAN\"),\n            get_season_expr(col=\"DATE\", alias=\"SEASON\"),\n        )\n        .with_columns(\n            add_day_of_season_expr(col=\"DATE\", group_col=\"SEASON\", alias=idx_colname)  #\n        )\n        .collect()\n    )\n\n\ndef get_season_expr(col: str = \"DATE\", alias: str = \"SEASON\") -&gt; pl.expr:\n    return (\n        (\n            pl.when((pl.col(col).dt.month().is_between(5, 10, closed=\"both\")))\n            .then(pl.lit(\"Summer \"))\n            .otherwise(pl.lit(\"Ski \"))\n        )\n        .add(\n            pl.when(pl.col(col).dt.month() &lt; 11)\n            .then(pl.col(col).dt.year().cast(pl.String))\n            .otherwise(pl.col(col).dt.year().add(1).cast(pl.String))\n        )\n        .alias(alias)\n    )\n\n\ndef add_day_of_season_expr(\n    col: str = \"DATE\", group_col: str = \"SEASON\", alias: str = \"DAY_OF_SEASON\"\n) -&gt; pl.expr:\n    return (\n        (pl.col(col) - pl.col(col).min()).dt.total_days().over(group_col).alias(alias)\n    )\n\n\ndef plot_temps(_df: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\") -&gt; pl.DataFrame:\n    plt.rcParams[\"font.family\"] = \"Roboto\"\n    figsize = (160, 165)  # pts\n\n    def points_to_inches(points):\n        return points / 72\n\n    figsize_inches = [points_to_inches(dim) for dim in figsize]\n\n    heading_fontsize = 9.5\n    heading_fontweight = \"bold\"\n    subheading_fontsize = 8\n    subheading_fontweight = \"normal\"\n    source_fontsize = 6.5\n    source_fontweight = \"light\"\n    axis_fontsize = 7\n    axis_fontweight = \"normal\"\n\n    grey = \"#aaaaaa\"\n    red = \"#e3120b\"\n    blue = \"#0000ff\"\n    cmap = colormaps.get_cmap(\"Grays\")\n\n    layout = [[\"title\"], [\"plot\"], [\"notes\"]]\n    fig, axs = plt.subplot_mosaic(\n        layout,\n        gridspec_kw={\"height_ratios\": [6, 12, 1]},\n        figsize=figsize_inches,\n        dpi=300,\n        constrained_layout=True,\n    )\n\n    # ----- Title -----\n    ax_title = axs[\"title\"]\n    ax_title.axis(\"off\")\n    sub_props = {\"fontsize\": subheading_fontsize, \"fontweight\": subheading_fontweight}\n    ax_text(\n        s=\"&lt;Alta Ski Resort&gt;\\n&lt;Temperature trends by &gt;\\n&lt;decade&gt;&lt; and &gt;&lt;2019&gt;\",\n        x=0,\n        y=0,\n        fontsize=heading_fontsize,\n        ax=ax_title,\n        va=\"bottom\",\n        ha=\"left\",\n        zorder=5,\n        highlight_textprops=[\n            {\"fontsize\": heading_fontsize, \"fontweight\": heading_fontweight},\n            sub_props,\n            {\"color\": blue, **sub_props},\n            sub_props,\n            {\"color\": red, **sub_props},\n        ],\n    )\n\n    # ----- Plot -----\n    ax = axs[\"plot\"]\n    season_temps = _df.filter(pl.col(\"SEASON\").str.contains(\"Ski\")).pivot(\n        \"SEASON\", index=idx_colname, values=\"TMEAN\", aggregate_function=\"first\"\n    )\n    season_temps_index = season_temps[idx_colname]\n\n    columns = season_temps.columns\n    columns.remove(idx_colname)\n    columns.remove(\"Ski 2019\")\n    for i, column in enumerate(columns):\n        color = cmap(i / len(columns))\n        ax.plot(\n            season_temps_index,\n            season_temps[column],\n            color=color,\n            linewidth=1,\n            alpha=0.2,\n            zorder=1,\n        )\n\n    # # ---- Decade Averages ----\n    decades = [1980, 1990, 2000, 2010]\n    blues = [\"#0055EE\", \"#0033CC\", \"#0011AA\", \"#3377FF\"]\n    for decade, color in zip(decades, blues):\n        match = str(decade)[:-1]  # 1980 -&gt; \"198\", 2010 -&gt; \"201\"\n        decade_temps = season_temps.select(cs.contains(match)).mean_horizontal()\n        ax.plot(season_temps_index, decade_temps, color=color, linewidth=1)\n\n        # add label to right of line\n        last_y_label = decade_temps.last()\n\n        if decade == 2000:\n            last_y_label -= 3\n        elif decade == 2010:\n            last_y_label -= 0.3\n\n        ax.text(\n            185,\n            last_y_label,\n            f\"{decade}\",\n            va=\"center\",\n            ha=\"left\",\n            fontsize=axis_fontsize,\n            fontweight=axis_fontweight,\n            color=color,\n        )\n        # # add dot to start and end of each line\n        ax.plot(\n            season_temps_index.first(),\n            decade_temps.first(),\n            marker=\"o\",\n            color=color,\n            markersize=1,\n            zorder=2,\n        )\n        ax.plot(\n            season_temps_index.last(),\n            decade_temps.last(),\n            marker=\"o\",\n            color=color,\n            markersize=1,\n            zorder=2,\n        )\n\n    # # ------ Ski 2019 ------\n    # # plot `Ski 2019` in red\n    ski_2019 = season_temps.select(idx_colname, cs.by_name(\"Ski 2019\")).drop_nulls()\n    ski_2019_index = ski_2019[idx_colname]\n    ski_2019 = ski_2019.drop([idx_colname]).to_series()\n    ax.plot(ski_2019_index, ski_2019, color=\"red\", linewidth=1)\n\n    # add dot to start and end of each line\n    ax.plot(\n        ski_2019_index.first(),\n        ski_2019.first(),\n        marker=\"o\",\n        color=\"red\",\n        markersize=2,\n        zorder=2,\n    )\n    ax.plot(\n        ski_2019_index.last(),\n        ski_2019.last(),\n        marker=\"o\",\n        color=\"red\",\n        markersize=2,\n        zorder=2,\n    )\n\n    # # ------ Ticks & Lines ------\n    # # remove spines\n    for side in [\"top\", \"left\", \"right\"]:\n        ax.spines[side].set_visible(False)\n\n    # # add horizontal line at 32F\n    ax.axhline(32, color=\"black\", linestyle=\"--\", linewidth=1, zorder=1)\n\n    # # set y ticks\n    ax.set_yticks(ticks=[10, 32, 40])\n\n    # # set y limit\n    ax.set_ylim([10, 55])\n\n    # # set x label\n    ax.set_xlabel(\"Day of season\", fontsize=axis_fontsize, fontweight=axis_fontweight)\n\n    # # ------ Source ------\n    ax_notes = axs[\"notes\"]\n    # add source\n    ax_notes.axis(\"off\")\n    ax_notes.text(\n        0,\n        0,\n        \"Source: NOAA\",\n        fontsize=source_fontsize,\n        fontweight=source_fontweight,\n        color=grey,\n    )\n    return _df\n\n\ndf = tweak_df(data_path, columns, idx_colname)\ndf.pipe(plot_temps, idx_colname)"
  },
  {
    "objectID": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#data-processing-pipeline",
    "href": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#data-processing-pipeline",
    "title": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib",
    "section": "Data Processing Pipeline",
    "text": "Data Processing Pipeline\nBelow is the data pipeline used to generate the DataFrame for the upcoming visualization stage:\ndata_path = \"alta-noaa-1980-2019.csv\"\ncolumns = [\"DATE\", \"TOBS\"]\nidx_colname = \"DAY_OF_SEASON\"\n\n\ndef tweak_df(data_path: str, columns: list[str], idx_colname: str = \"DAY_OF_SEASON\"):\n    return (\n        pl.scan_csv(data_path)\n1        .select(columns)\n        .with_columns(\n2            pl.col(\"DATE\").str.to_datetime(),\n3            pl.col(\"TOBS\").interpolate(),\n        )\n        .sort(\"DATE\")\n        .with_columns(\n            # Caveat: Cannot be placed in the previous `with_columns()`\n            # due to different statuses of `TOBS`.\n4            pl.col(\"TOBS\").rolling_mean(window_size=28, center=True).alias(\"TMEAN\"),\n5            get_season_expr(col=\"DATE\", alias=\"SEASON\"),\n        )\n        .with_columns(\n6            add_day_of_season_expr(col=\"DATE\", group_col=\"SEASON\", alias=idx_colname)\n        )\n        .collect()\n    )\n\ndf = tweak_df(data_path, columns, idx_colname)\n\n1\n\nSelect the DATE column (dates) and TOBS column (recorded temperatures in Fahrenheit).\n\n2\n\nConvert the DATE column to a datetime format.\n\n3\n\nPerform interpolation on the TOBS column.\n\n4\n\nCompute a 28-day rolling average for TOBS.\n\n5\n\nUse get_season_expr() to categorize each date into a SEASON.\n\n6\n\nApply add_day_of_season_expr() to calculate DAY_OF_SEASON, representing days elapsed since the start of the season.\n\n\nThe first three steps involve straightforward Polars expressions. In the following sections, we’ll dive deeper into steps 5 to 6.\n\nCategorizing Dates into Summer and Ski Seasons\nTo analyze seasonal trends, we classify dates into two categories:\n\nSummer: Covers May through October.\n\nSki: Covers November through April.\n\nIf a date falls in November or December, it is assigned to the following year’s season. For example, 2015-10-31 is categorized as Summer 2015, while 2015-11-01 belongs to Ski 2016.\nTo implement this logic, we define get_season_expr(), which leverages Polars’ when-then-otherwise expressions to determine the season and year.\ndef get_season_expr(col: str = \"DATE\", alias: str = \"SEASON\") -&gt; pl.expr:\n    return (\n        (\n            pl.when((pl.col(col).dt.month().is_between(5, 10, closed=\"both\")))\n            .then(pl.lit(\"Summer \"))\n            .otherwise(pl.lit(\"Ski \"))\n        )\n        .add(\n            pl.when(pl.col(col).dt.month() &lt; 11)\n            .then(pl.col(col).dt.year().cast(pl.String))\n            .otherwise(pl.col(col).dt.year().add(1).cast(pl.String))\n        )\n        .alias(alias)\n    )\nIn this function:\n\nIf the month is between May and October, the function assigns \"Summer \". Otherwise, it assigns \"Ski \" (with a trailing space for concatenation).\n\nThe year is determined based on the month: dates from January to October retain their current year, while those in November and December are shifted to the next year.\n\nBy applying this function, we can add a SEASON column to a Polars DataFrame, ensuring each date is categorized correctly.\n\n\nCalculating the Total Days for Each Season\nOnce we have the seasonal categories, we calculate DAY_OF_SEASON, which tracks the number of days elapsed within each season. This is achieved using the pl.expr.over() expression, which operates similarly to Pandas’ groupby().transform(), applying transformations within groups.\ndef add_day_of_season_expr(\n    col: str = \"DATE\", group_col: str = \"SEASON\", alias: str = \"DAY_OF_SEASON\"\n) -&gt; pl.expr:\n    return (\n        (pl.col(col) - pl.col(col).min()).dt.total_days().over(group_col).alias(alias)\n    )"
  },
  {
    "objectID": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#visualizing-temperature-trends-with-matplotlib",
    "href": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#visualizing-temperature-trends-with-matplotlib",
    "title": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib",
    "section": "Visualizing Temperature Trends with Matplotlib",
    "text": "Visualizing Temperature Trends with Matplotlib\nWith the data prepared, we move on to plotting. Since plot_temps() is quite long, we’ll break it down into several parts for easier explanation.\n\nSetting Up the Figure\nWe start by defining some parameters and using plt.subplot_mosaic() to create the figure layout. This provides structured axes for different elements of the visualization.\ndef plot_temps(_df: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\") -&gt; pl.DataFrame:\n    plt.rcParams[\"font.family\"] = \"Roboto\"\n    figsize = (160, 165)  # pts\n\n    def points_to_inches(points):\n        return points / 72\n\n    figsize_inches = [points_to_inches(dim) for dim in figsize]\n\n    heading_fontsize = 9.5\n    heading_fontweight = \"bold\"\n    subheading_fontsize = 8\n    subheading_fontweight = \"normal\"\n    source_fontsize = 6.5\n    source_fontweight = \"light\"\n    axis_fontsize = 7\n    axis_fontweight = \"normal\"\n\n    grey = \"#aaaaaa\"\n    red = \"#e3120b\"\n    blue = \"#0000ff\"\n    cmap = colormaps.get_cmap(\"Grays\")\n\n    layout = [[\"title\"], [\"plot\"], [\"notes\"]]\n    fig, axs = plt.subplot_mosaic(\n        layout,\n        gridspec_kw={\"height_ratios\": [6, 12, 1]},\n        figsize=figsize_inches,\n        dpi=300,\n        constrained_layout=True,\n    )\n    ...\n    \n\n\nAdding the Title\nFor the title, we use ax_text() from the HighlightText library, which allows selective styling of text enclosed in &lt; &gt;. This lets us highlight key parts of the title, such as &lt;Alta Ski Resort&gt;, &lt;Temperature trends by &gt;, &lt;decade&gt;, &lt; and &gt;, and &lt;2019&gt;, with custom formatting.\ndef plot_temps(\n    _df: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    ...\n\n    # ----- Title -----\n    ax_title = axs[\"title\"]\n    ax_title.axis(\"off\")\n    sub_props = {\"fontsize\": subheading_fontsize, \"fontweight\": subheading_fontweight}\n    ax_text(\n        s=\"&lt;Alta Ski Resort&gt;\\n&lt;Temperature trends by &gt;\\n&lt;decade&gt;&lt; and &gt;&lt;2019&gt;\",\n        x=0,\n        y=0,\n        fontsize=heading_fontsize,\n        ax=ax_title,\n        va=\"bottom\",\n        ha=\"left\",\n        zorder=5,\n        highlight_textprops=[\n            {\"fontsize\": heading_fontsize, \"fontweight\": heading_fontweight},\n            sub_props,\n            {\"color\": blue, **sub_props},\n            sub_props,\n            {\"color\": red, **sub_props},\n        ],\n    )\n\n\nPlotting Seasonal Trends\nNext, we generate the main plot by:\n\nFiltering the dataset for Ski seasons.\n\nPivoting the table to organize TMEAN values by DAY_OF_SEASON and SEASON.\n\nUsing ax.plot() to draw a separate line for each Ski season.\n\ndef plot_temps(\n    _df: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    ...\n\n    # ----- Plot -----\n    ax = axs[\"plot\"]\n    season_temps = _df.filter(pl.col(\"SEASON\").str.contains(\"Ski\")).pivot(\n        \"SEASON\", index=idx_colname, values=\"TMEAN\", aggregate_function=\"first\"\n    )\n    season_temps_index = season_temps[idx_colname]\n\n    columns = season_temps.columns\n    columns.remove(idx_colname)\n    columns.remove(\"Ski 2019\")\n    for i, column in enumerate(columns):\n        color = cmap(i / len(columns))\n        ax.plot(\n            season_temps_index,\n            season_temps[column],\n            color=color,\n            linewidth=1,\n            alpha=0.2,\n            zorder=1,\n        )\nTo illustrate long-term trends, we overlay four lines representing the average temperature trends for different decades, marking their start and end points with dots for emphasis.\ndef plot_temps(\n    _df: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    ...\n\n    # # ---- Decade Averages ----\n    decades = [1980, 1990, 2000, 2010]\n    blues = [\"#0055EE\", \"#0033CC\", \"#0011AA\", \"#3377FF\"]\n    for decade, color in zip(decades, blues):\n        match = str(decade)[:-1] # 1980 -&gt; \"198\", 2010 -&gt; \"201\"\n1        decade_temps = season_temps.select(cs.contains(match)).mean_horizontal()\n        ax.plot(season_temps_index, decade_temps, color=color, linewidth=1)\n\n        # add label to right of line\n        last_y_label = decade_temps.last()\n\n        if decade == 2000:\n            last_y_label -= 3\n        elif decade == 2010:\n            last_y_label -= 0.3\n\n        ax.text(\n            185,\n            last_y_label,\n            f\"{decade}\",\n            va=\"center\",\n            ha=\"left\",\n            fontsize=axis_fontsize,\n            fontweight=axis_fontweight,\n            color=color,\n        )\n        # # add dot to start and end of each line\n        ax.plot(\n            season_temps_index.first(),\n            decade_temps.first(),\n            marker=\"o\",\n            color=color,\n            markersize=1,\n            zorder=2,\n        )\n        ax.plot(\n            season_temps_index.last(),\n            decade_temps.last(),\n            marker=\"o\",\n            color=color,\n            markersize=1,\n            zorder=2,\n        )\n\n1\n\nWe leverage two powerful features of Polars: Polars selectors, which enable efficient column selection based on name patterns to extract data for each decade (cs.contains(match)), and df.mean_horizontal(), which performs vectorized operations across columns to compute the average temperature for each decade.\n\n\n\n\nHighlighting the 2019 Ski Season\nTo make Ski 2019 stand out, we plot its trend in red and highlight its start and end points with dots, similar to the decade lines.\ndef plot_temps(\n    _df: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    ...\n\n    # # ------ Ski 2019 ------\n    # # plot `Ski 2019` in red\n1    ski_2019 = season_temps.select(idx_colname, cs.by_name(\"Ski 2019\")).drop_nulls()\n    ski_2019_index = ski_2019[idx_colname]\n    ski_2019 = ski_2019.drop([idx_colname]).to_series()\n    ax.plot(ski_2019_index, ski_2019, color=\"red\", linewidth=1)\n\n    # add dot to start and end of each line\n    ax.plot(\n        ski_2019_index.first(),\n        ski_2019.first(),\n        marker=\"o\",\n        color=\"red\",\n        markersize=2,\n        zorder=2,\n    )\n    ax.plot(\n        ski_2019_index.last(),\n        ski_2019.last(),\n        marker=\"o\",\n        color=\"red\",\n        markersize=2,\n        zorder=2,\n    )\n\n1\n\nWe use the Polars selector (cs.by_name()) to isolate the Ski 2019 data.\n\n\n\n\nRefinements for Clarity\nTo enhance readability, we refine the visualization by adjusting:\n\nSpines: Removing unnecessary borders.\n\nReference Line: Adding a horizontal dashed line at 32°F for context.\n\nTicks & Limits: Setting appropriate y-axis ticks and limits.\n\nLabels: Customizing the x-axis label for clarity.\n\ndef plot_temps(\n    _df: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    ...\n\n    # # ------ Ticks & Lines ------\n    # # remove spines\n    for side in [\"top\", \"left\", \"right\"]:\n        ax.spines[side].set_visible(False)\n\n    # # add horizontal line at 32F\n    ax.axhline(32, color=\"black\", linestyle=\"--\", linewidth=1, zorder=1)\n\n    # # set y ticks\n    ax.set_yticks(ticks=[10, 32, 40])\n\n    # # set y limit\n    ax.set_ylim([10, 55])\n\n    # # set x label\n    ax.set_xlabel(\"Day of season\", fontsize=axis_fontsize, fontweight=axis_fontweight)\n\n\nAdding Notes\nFinally, we use Matplotlib’s ax.text() to annotate the source of the data.\ndef plot_temps(\n    _df: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    ...\n\n    # # ------ Source ------\n    ax_notes = axs[\"notes\"]\n    # add source\n    ax_notes.axis(\"off\")\n    ax_notes.text(\n        0,\n        0,\n        \"Source: NOAA\",\n        fontsize=source_fontsize,\n        fontweight=source_fontweight,\n        color=grey,\n    )\n    return _df"
  },
  {
    "objectID": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#rendering-the-plot",
    "href": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#rendering-the-plot",
    "title": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib",
    "section": "Rendering the Plot",
    "text": "Rendering the Plot\nFinally, we render the plot using pl.DataFrame.pipe():\ndf.pipe(plot_temps, idx_colname)"
  },
  {
    "objectID": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#wrapping-up",
    "href": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#wrapping-up",
    "title": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib",
    "section": "Wrapping Up",
    "text": "Wrapping Up\nRecreating this figure with Polars turned out to be more involved than I initially expected. However, the process was incredibly rewarding, as it deepened my understanding of Pandas, Polars, and Matplotlib. Switching between Pandas and Polars required a shift in mindset, but it also reinforced key concepts in both libraries. I look forward to exploring more of these challenges in the future.\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Posts",
    "section": "",
    "text": "Styling tricks in Great Tables\n\n\n\npython\n\npandas\n\npolars\n\ngt\n\n\n\n\n\n\n\n\n\nMay 26, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\ncase_when() in Polars\n\n\n\npython\n\npolars\n\n\n\n\n\n\n\n\n\nMay 25, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nCustom Row Selector in Great Tables\n\n\n\npython\n\npandas\n\npolars\n\ngt\n\n\n\n\n\n\n\n\n\nMay 11, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nPolars Custom Expression Namespace\n\n\n\npython\n\npolars\n\n\n\n\n\n\n\n\n\nApr 17, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nClone the Reciprocal Tariffs Table Using Plotnine\n\n\n\npython\n\npolars\n\nplotnine\n\n\n\n\n\n\n\n\n\nApr 16, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nWeekend Challenge – Recreating a Data Visualization with Polars and Plotnine\n\n\n\npython\n\npolars\n\nmatplotlib\n\nplotnine\n\n\n\n\n\n\n\n\n\nApr 12, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nHow to Access the Axes in Plotnine\n\n\n\npython\n\nmatplotlib\n\nplotnine\n\n\n\n\n\n\n\n\n\nApr 11, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nClone the Reciprocal Tariffs Table Using Great Tables\n\n\n\npython\n\npolars\n\ngt\n\n\n\n\n\n\n\n\n\nApr 3, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nApplying Custom Color Palettes to the Table Body in Great Tables\n\n\n\npython\n\npandas\n\npolars\n\ngt\n\n\n\n\n\n\n\n\n\nFeb 25, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nWeekend Challenge - Effective Data Visualization with Polars and Matplotlib\n\n\n\npython\n\npandas\n\npolars\n\nmatplotlib\n\n\n\n\n\n\n\n\n\nFeb 10, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nThree Approaches to Styling the Table Body in Great Tables\n\n\n\npython\n\npolars\n\ngt\n\n\n\n\n\n\n\n\n\nJan 24, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nExploring Resend SMTP Service with Django\n\n\n\npython\n\ndjango\n\nresend\n\n\n\n\n\n\n\n\n\nDec 23, 2024\n\n\nJerry Wu\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/table-body-custom-palette/20250225.html",
    "href": "posts/table-body-custom-palette/20250225.html",
    "title": "Applying Custom Color Palettes to the Table Body in Great Tables",
    "section": "",
    "text": "This post provides a concise guide on styling the table body with custom colors using Pandas and Polars.\nThere are two primary methods for applying a color palette: one leverages a pre-existing column containing color values, while the other determines colors dynamically based on conditions. I’ll walk you through both approaches.\nSince all the generated tables will have the same appearance, I’ll display the final result just once:"
  },
  {
    "objectID": "posts/table-body-custom-palette/20250225.html#preparations",
    "href": "posts/table-body-custom-palette/20250225.html#preparations",
    "title": "Applying Custom Color Palettes to the Table Body in Great Tables",
    "section": "Preparations",
    "text": "Preparations\nWe’ll start by creating a data dictionary, which will be used with Pandas or Polars later. Additionally, we’ll define a color_mapping dictionary to store the palette information for styling.\n\nimport pandas as pd\nimport polars as pl\nfrom great_tables import GT, from_column, loc, style\nfrom polars import selectors as cs\n\ndata = {\n    \"col1\": [2, 5, 7, 10, 15],\n    \"col2\": [\"x\", \"y\", \"y\", \"z\", \"z\"],\n    \"color\": [\"lightgrey\", \"lightblue\", \"lightblue\", \"papayawhip\", \"papayawhip\"],\n}\n\ncolor_mapping = {\"x\": \"lightgrey\", \"y\": \"lightblue\", \"z\": \"papayawhip\"}"
  },
  {
    "objectID": "posts/table-body-custom-palette/20250225.html#pandas",
    "href": "posts/table-body-custom-palette/20250225.html#pandas",
    "title": "Applying Custom Color Palettes to the Table Body in Great Tables",
    "section": "Pandas",
    "text": "Pandas\nFirst, we create a Pandas DataFrame called df_pd using data as the input:\n\n\nCode\ndf_pd = pd.DataFrame(data)\nprint(df_pd)\n\n\n   col1 col2       color\n0     2    x   lightgrey\n1     5    y   lightblue\n2     7    y   lightblue\n3    10    z  papayawhip\n4    15    z  papayawhip\n\n\n\nUsing an Existing Column\nIn this straightforward scenario, the DataFrame already contains a predefined column with color names for each row. You can use the from_column() function provided by Great Tables to apply colors to the table body:\n\n(\n    GT(df_pd)\n    .tab_style(style=style.fill(color=from_column(\"color\")), locations=loc.body())\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)\n\n\n\nUsing Functions\nIn cases where colors need to be determined dynamically based on conditions, the pd.Series.case_when() function can be very useful. The following example categorizes the values of the col1 column into three different colors:\n\ndef color_selector(df_):\n    return df_[\"col1\"].case_when(\n        [\n            (df_[\"col1\"].lt(3), \"lightgrey\"),  # &lt;3\n            (df_[\"col1\"].lt(10), \"lightblue\"),  # &lt;10\n            (df_[\"col1\"].ge(10), \"papayawhip\"),  # &gt;=10\n        ]\n    )\n\n\n(\n    GT(df_pd)\n    .tab_style(style=style.fill(color=color_selector), locations=loc.body())\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)\n\nFor categorical-like columns (e.g., col2), a simple value-to-color mapping may be sufficient. In such cases, a predefined dictionary can be used with pd.Series.map() or pd.Series.replace():\n\npd.Series.map()pd.Series.replace()\n\n\n\n(\n    GT(df_pd)\n    .tab_style(\n        style=style.fill(color=lambda df_: df_[\"col2\"].map(color_mapping)),\n        locations=loc.body(),\n    )\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)\n\n\n\n\n(\n    GT(df_pd)\n    .tab_style(\n        style=style.fill(color=lambda df_: df_[\"col2\"].replace(color_mapping)),\n        locations=loc.body(),\n    )\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)\n\n\n\n\nAlternatively, if you prefer sticking with the same approach, pd.Series.case_when() still works:\n\ndef color_selector(df_):\n    return df_[\"col2\"].case_when(\n        [\n            (df_[\"col2\"].eq(\"x\"), \"lightgrey\"),\n            (df_[\"col2\"].eq(\"y\"), \"lightblue\"),\n            (df_[\"col2\"].eq(\"z\"), \"papayawhip\"),\n        ]\n    )\n\n\n(\n    GT(df_pd)\n    .tab_style(style=style.fill(color=color_selector), locations=loc.body())\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)"
  },
  {
    "objectID": "posts/table-body-custom-palette/20250225.html#polars",
    "href": "posts/table-body-custom-palette/20250225.html#polars",
    "title": "Applying Custom Color Palettes to the Table Body in Great Tables",
    "section": "Polars",
    "text": "Polars\nJust like before, let’s start by creating a Polars DataFrame named df_pl using data as input:\n\n\nCode\ndf_pl= pl.DataFrame(data)\nprint(df_pl)\n\n\nshape: (5, 3)\n┌──────┬──────┬────────────┐\n│ col1 ┆ col2 ┆ color      │\n│ ---  ┆ ---  ┆ ---        │\n│ i64  ┆ str  ┆ str        │\n╞══════╪══════╪════════════╡\n│ 2    ┆ x    ┆ lightgrey  │\n│ 5    ┆ y    ┆ lightblue  │\n│ 7    ┆ y    ┆ lightblue  │\n│ 10   ┆ z    ┆ papayawhip │\n│ 15   ┆ z    ┆ papayawhip │\n└──────┴──────┴────────────┘\n\n\n\nUsing an Existing Column\nIf the DataFrame already contains a column specifying colors, we can apply them directly with from_column():\n\n(\n    GT(df_pl)\n    .tab_style(style=style.fill(color=from_column(\"color\")), locations=loc.body())\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)\n\nAs another option, we can reference the color column using a Polars expression:\n\n(\n    GT(df_pl)\n    .tab_style(style=style.fill(color=pl.col(\"color\")), locations=loc.body())\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)\n\n\n\nUsing Conditional Logic with Polars Expressions\nFor cases where colors need to be assigned dynamically, pl.when() provides a structured way to define conditions. The example below assigns colors based on the values in col1:\n\ncolor_selector_expr = (\n    pl.when(pl.col(\"col1\").lt(3))  # &lt;3\n    .then(pl.lit(\"lightgrey\"))\n    .when(pl.col(\"col1\").lt(10))  # &lt;10\n    .then(pl.lit(\"lightblue\"))\n    .when(pl.col(\"col1\").ge(10))  # &gt;=10\n    .then(pl.lit(\"papayawhip\"))\n)\n\n(\n    GT(df_pl)\n    .tab_style(style=style.fill(color=color_selector_expr), locations=loc.body())\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)\n\nFor categorical-like columns (e.g., col2), predefined mappings can be applied efficiently using pl.Expr.replace():\n\n(\n    GT(df_pl)\n    .tab_style(\n        style=style.fill(color=pl.col(\"col2\").replace(color_mapping)),\n        locations=loc.body(),\n    )\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)\n\nAlternatively, if you prefer the conditional approach, pl.when() can still be used:\n\ncolor_selector_expr = (\n    pl.when(pl.col(\"col2\").eq(pl.lit(\"x\")))\n    .then(pl.lit(\"lightgrey\"))\n    .when(pl.col(\"col2\").eq(pl.lit(\"y\")))\n    .then(pl.lit(\"lightblue\"))\n    .when(pl.col(\"col2\").eq(pl.lit(\"z\")))\n    .then(pl.lit(\"papayawhip\"))\n)\n\n\n(\n    GT(df_pl)\n    .tab_style(style=style.fill(color=color_selector_expr), locations=loc.body())\n    .cols_align(align=\"center\")\n    .opt_stylize(style=3, color=\"pink\")\n)"
  },
  {
    "objectID": "posts/table-body-custom-palette/20250225.html#final-notes",
    "href": "posts/table-body-custom-palette/20250225.html#final-notes",
    "title": "Applying Custom Color Palettes to the Table Body in Great Tables",
    "section": "Final Notes",
    "text": "Final Notes\nIn this post, we explored how to use a custom color palette to style table backgrounds with style.fill(). The same approach can be applied to customize text color using style.text() or adjust border color with style.borders().\nLastly, remember that loc.body() allows you to target specific columns and rows, giving you precise control over table styling.\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/polars-custom-expr-namespace/20250417.html",
    "href": "posts/polars-custom-expr-namespace/20250417.html",
    "title": "Polars Custom Expression Namespace",
    "section": "",
    "text": "Today I explored how to register a custom expression namespace in Polars. This feature turned out to be super helpful for solving a common problem I run into when building tables or plots—colorizing rows based on their row index.\nHere is the code snippet:\nShow full code\nfrom typing import Any\n\nimport polars as pl\nfrom great_tables import GT, loc, style\n\n\n@pl.api.register_expr_namespace(\"spt\")\nclass DiscreteSplitter:\n    def __init__(self, expr: pl.Expr) -&gt; None:\n        self._expr = expr\n\n    def _mod_expr(self, n: int) -&gt; pl.Expr:\n        return pl.int_range(pl.len(), dtype=pl.UInt32).mod(n)\n\n    def binarize(\n        self, lit1: str, lit2: str, name: str = \"binarized\"\n    ) -&gt; pl.Expr:\n        mod_expr = self._mod_expr(2)\n        return (\n            pl.when(mod_expr.eq(0))\n            .then(pl.lit(lit1))\n            .otherwise(pl.lit(lit2))\n            .alias(name)\n        )\n\n    def trinarize(\n        self, lit1: str, lit2: str, lit3: str, name: str = \"trinarized\"\n    ) -&gt; pl.Expr:\n        mod_expr = self._mod_expr(3)\n        return (\n            pl.when(mod_expr.eq(0))\n            .then(pl.lit(lit1))\n            .when(mod_expr.eq(1))\n            .then(pl.lit(lit2))\n            .otherwise(pl.lit(lit3))\n            .alias(name)\n        )\n\n    def bucketize(\n        self, lits: list[Any], name: str = \"bucketized\"\n    ) -&gt; pl.Expr:\n        mod_expr = self._mod_expr(len(lits))\n\n        # first\n        expr = pl.when(mod_expr.eq(0)).then(pl.lit(lits[0]))\n\n        # middles\n        for i, one_lit in enumerate(lits[1:-1], start=1):\n            expr = expr.when(mod_expr.eq(i)).then(pl.lit(one_lit))\n\n        # last\n        expr = expr.otherwise(pl.lit(lits[-1]))\n        return expr.alias(name)\n\n\ndf = (\n    pl.DataFrame({\"n\": [100, 50, 72, 83, 97, 42, 20, 51, 77]})\n    .with_row_index(offset=1)\n    .with_columns(\n        pl.col(\"\").spt.binarize(\"lightblue\", \"papayawhip\"),\n        pl.col(\"\").spt.trinarize(\"one\", \"two\", \"three\"),\n        pl.col(\"\").spt.bucketize([1, 2, 3, 4]),\n    )\n)\n\n(\n    GT(df)\n    .tab_style(style=style.fill(pl.col(\"binarized\")), locations=loc.body())\n    .opt_stylize(style=6)\n)"
  },
  {
    "objectID": "posts/polars-custom-expr-namespace/20250417.html#step-by-step-breakdown",
    "href": "posts/polars-custom-expr-namespace/20250417.html#step-by-step-breakdown",
    "title": "Polars Custom Expression Namespace",
    "section": "Step-by-Step Breakdown",
    "text": "Step-by-Step Breakdown\n\nRegistering the Namespace\nWe use pl.api.register_expr_namespace() to attach our class to the spt namespace. Once registered, we can call our methods like this: pl.col(\"any\").spt.binarize(...).\n@pl.api.register_expr_namespace(\"spt\")\nclass DiscreteSplitter:\n    def __init__(self, expr: pl.Expr) -&gt; None:\n        self._expr = expr\n\n\nHelper: Row-Index Based Modulo Expression\nTo assign values based on row position, we need a way to refer to the row index inside an expression. Polars provides a trick using pl.int_range(pl.len()), as shown in pl.DataFrame.with_row_index().\n@pl.api.register_expr_namespace(\"spt\")\nclass DiscreteSplitter:\n    def _mod_expr(self, n: int) -&gt; pl.Expr:\n        return pl.int_range(pl.len(), dtype=pl.UInt32).mod(n)\n\n\nbinarize: Two Groups\nThis method maps alternating rows into two categories using pl.when().then().otherwise().\n@pl.api.register_expr_namespace(\"spt\")\nclass DiscreteSplitter:\n    def binarize(\n        self, lit1: str, lit2: str, name: str = \"binarized\"\n    ) -&gt; pl.Expr:\n        mod_expr = self._mod_expr(2)\n        return (\n            pl.when(mod_expr.eq(0))\n            .then(pl.lit(lit1))\n            .otherwise(pl.lit(lit2))\n            .alias(name)\n        )\n\n\ntrinarize: Three Groups\nSimilar to binarize, but splits the rows into three groups using two when().then() branches before the final otherwise().\n@pl.api.register_expr_namespace(\"spt\")\nclass DiscreteSplitter:\n    def trinarize(\n        self, lit1: str, lit2: str, lit3: str, name: str = \"trinarized\"\n    ) -&gt; pl.Expr:\n        mod_expr = self._mod_expr(3)\n        return (\n            pl.when(mod_expr.eq(0))\n            .then(pl.lit(lit1))\n            .when(mod_expr.eq(1))\n            .then(pl.lit(lit2))\n            .otherwise(pl.lit(lit3))\n            .alias(name)\n        )\n\n\nbucketize: N Groups\nA generalized version of the above, which dynamically assigns values from a list across n groups:\n@pl.api.register_expr_namespace(\"spt\")\nclass DiscreteSplitter:\n    def bucketize(\n        self, lits: list[Any], name: str = \"bucketized\"\n    ) -&gt; pl.Expr:\n        mod_expr = self._mod_expr(len(lits))\n\n        # first\n        expr = pl.when(mod_expr.eq(0)).then(pl.lit(lits[0]))\n\n        # middles\n        for i, one_lit in enumerate(lits[1:-1], start=1):\n            expr = expr.when(mod_expr.eq(i)).then(pl.lit(one_lit))\n\n        # last\n        expr = expr.otherwise(pl.lit(lits[-1]))\n        return expr.alias(name)\n\n\nExample Usage\nHere’s a simple example that demonstrates how the custom namespace works in practice:\ndf = (\n    pl.DataFrame({\"n\": [100, 50, 72, 83, 97, 42, 20, 51, 77]})\n    .with_row_index(offset=1)\n    .with_columns(\n        pl.col(\"\").spt.binarize(\"lightblue\", \"papayawhip\"),\n        pl.col(\"\").spt.trinarize(\"one\", \"two\", \"three\"),\n        pl.col(\"\").spt.bucketize([1, 2, 3, 4]),\n    )\n)\nThis produces the following DataFrame:\nshape: (9, 5)\n┌───────┬─────┬────────────┬────────────┬────────────┐\n│ index ┆ n   ┆ binarized  ┆ trinarized ┆ bucketized │\n│ ---   ┆ --- ┆ ---        ┆ ---        ┆ ---        │\n│ u32   ┆ i64 ┆ str        ┆ str        ┆ i32        │\n╞═══════╪═════╪════════════╪════════════╪════════════╡\n│ 1     ┆ 100 ┆ lightblue  ┆ one        ┆ 1          │\n│ 2     ┆ 50  ┆ papayawhip ┆ two        ┆ 2          │\n│ 3     ┆ 72  ┆ lightblue  ┆ three      ┆ 3          │\n│ 4     ┆ 83  ┆ papayawhip ┆ one        ┆ 4          │\n│ 5     ┆ 97  ┆ lightblue  ┆ two        ┆ 1          │\n│ 6     ┆ 42  ┆ papayawhip ┆ three      ┆ 2          │\n│ 7     ┆ 20  ┆ lightblue  ┆ one        ┆ 3          │\n│ 8     ┆ 51  ┆ papayawhip ┆ two        ┆ 4          │\n│ 9     ┆ 77  ┆ lightblue  ┆ three      ┆ 1          │\n└───────┴─────┴────────────┴────────────┴────────────┘\nNote: Since the custom logic is based on the row index rather than actual column values, you can safely use pl.col(\"\") as a placeholder when calling the namespace methods.\nEach new column shows how rows are grouped using the row index modulo 2, 3, or 4—useful for highlighting patterns or applying styling.\nFor instance, you can use the binarized column with Great Tables like this:\n(\n    GT(df)\n    .tab_style(style=style.fill(pl.col(\"binarized\")), locations=loc.body())\n    .opt_stylize(style=6)\n)\n\n\n\n\n\n\n\nConclusion\nRegistering a custom expression namespace in Polars is a powerful way to encapsulate and reuse logic across your codebase. In this post, we created a DiscreteSplitter class to simplify index-based grouping, enabling operations like binarize, trinarize, and bucketize. This approach keeps your expressions clean and composable, especially when generating tables or plots that require styling based on row position.\nIt’s also worth noting that Polars supports similar registration for Series, LazyFrame, and DataFrame objects—check out the official documentation for more details.\n\n\nRemark\nHere’s a rough draft showing how to achieve a similar effect using the DataFrame namespace. I might revisit and refine this approach in the future.\n\n\nShow full code\nfrom typing import Any\n\nimport polars as pl\nfrom great_tables import GT, loc, style\n\n\n@pl.api.register_dataframe_namespace(\"spt\")\nclass DiscreteSplitter:\n    def __init__(self, df: pl.DataFrame) -&gt; None:\n        self._df = df\n        self._mod_colname = \"mod\"\n        self._mod_col = pl.col(self._mod_colname)\n        self._idx_colname = \"index\"\n        self._idx_col = pl.col(self._idx_colname)\n\n    def _get_df(self, n: int) -&gt; pl.DataFrame:\n        return self._df.with_row_index(self._idx_colname).with_columns(\n            self._idx_col.mod(n).alias(self._mod_colname)\n        )\n\n    def _get_final_df(self, n: int, expr: pl.Expr) -&gt; pl.DataFrame:\n        return (\n            self._get_df(n)\n            .with_columns(expr)\n            .drop([self._idx_colname, self._mod_colname])\n        )\n\n    def binarize(\n        self, lit1: str, lit2: str, name: str = \"binarized\"\n    ) -&gt; pl.DataFrame:\n        n = 2\n\n        expr = (\n            pl.when(self._mod_col.eq(0))\n            .then(pl.lit(lit1))\n            .otherwise(pl.lit(lit2))\n            .alias(name)\n        )\n\n        self._df = self._get_final_df(n, expr)\n        return self._df\n\n    def trinarize(\n        self, lit1: str, lit2: str, lit3: str, name: str = \"trinarized\"\n    ) -&gt; pl.DataFrame:\n        n = 3\n\n        expr = (\n            pl.when(self._mod_col.eq(0))\n            .then(pl.lit(lit1))\n            .when(self._mod_col.eq(1))\n            .then(pl.lit(lit2))\n            .otherwise(pl.lit(lit3))\n            .alias(name)\n        )\n\n        self._df = self._get_final_df(n, expr)\n        return self._df\n\n    def bucketize(\n        self, lits: list[Any], name: str = \"bucketized\"\n    ) -&gt; pl.DataFrame:\n        n = len(lits)\n\n        # first\n        expr = pl.when(self._mod_col.eq(0)).then(pl.lit(lits[0]))\n\n        # middles\n        for i, one_lit in enumerate(lits[1:-1], start=1):\n            expr = expr.when(self._mod_col.eq(i)).then(pl.lit(one_lit))\n\n        # last\n        expr = expr.otherwise(pl.lit(lits[-1]))\n\n        # alias\n        expr = expr.alias(name)\n\n        self._df = self._get_final_df(n, expr)\n        return self._df\n\n\ndf = (\n    pl.DataFrame({\"n\": [100, 50, 72, 83, 97, 42, 20, 51, 77]})\n    .spt.binarize(\"lightblue\", \"papayawhip\")\n    .spt.trinarize(\"one\", \"two\", \"three\")\n    .spt.bucketize([1, 2, 3, 4])\n    .with_row_index(offset=1)\n)\n\n(\n    GT(df)\n    .tab_style(style=style.fill(pl.col(\"binarized\")), locations=loc.body())\n    .opt_stylize(style=6)\n)\n\n\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/p9-polars-alta-ski-resort/20250412.html",
    "href": "posts/p9-polars-alta-ski-resort/20250412.html",
    "title": "Weekend Challenge – Recreating a Data Visualization with Polars and Plotnine",
    "section": "",
    "text": "This post is part of a visualization recreation challenge using Polars and plotnine, inspired by my earlier work.\nIt marks my first serious dive into plotnine—an impressive library with a bit of a learning curve.\nI’ll walk through the journey I took to recreate the visualization. Some parts may overlap with the earlier post, but I believe that’s acceptable to keep this one self-contained.\nThe final figure, shown below, visualizes temperature trends for the ski season in Alta over the past few decades.\nShow full code\nimport polars as pl\nimport polars.selectors as cs\nfrom highlight_text import ax_text\nfrom matplotlib.axes import Axes\nfrom matplotlib.figure import Figure\n\nfrom plotnine import (\n    aes,\n    element_blank,\n    element_text,\n    geom_line,\n    geom_point,\n    geom_segment,\n    geom_text,\n    ggplot,\n    labs,\n    scale_color_cmap,\n    scale_x_continuous,\n    scale_y_continuous,\n    theme,\n    theme_classic,\n)\n\n# https://github.com/mattharrison/datasets/raw/refs/heads/master/data/alta-noaa-1980-2019.csv\ndata_path = \"alta-noaa-1980-2019.csv\"\ncolumns = [\"DATE\", \"TOBS\"]\nidx_colname = \"DAY_OF_SEASON\"\ntemp_colname = \"temp\"\n\nheading_fontsize = 9.5\nheading_fontweight = \"bold\"\nsubheading_fontsize = 8\nsubheading_fontweight = \"normal\"\nsource_fontsize = 6.5\nsource_fontweight = \"light\"\naxis_fontsize = 7\naxis_fontweight = \"normal\"\nsub_props = {\"fontsize\": subheading_fontsize, \"fontweight\": subheading_fontweight}\n\ngrey = \"#aaaaaa\"\nred = \"#e3120b\"\nblue = \"#0000ff\"\n\n\ndef get_season_expr(col: str = \"DATE\", alias: str = \"SEASON\") -&gt; pl.expr:\n    return (\n        (\n            pl.when((pl.col(col).dt.month().is_between(5, 10, closed=\"both\")))\n            .then(pl.lit(\"Summer \"))\n            .otherwise(pl.lit(\"Ski \"))\n        )\n        .add(\n            pl.when(pl.col(col).dt.month() &lt; 11)\n            .then(pl.col(col).dt.year().cast(pl.String))\n            .otherwise(pl.col(col).dt.year().add(1).cast(pl.String))\n        )\n        .alias(alias)\n    )\n\n\ndef add_day_of_season_expr(\n    col: str = \"DATE\", group_col: str = \"SEASON\", alias: str = \"DAY_OF_SEASON\"\n) -&gt; pl.expr:\n    return (\n        (pl.col(col) - pl.col(col).min()).dt.total_days().over(group_col).alias(alias)\n    )\n\n\ndef tweak_df(\n    data_path: str, columns: list[str], idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    return (\n        pl.scan_csv(data_path)\n        .select(columns)\n        .with_columns(\n            pl.col(\"DATE\").str.to_datetime(),\n            pl.col(\"TOBS\").interpolate(),\n        )\n        .sort(\"DATE\")\n        .with_columns(\n            # Caveat: Cannot be placed in the previous `with_columns()`\n            # due to different statuses of `TOBS`.\n            pl.col(\"TOBS\").rolling_mean(window_size=28, center=True).alias(\"TMEAN\"),\n            get_season_expr(col=\"DATE\", alias=\"SEASON\"),\n        )\n        .with_columns(\n            add_day_of_season_expr(col=\"DATE\", group_col=\"SEASON\", alias=idx_colname)\n        )\n        .collect()\n    )\n\n\ndef plot_temps(_df: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\") -&gt; ggplot:\n    season_temps = _df.filter(pl.col(\"SEASON\").str.contains(\"Ski\")).pivot(\n        \"SEASON\", index=idx_colname, values=\"TMEAN\", aggregate_function=\"first\"\n    )\n\n    # main\n    df_main = season_temps.unpivot(\n        (cs.starts_with(\"Ski\") - cs.by_name(\"Ski 2019\")),\n        index=idx_colname,\n        variable_name=\"year\",\n        value_name=temp_colname,\n    ).select(\n        idx_colname,\n        temp_colname,\n        pl.col(\"year\").str.slice(-4).cast(pl.Int32),\n    )\n\n    # decades\n    decades = [1980, 1990, 2000, 2010]\n    blues = [\"#0055EE\", \"#0033CC\", \"#0011AA\", \"#3377FF\"]\n\n    df_decade = pl.concat(\n        [\n            season_temps.select(\n                idx_colname,\n                pl.mean_horizontal(cs.contains(str(decade)[:-1])).alias(temp_colname),\n                pl.lit(b).alias(\"color\"),\n            )\n            for b, decade in zip(blues, decades)\n        ],\n        how=\"vertical\",\n    )\n\n    # decade points\n    df_decade_pts = (\n        df_decade.group_by(pl.col(\"color\"), maintain_order=True)\n        .agg(\n            pl.col(idx_colname).first().append(pl.col(idx_colname).last()),\n            pl.col(temp_colname).first().append(pl.col(temp_colname).last()),\n        )\n        .explode(idx_colname, temp_colname)\n    )\n\n    # decade annotations\n    decade_annts = (\n        df_decade_pts.filter(pl.col(idx_colname).eq(pl.col(idx_colname).max()))\n        .select(temp_colname)\n        .to_series()\n        .to_list()\n    )\n\n    df_decade_annt = pl.DataFrame(\n        {\n            \"x\": [185] * len(decade_annts),\n            # adjust y position for better appearance\n            \"y\": [\n                decade_annts[0],\n                decade_annts[1] + 0.5,\n                decade_annts[2] - 3,\n                decade_annts[3],\n            ],\n            \"color\": blues,\n            \"label\": decades,\n        }\n    )\n\n    # ski_2019\n    ski_2019 = (\n        season_temps.select(\n            idx_colname, pl.col(\"Ski 2019\").alias(temp_colname)\n        ).drop_nulls()  # \"DAY_OF_SEASON\"=181, \"temp\"=null\n    )\n\n    # ski_2019 points\n    ski_2019_pts = pl.concat([ski_2019.head(1), ski_2019.tail(1)])\n\n    # ggplot\n    return (\n        ggplot(mapping=aes(x=idx_colname, y=temp_colname))\n        # multiple grey lines\n        + geom_line(\n            mapping=aes(color=\"factor(year)\"),\n            data=df_main,\n            alpha=0.2,\n            size=0.5,\n        )\n        # 4 blue lines\n        + geom_line(\n            mapping=aes(fill=\"factor(color)\"),\n            data=df_decade,\n            color=df_decade[\"color\"],\n            size=0.5,\n            lineend=\"round\",\n        )\n        # 2019 red line\n        + geom_line(\n            data=ski_2019,\n            color=red,\n            size=0.8,\n            lineend=\"round\",\n        )\n        # 1 black dashed line for temp=32F\n        + geom_segment(\n            mapping=aes(x=0, xend=200, y=32, yend=32),\n            size=0.5,\n            linetype=\"dashed\",\n        )\n        # start and end dots for 4 blue lines\n        + geom_point(\n            mapping=aes(x=idx_colname, y=temp_colname),\n            data=df_decade_pts,\n            color=df_decade_pts[\"color\"],\n            size=0.2,\n        )\n        # start and end dots for 2019 red line\n        + geom_point(\n            mapping=aes(x=idx_colname, y=temp_colname),\n            data=ski_2019_pts,\n            color=red,\n            size=1,\n        )\n        # annotations for 4 blue lines\n        + geom_text(\n            mapping=aes(x=\"x\", y=\"y\", label=\"label\"),\n            data=df_decade_annt,\n            color=df_decade_annt[\"color\"],\n            size=axis_fontsize,\n            fontweight=axis_fontweight,\n            ha=\"left\",\n            va=\"center\",\n        )\n        + labs(x=idx_colname, y=\"\")\n        + scale_x_continuous(\n            breaks=[0, 50, 100, 150],\n            limits=(0, 200),\n            expand=(0, 10, 0, 15),\n        )\n        + scale_y_continuous(breaks=[10, 32, 40], limits=(10, 70), expand=(0, 0))\n        + scale_color_cmap(\"Greys\", guide=None)\n    )\n\n\ndef points_to_inches(points):\n    return points / 72\n\n\ndef themify(p: ggplot) -&gt; Figure:\n    figsize = (160, 165)  # pts\n    figsize_inches = [points_to_inches(dim) for dim in figsize]\n\n    return (\n        p\n        + theme_classic()\n        + theme(\n            axis_line_y=element_blank(),\n            axis_title_x=element_text(weight=axis_fontweight, size=axis_fontsize),\n            axis_title_y=element_text(weight=axis_fontweight, size=axis_fontsize),\n            axis_text_x=element_text(color=\"black\"),\n            axis_text_y=element_text(color=\"black\"),\n            dpi=300,\n            figure_size=figsize_inches,\n            aspect_ratio=2 / 3,\n            text=element_text(\"Roboto\"),\n        )\n    ).draw(show=False)\n\n\ndef add_ax_text(ax: Axes) -&gt; Axes:\n    ax_text(\n        s=\"&lt;Alta Ski Resort&gt;\\n&lt;Temperature trends by &gt;\\n&lt;decade&gt;&lt; and &gt;&lt;2019&gt;\",\n        x=-5,\n        y=55,\n        fontsize=heading_fontsize,\n        ax=ax,\n        va=\"bottom\",\n        ha=\"left\",\n        zorder=5,\n        highlight_textprops=[\n            {\"fontsize\": heading_fontsize, \"fontweight\": heading_fontweight},\n            sub_props,\n            {\"color\": blue, **sub_props},\n            sub_props,\n            {\"color\": red, **sub_props},\n        ],\n    )\n\n    ax.text(\n        0,\n        -10,\n        \"Source: NOAA\",\n        fontsize=source_fontsize,\n        fontweight=source_fontweight,\n        color=grey,\n    )\n    return ax\n\n\ndf = tweak_df(data_path, columns, idx_colname)\np = plot_temps(df, idx_colname)\nfig = themify(p)\nax = fig.axes[0]\nax = add_ax_text(ax)\nfig"
  },
  {
    "objectID": "posts/p9-polars-alta-ski-resort/20250412.html#data-processing-pipeline",
    "href": "posts/p9-polars-alta-ski-resort/20250412.html#data-processing-pipeline",
    "title": "Weekend Challenge – Recreating a Data Visualization with Polars and Plotnine",
    "section": "Data Processing Pipeline",
    "text": "Data Processing Pipeline\nBelow is the data pipeline used to generate the DataFrame for the upcoming visualization stage:\ndata_path = \"alta-noaa-1980-2019.csv\"\ncolumns = [\"DATE\", \"TOBS\"]\nidx_colname = \"DAY_OF_SEASON\"\ntemp_colname = \"temp\"\n\n\ndef tweak_df(data_path: str, columns: list[str], idx_colname: str = \"DAY_OF_SEASON\"):\n    return (\n        pl.scan_csv(data_path)\n1        .select(columns)\n        .with_columns(\n2            pl.col(\"DATE\").str.to_datetime(),\n3            pl.col(\"TOBS\").interpolate(),\n        )\n        .sort(\"DATE\")\n        .with_columns(\n            # Caveat: Cannot be placed in the previous `with_columns()`\n            # due to different statuses of `TOBS`.\n4            pl.col(\"TOBS\").rolling_mean(window_size=28, center=True).alias(\"TMEAN\"),\n5            get_season_expr(col=\"DATE\", alias=\"SEASON\"),\n        )\n        .with_columns(\n6            add_day_of_season_expr(col=\"DATE\", group_col=\"SEASON\", alias=idx_colname)\n        )\n        .collect()\n    )\n\n1\n\nSelect the DATE column (dates) and TOBS column (recorded temperatures in Fahrenheit).\n\n2\n\nConvert the DATE column to a datetime format.\n\n3\n\nPerform interpolation on the TOBS column.\n\n4\n\nCompute a 28-day rolling average for TOBS.\n\n5\n\nUse get_season_expr() to categorize each date into a SEASON.\n\n6\n\nApply add_day_of_season_expr() to calculate DAY_OF_SEASON, representing days elapsed since the start of the season.\n\n\nThe first three steps involve straightforward Polars expressions. In the following two sub-sections, we’ll dive deeper into steps 5 and 6.\n\nCategorizing Dates into Summer and Ski Seasons\nTo analyze seasonal trends, we classify dates into two categories:\n\nSummer: Covers May through October.\n\nSki: Covers November through April.\n\nIf a date falls in November or December, it is assigned to the following year’s season. For example, 2015-10-31 is categorized as Summer 2015, while 2015-11-01 belongs to Ski 2016.\nTo implement this logic, we define get_season_expr(), which leverages Polars’ when-then-otherwise expressions to determine the season and year.\ndef get_season_expr(col: str = \"DATE\", alias: str = \"SEASON\") -&gt; pl.expr:\n    return (\n        (\n            pl.when((pl.col(col).dt.month().is_between(5, 10, closed=\"both\")))\n            .then(pl.lit(\"Summer \"))\n            .otherwise(pl.lit(\"Ski \"))\n        )\n        .add(\n            pl.when(pl.col(col).dt.month() &lt; 11)\n            .then(pl.col(col).dt.year().cast(pl.String))\n            .otherwise(pl.col(col).dt.year().add(1).cast(pl.String))\n        )\n        .alias(alias)\n    )\nIn this function:\n\nIf the month is between May and October, the function assigns \"Summer \". Otherwise, it assigns \"Ski \" (with a trailing space for concatenation).\n\nThe year is determined based on the month: dates from January to October retain their current year, while those in November and December are shifted to the next year.\n\nBy applying this function, we can add a SEASON column to a DataFrame, ensuring each date is categorized correctly.\n\n\nCalculating the Total Days for Each Season\nOnce we have the seasonal categories, we calculate DAY_OF_SEASON, which tracks the number of days elapsed within each season. This is achieved using the pl.expr.over() expression, which operates similarly to Pandas’ groupby().transform(), applying transformations within groups.\ndef add_day_of_season_expr(\n    col: str = \"DATE\", group_col: str = \"SEASON\", alias: str = \"DAY_OF_SEASON\"\n) -&gt; pl.expr:\n    return (\n        (pl.col(col) - pl.col(col).min()).dt.total_days().over(group_col).alias(alias)\n    )"
  },
  {
    "objectID": "posts/p9-polars-alta-ski-resort/20250412.html#visualizing-temperature-trends-with-plotnine",
    "href": "posts/p9-polars-alta-ski-resort/20250412.html#visualizing-temperature-trends-with-plotnine",
    "title": "Weekend Challenge – Recreating a Data Visualization with Polars and Plotnine",
    "section": "Visualizing Temperature Trends with Plotnine",
    "text": "Visualizing Temperature Trends with Plotnine\nWith the data prepared, we now turn our focus to visualization. The plot_temps() function is relatively long, so we’ll walk through it step by step. Ultimately, we’ll construct several intermediate DataFrames and use them to build a ggplot object for rendering.\n\nReshaping the Main DataFrame\nWe begin by filtering the dataset to include only rows corresponding to Ski seasons. Then, using pl.DataFrame.pivot() and pl.DataFrame.unpivot(), we reshape the main DataFrame.\ndef plot_temps(\n    _df: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; ggplot:\n    season_temps = _df.filter(pl.col(\"SEASON\").str.contains(\"Ski\")).pivot(\n        \"SEASON\", index=idx_colname, values=\"TMEAN\", aggregate_function=\"first\"\n    )\n\n    df_main = season_temps.unpivot(\n        (cs.starts_with(\"Ski\") - cs.by_name(\"Ski 2019\")),\n        index=idx_colname,\n        variable_name=\"year\",\n        value_name=temp_colname,\n    ).select(\n        idx_colname,\n        temp_colname,\n        pl.col(\"year\").str.slice(-4).cast(pl.Int32),\n    )\n    ...\nNote: We intentionally exclude Ski 2019 here, as it will be handled separately later.\nPreview of df_main:\nshape: (7_098, 3)\n┌───────────────┬───────────┬──────┐\n│ DAY_OF_SEASON ┆ temp      ┆ year │\n│ ---           ┆ ---       ┆ ---  │\n│ i64           ┆ f64       ┆ i32  │\n╞═══════════════╪═══════════╪══════╡\n│ 0             ┆ null      ┆ 1980 │\n│ 1             ┆ null      ┆ 1980 │\n│ 2             ┆ null      ┆ 1980 │\n│ 3             ┆ null      ┆ 1980 │\n│ 4             ┆ null      ┆ 1980 │\n│ …             ┆ …         ┆ …    │\n│ 177           ┆ 44.0      ┆ 2018 │\n│ 178           ┆ 44.464286 ┆ 2018 │\n│ 179           ┆ 44.607143 ┆ 2018 │\n│ 180           ┆ 44.142857 ┆ 2018 │\n│ 181           ┆ null      ┆ 2018 │\n└───────────────┴───────────┴──────┘\n\n\nBuilding a DataFrame for Decade Averages\nTo reveal long-term patterns, we compute average temperature trends by decade. Each decade will be represented by a separate line with a distinct color.\ndef plot_temps(df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\") -&gt; ggplot:\n    ...\n    decades = [1980, 1990, 2000, 2010]\n    blues = [\"#0055EE\", \"#0033CC\", \"#0011AA\", \"#3377FF\"]\n\n    df_decade = pl.concat(\n        [\n            season_temps.select(\n                idx_colname,\n                pl.mean_horizontal(cs.contains(str(decade)[:-1])).alias(temp_colname),\n                pl.lit(b).alias(\"color\"),\n            )\n            for b, decade in zip(blues, decades)\n        ],\n        how=\"vertical\",\n    )\nPreview of df_decade:\nshape: (728, 3)\n┌───────────────┬───────────┬─────────┐\n│ DAY_OF_SEASON ┆ temp      ┆ color   │\n│ ---           ┆ ---       ┆ ---     │\n│ i64           ┆ f64       ┆ str     │\n╞═══════════════╪═══════════╪═════════╡\n│ 0             ┆ 32.704365 ┆ #0055EE │\n│ 1             ┆ 32.156746 ┆ #0055EE │\n│ 2             ┆ 31.875    ┆ #0055EE │\n│ 3             ┆ 31.561508 ┆ #0055EE │\n│ 4             ┆ 31.041667 ┆ #0055EE │\n│ …             ┆ …         ┆ …       │\n│ 177           ┆ 39.275    ┆ #3377FF │\n│ 178           ┆ 39.639286 ┆ #3377FF │\n│ 179           ┆ 40.092857 ┆ #3377FF │\n│ 180           ┆ 40.653571 ┆ #3377FF │\n│ 181           ┆ 41.428571 ┆ #3377FF │\n└───────────────┴───────────┴─────────┘\n\n\nAnnotating Decade Lines\nTo enhance readability, we annotate each decade line in two ways: by marking the start and end points and by adding labels to the line endings. For this purpose, we create two separate DataFrames.\ndef plot_temps(df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\") -&gt; ggplot:\n    ...\n    df_decade_pts = (\n        df_decade.group_by(pl.col(\"color\"), maintain_order=True)\n        .agg(\n            pl.col(idx_colname).first().append(pl.col(idx_colname).last()),\n            pl.col(temp_colname).first().append(pl.col(temp_colname).last()),\n        )\n        .explode(idx_colname, temp_colname)\n    )\n\n    decade_annts = (\n        df_decade_pts.filter(pl.col(idx_colname).eq(pl.col(idx_colname).max()))\n        .select(temp_colname)\n        .to_series()\n        .to_list()\n    )\n\n    df_decade_annt = pl.DataFrame(\n        {\n            \"x\": [185] * len(decade_annts),\n            # adjust y position for better appearance\n            \"y\": [\n                decade_annts[0],\n                decade_annts[1] + 0.5,\n                decade_annts[2] - 3,\n                decade_annts[3],\n            ],\n            \"color\": blues,\n            \"label\": decades,\n        }\n    )\nPreview of df_decade_pts (start and end points):\nshape: (8, 3)\n┌─────────┬───────────────┬───────────┐\n│ color   ┆ DAY_OF_SEASON ┆ temp      │\n│ ---     ┆ ---           ┆ ---       │\n│ str     ┆ i64           ┆ f64       │\n╞═════════╪═══════════════╪═══════════╡\n│ #0055EE ┆ 0             ┆ 32.704365 │\n│ #0055EE ┆ 181           ┆ 34.357143 │\n│ #0033CC ┆ 0             ┆ 34.851786 │\n│ #0033CC ┆ 181           ┆ 44.535714 │\n│ #0011AA ┆ 0             ┆ 35.719643 │\n│ #0011AA ┆ 181           ┆ 40.77381  │\n│ #3377FF ┆ 0             ┆ 35.380357 │\n│ #3377FF ┆ 181           ┆ 41.428571 │\n└─────────┴───────────────┴───────────┘\nPreview of df_decade_annt (annotation labels):\nshape: (4, 4)\n┌─────┬───────────┬─────────┬───────┐\n│ x   ┆ y         ┆ color   ┆ label │\n│ --- ┆ ---       ┆ ---     ┆ ---   │\n│ i64 ┆ f64       ┆ str     ┆ i64   │\n╞═════╪═══════════╪═════════╪═══════╡\n│ 185 ┆ 34.357143 ┆ #0055EE ┆ 1980  │\n│ 185 ┆ 45.035714 ┆ #0033CC ┆ 1990  │\n│ 185 ┆ 37.77381  ┆ #0011AA ┆ 2000  │\n│ 185 ┆ 41.428571 ┆ #3377FF ┆ 2010  │\n└─────┴───────────┴─────────┴───────┘\n\n\nIsolating the 2019 Ski Season\nWe separate out the 2019 Ski season so that we can highlight it independently in the final visualization.\ndef plot_temps(df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\") -&gt; ggplot:\n    ...\n    ski_2019 = (\n        season_temps.select(\n            idx_colname, pl.col(\"Ski 2019\").alias(temp_colname)\n        ).drop_nulls()  # \"DAY_OF_SEASON\"=181, \"temp\"=null\n    )\nPreview of ski_2019:\nshape: (181, 2)\n┌───────────────┬───────────┐\n│ DAY_OF_SEASON ┆ temp      │\n│ ---           ┆ ---       │\n│ i64           ┆ f64       │\n╞═══════════════╪═══════════╡\n│ 0             ┆ 33.214286 │\n│ 1             ┆ 32.892857 │\n│ 2             ┆ 32.25     │\n│ 3             ┆ 31.142857 │\n│ 4             ┆ 30.357143 │\n│ …             ┆ …         │\n│ 176           ┆ 38.607143 │\n│ 177           ┆ 39.285714 │\n│ 178           ┆ 39.964286 │\n│ 179           ┆ 40.464286 │\n│ 180           ┆ 41.25     │\n└───────────────┴───────────┘\nWe also prepare a small DataFrame to annotate the start and end points of the 2019 line:\nPreview of ski_2019_pts:\ndef plot_temps(df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\") -&gt; ggplot:\n    ...\n    ski_2019_pts = pl.concat([ski_2019.head(1), ski_2019.tail(1)])\n\n\nCreating the ggplot Object\nWe now bring everything together into a single ggplot object:\ndef plot_temps(df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\") -&gt; ggplot:\n    ...\n    return (\n1        ggplot(mapping=aes(x=idx_colname, y=temp_colname))\n        # multiple grey lines\n        + geom_line(\n2            mapping=aes(color=\"factor(year)\"),\n            data=df_main,\n            alpha=0.2,\n            size=0.5,\n        )\n        # 4 blue lines\n        + geom_line(\n3            mapping=aes(fill=\"factor(color)\"),\n            data=df_decade,\n            color=df_decade[\"color\"],\n            size=0.5,\n4            lineend=\"round\",\n        )\n        # 2019 red line\n        + geom_line(\n            data=ski_2019,\n            color=red,\n            size=0.8,\n            lineend=\"round\",\n        )\n        # 1 black dashed line for temp=32F\n5        + geom_segment(\n            mapping=aes(x=0, xend=200, y=32, yend=32),\n            size=0.5,\n            linetype=\"dashed\",\n        )\n        # start and end dots for 4 blue lines\n        + geom_point(\n            mapping=aes(x=idx_colname, y=temp_colname),\n            data=df_decade_pts,\n            color=df_decade_pts[\"color\"],\n            size=0.2,\n        )\n        # start and end dots for 2019 red line\n        + geom_point(\n            mapping=aes(x=idx_colname, y=temp_colname),\n            data=ski_2019_pts,\n            color=red,\n            size=1,\n        )\n        # annotations for 4 blue lines\n        + geom_text(\n6            mapping=aes(x=\"x\", y=\"y\", label=\"label\"),\n            data=df_decade_annt,\n            color=df_decade_annt[\"color\"],\n            size=axis_fontsize,\n            fontweight=axis_fontweight,\n            ha=\"left\",\n            va=\"center\",\n        )\n        + labs(x=idx_colname, y=\"\")\n        + scale_x_continuous(\n            breaks=[0, 50, 100, 150],\n            limits=(0, 200),\n            expand=(0, 10, 0, 15),\n        )\n        + scale_y_continuous(breaks=[10, 32, 40], limits=(10, 70), expand=(0, 0))\n        + scale_color_cmap(\"Greys\", guide=None)\n    )\n\n1\n\nWe define the default aesthetic mapping in ggplot() to avoid repetition in later layers.\n\n2\n\nfactor(year) is mapped to color=, and the Greys colormap is applied using scale_color_cmap()—a very convenient way to show progression.\n\n3\n\nFor the decade lines, factor(color) is mapped to the fill= aesthetic. Colors are controlled via a color column in the dataframe—an effective trick.\n\n4\n\nThe lineend= parameter is useful if you don’t plan to mark endpoints with dots.\n\n5\n\nUsing geom_hline() would extend the line infinitely in both directions. In this case, we used geom_segment() to constrain the line.\n\n6\n\nThe label= aesthetic in geom_text() is mapped from the label column in df_decade_annt."
  },
  {
    "objectID": "posts/p9-polars-alta-ski-resort/20250412.html#touchups",
    "href": "posts/p9-polars-alta-ski-resort/20250412.html#touchups",
    "title": "Weekend Challenge – Recreating a Data Visualization with Polars and Plotnine",
    "section": "Touchups",
    "text": "Touchups\n\nAdding a Theme\nWe apply a custom theme using the themify() function, adjusting various themeable elements to refine the plot’s appearance:\ndef points_to_inches(points):\n    return points / 72\n\n\ndef themify(p: ggplot) -&gt; Figure:\n    figsize = (160, 165)  # pts\n    figsize_inches = [points_to_inches(dim) for dim in figsize]\n\n    return (\n        p\n        + theme_classic()\n        + theme(\n            axis_line_y=element_blank(),\n            axis_title_x=element_text(weight=axis_fontweight, size=axis_fontsize),\n            axis_title_y=element_text(weight=axis_fontweight, size=axis_fontsize),\n            axis_text_x=element_text(color=\"black\"),\n            axis_text_y=element_text(color=\"black\"),\n            dpi=300,\n            figure_size=figsize_inches,\n            aspect_ratio=2 / 3,\n            text=element_text(\"Roboto\"),\n        )\n    ).draw(show=False)\n\n\nAdding a Title and Source Note\nFor the title, we use ax_text() from the HighlightText library. It allows inline text highlighting using &lt; &gt;, letting us emphasize specific parts of the title like &lt;Alta Ski Resort&gt;, &lt;Temperature trends by &gt;, &lt;decade&gt;, &lt; and &gt;, and &lt;2019&gt; with customized styles.\nTo add a source note, we simply use Matplotlib’s ax.text():\ndef add_ax_text(ax: Axes) -&gt; Axes:\n    ax_text(\n        s=\"&lt;Alta Ski Resort&gt;\\n&lt;Temperature trends by &gt;\\n&lt;decade&gt;&lt; and &gt;&lt;2019&gt;\",\n        x=-5,\n        y=55,\n        fontsize=heading_fontsize,\n        ax=ax,\n        va=\"bottom\",\n        ha=\"left\",\n        zorder=5,\n        highlight_textprops=[\n            {\"fontsize\": heading_fontsize, \"fontweight\": heading_fontweight},\n            sub_props,\n            {\"color\": blue, **sub_props},\n            sub_props,\n            {\"color\": red, **sub_props},\n        ],\n    )\n\n    ax.text(\n        0,\n        -10,\n        \"Source: NOAA\",\n        fontsize=source_fontsize,\n        fontweight=source_fontweight,\n        color=grey,\n    )\n    return ax"
  },
  {
    "objectID": "posts/p9-polars-alta-ski-resort/20250412.html#rendering-the-plot",
    "href": "posts/p9-polars-alta-ski-resort/20250412.html#rendering-the-plot",
    "title": "Weekend Challenge – Recreating a Data Visualization with Polars and Plotnine",
    "section": "Rendering the Plot",
    "text": "Rendering the Plot\nNow we put everything together and render the final plot. A key trick here is retrieving the ax object using fig.axes[0], which allows us to apply both HighlightText and regular Matplotlib functions.\ndf = tweak_df(data_path, columns, idx_colname)\np = plot_temps(df, idx_colname)\nfig = themify(p)\nax = fig.axes[0]\nax = add_ax_text(ax)\nfig"
  },
  {
    "objectID": "posts/p9-polars-alta-ski-resort/20250412.html#takeaways",
    "href": "posts/p9-polars-alta-ski-resort/20250412.html#takeaways",
    "title": "Weekend Challenge – Recreating a Data Visualization with Polars and Plotnine",
    "section": "Takeaways",
    "text": "Takeaways\nWrapping up this post, I’ve come to appreciate how powerful the plotnine library truly is. While its aesthetic system requires a bit of mental shift, it offers a clean, expressive way to build layered visualizations.\nOne key takeaway for me is that each layer can operate on its own dataset, which adds a lot of flexibility. What I enjoyed most, though, is the theme system—it makes it easy to define a consistent visual style that can be reused across different plots.\nOne limitation I ran into was the lack of a plotnine-native alternative to pli.subplot_mosaic(). This feature allows for more granular layout control—for example, dividing the figure into separate axes with custom height ratios for the title, main plot, and source note using gridspec_kw={\"height_ratios\": [6, 12, 1]}.\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/django-allauth-resend/20241223.html",
    "href": "posts/django-allauth-resend/20241223.html",
    "title": "Exploring Resend SMTP Service with Django",
    "section": "",
    "text": "This post demonstrates how to integrate Resend with django-allauth seamlessly in a Django project. If you’re looking to use Resend for sending emails via Django, refer to the repo provided by Resend."
  },
  {
    "objectID": "posts/django-allauth-resend/20241223.html#preparations-for-django",
    "href": "posts/django-allauth-resend/20241223.html#preparations-for-django",
    "title": "Exploring Resend SMTP Service with Django",
    "section": "Preparations for Django",
    "text": "Preparations for Django\n\nCreate a Virtual Environment\nStart by creating a virtual environment using uv and activating it:\nuv venv venv\nsource venv/bin/activate\n\n\nInstall Required Packages\nCreate a requirements.txt file and add the necessary dependencies:\ndjango\nenvirons[django]\ndjango-allauth\nInstall the packages via uv:\nuv pip install -r requirements.txt\n\n\nSet Up a Django Project\nUse the django-admin command to create a project named core:\ndjango-admin startproject core .\n\n\nConfigure Environment Variables\nCreate a .env file with the following content:\nDEFAULT_FROM_EMAIL=\nRESEND_SMTP_HOST=smtp.resend.com\nRESEND_SMTP_USERNAME=resend\nRESEND_API_KEY=\nRESEND_SMTP_PORT=587\nRESEND_USE_TLS=True\nThe next sections explain how to obtain DEFAULT_FROM_EMAIL and RESEND_API_KEY."
  },
  {
    "objectID": "posts/django-allauth-resend/20241223.html#preparations-for-resend",
    "href": "posts/django-allauth-resend/20241223.html#preparations-for-resend",
    "title": "Exploring Resend SMTP Service with Django",
    "section": "Preparations for Resend",
    "text": "Preparations for Resend\n\nVerify Your Domain\nFollow the Resend documentation to verify your domain. Once verified, you can send emails using an address like user@send.yourdomain.com.\n\nYou control the prefix before @, as ownership of the domain has been confirmed.\n\nAdd your chosen email to DEFAULT_FROM_EMAIL in the .env file.\n\n\n\nObtain an API Key\nGenerate an API key via the Resend API Keys page and add it to the RESEND_API_KEY field in your .env file."
  },
  {
    "objectID": "posts/django-allauth-resend/20241223.html#django-scaffold",
    "href": "posts/django-allauth-resend/20241223.html#django-scaffold",
    "title": "Exploring Resend SMTP Service with Django",
    "section": "Django Scaffold",
    "text": "Django Scaffold\nFollow the quick start guide from django-allauth to configure the project with minimal setup.\n\nModify core/urls.py\nInclude django-allauth routes and define a homepage route:\n# core/urls.py\n\nfrom django.contrib import admin\nfrom django.urls import path, include\nfrom . import views\n\nurlpatterns = [\n    path(\"admin/\", admin.site.urls),\n    path(\"accounts/\", include(\"allauth.urls\")),  # added\n    path(\"\", views.index, name=\"home\"),  # added\n]\n\n\nAdd core/views.py\nDefine the homepage with a link to the signup URL provided by django-allauth:\nfrom django.http import HttpResponse\nfrom django.urls import reverse\n\n\ndef index(request):\n    signup_url = reverse(\"account_signup\")\n    return HttpResponse(f'&lt;a href=\"{signup_url}\"&gt;Hello, please Sign Up here!&lt;/a&gt;')\n\n\nModify core/settings.py\n\nRead Environment Variables\n# core/settings.py\n\nfrom environs import Env\n\nenv = Env()\nenv.read_env()\n\n\nUpdate INSTALLED_APPS\n# core/settings.py\n\nINSTALLED_APPS = [\n    ...\n    \"allauth\",  # added\n    \"allauth.account\",  # added\n]\n\n\nUpdate MIDDLEWARE\n# core/settings.py\n\nMIDDLEWARE = [\n    \"django.middleware.security.SecurityMiddleware\",\n    \"django.contrib.sessions.middleware.SessionMiddleware\",\n    \"django.middleware.common.CommonMiddleware\",\n    \"django.middleware.csrf.CsrfViewMiddleware\",\n    \"django.contrib.auth.middleware.AuthenticationMiddleware\",\n    \"django.contrib.messages.middleware.MessageMiddleware\",\n    \"allauth.account.middleware.AccountMiddleware\",  # added\n    ...\n]\n\n\nConfigure Email Backend and Authentication Backends\n# core/settings.py\n\nEMAIL_BACKEND = \"django.core.mail.backends.smtp.EmailBackend\"\n\nAUTHENTICATION_BACKENDS = [\n    \"django.contrib.auth.backends.ModelBackend\",\n    \"allauth.account.auth_backends.AuthenticationBackend\",\n]\n\n\nDefine Login and Logout Redirect URLs\nHere, we define only ACCOUNT_LOGOUT_REDIRECT_URL because django-allauth overwrites LOGOUT_REDIRECT_URL.\nLOGIN_REDIRECT_URL = \"home\"\nACCOUNT_LOGOUT_REDIRECT_URL = \"home\"\n\n\nOptional Preference Settings\nOpinionated configurations for a simplified signup and email-based login:\nACCOUNT_SIGNUP_PASSWORD_ENTER_TWICE = False\nACCOUNT_USERNAME_REQUIRED = False\nACCOUNT_AUTHENTICATION_METHOD = \"email\"\nACCOUNT_EMAIL_REQUIRED = True\nACCOUNT_UNIQUE_EMAIL = True\n\n\nDefine Resend Variables\nDEFAULT_FROM_EMAIL = env(\"DEFAULT_FROM_EMAIL\")\nRESEND_SMTP_HOST = env(\"RESEND_SMTP_HOST\")\nRESEND_SMTP_USERNAME = env(\"RESEND_SMTP_USERNAME\")\nRESEND_API_KEY = env(\"RESEND_API_KEY\")\nRESEND_SMTP_PORT = env.int(\"RESEND_SMTP_PORT\")\nRESEND_USE_TLS = env.bool(\"RESEND_USE_TLS\")\n\n\nMap Resend Variables to Django Email Variables\nDelegate Django email settings to Resend environment variables:\nEMAIL_HOST = RESEND_SMTP_HOST\nEMAIL_HOST_USER = RESEND_SMTP_USERNAME\nEMAIL_HOST_PASSWORD = RESEND_API_KEY\nEMAIL_PORT = RESEND_SMTP_PORT\nEMAIL_USE_TLS = RESEND_USE_TLS"
  },
  {
    "objectID": "posts/django-allauth-resend/20241223.html#tryout",
    "href": "posts/django-allauth-resend/20241223.html#tryout",
    "title": "Exploring Resend SMTP Service with Django",
    "section": "Tryout",
    "text": "Tryout\nMigrate the database and run the development server with the following commands:\npython manage.py migrate\npython manage.py runserver\nNow, go to http://127.0.0.1:8000/ and click the sign-up link. You should see the signup page. After submitting the form, you will be redirected to the homepage.\nNext, check your inbox for an email with the subject [127.0.0.1:8000] Please Confirm Your Email Address.\nThe email will contain a confirmation link. Click the link, then click the confirmation button, and you’re all set for user registration!\n\n\n\n\n\n\nTip\n\n\n\nIf you encounter issues during configuration, the Resend logs can be a helpful resource, as they provide the request body, response body, and status code."
  },
  {
    "objectID": "posts/django-allauth-resend/20241223.html#final-words",
    "href": "posts/django-allauth-resend/20241223.html#final-words",
    "title": "Exploring Resend SMTP Service with Django",
    "section": "Final Words",
    "text": "Final Words\nThe configuration is straightforward, and it’s great that Resend offers SMTP services. The modern dashboard operates smoothly, and the well-documented resources make it easy for developers to find needed information. So far, the user experience has been positive, and I look forward to using it in real projects.\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/style-table-body/20250124.html",
    "href": "posts/style-table-body/20250124.html",
    "title": "Three Approaches to Styling the Table Body in Great Tables",
    "section": "",
    "text": "This post demonstrates three approaches to styling the table body:\nLet’s dive in."
  },
  {
    "objectID": "posts/style-table-body/20250124.html#preparations",
    "href": "posts/style-table-body/20250124.html#preparations",
    "title": "Three Approaches to Styling the Table Body in Great Tables",
    "section": "Preparations",
    "text": "Preparations\nWe’ll use the built-in dataset gtcars to create a Polars DataFrame. First, we’ll select the columns mfr, drivetrain, year, and hp to create a small pivoted table named df_mini. Then, we’ll pass df_mini to the GT object and use GT.tab_stub(), setting drivetrain as rowname_col= and mfr as groupname_col= to create the table gt, as shown below:\n\n\nCode\nimport polars as pl\nfrom great_tables import GT, loc, style\nfrom great_tables.data import gtcars\nfrom polars import selectors as cs\n\nyear_cols = [\"2014\", \"2015\", \"2016\", \"2017\"]\ndf_mini = (\n    pl.from_pandas(gtcars)\n    .filter(pl.col(\"mfr\").is_in([\"Ferrari\", \"Lamborghini\", \"BMW\"]))\n    .sort(\"drivetrain\")\n    .pivot(on=\"year\", index=[\"mfr\", \"drivetrain\"], values=\"hp\", aggregate_function=\"mean\")\n    .select([\"mfr\", \"drivetrain\", *year_cols])\n)\n\ngt = GT(df_mini).tab_stub(rowname_col=\"drivetrain\", groupname_col=\"mfr\").opt_stylize()\ngt\n\n\n\n\n\n\n\n\n  \n  2014\n  2015\n  2016\n  2017\n\n\n\n  \n    Ferrari\n  \n  \n    awd\n    None\n    652.0\n    None\n    680.0\n  \n  \n    rwd\n    562.0\n    678.4\n    661.0\n    None\n  \n  \n    Lamborghini\n  \n  \n    awd\n    None\n    700.0\n    None\n    None\n  \n  \n    rwd\n    550.0\n    610.0\n    None\n    None\n  \n  \n    BMW\n  \n  \n    awd\n    None\n    None\n    357.0\n    None\n  \n  \n    rwd\n    None\n    None\n    465.0\n    None\n  \n\n\n\n\n\n\n        \n\n\nThe numbers in the cells represent the average horsepower for each combination of mfr and drivetrain for a specific year.\nIn the following section, we’ll demonstrate three different ways to highlight the cell text in red if the average horsepower exceeds 650."
  },
  {
    "objectID": "posts/style-table-body/20250124.html#using-a-for-loop-repeatedly-call-gt.tab_style-for-each-column",
    "href": "posts/style-table-body/20250124.html#using-a-for-loop-repeatedly-call-gt.tab_style-for-each-column",
    "title": "Three Approaches to Styling the Table Body in Great Tables",
    "section": "Using a For-Loop: Repeatedly Call GT.tab_style() for Each Column",
    "text": "Using a For-Loop: Repeatedly Call GT.tab_style() for Each Column\nThe most intuitive way is to call GT.tab_style() for each column. Here’s how:\n\n1gt1 = gt\nfor col in year_cols:\n    gt1 = gt1.tab_style(\n        style=style.text(color=\"red\"),\n        locations=loc.body(columns=col, rows=pl.col(col).gt(650))\n    )\ngt1\n\n\n1\n\nSince we want to keep gt intact for later use, we will modify gt1 in this approach instead.\n\n\n\n\n\n\n\n\n\n\n  \n  2014\n  2015\n  2016\n  2017\n\n\n\n  \n    Ferrari\n  \n  \n    awd\n    None\n    652.0\n    None\n    680.0\n  \n  \n    rwd\n    562.0\n    678.4\n    661.0\n    None\n  \n  \n    Lamborghini\n  \n  \n    awd\n    None\n    700.0\n    None\n    None\n  \n  \n    rwd\n    550.0\n    610.0\n    None\n    None\n  \n  \n    BMW\n  \n  \n    awd\n    None\n    None\n    357.0\n    None\n  \n  \n    rwd\n    None\n    None\n    465.0\n    None"
  },
  {
    "objectID": "posts/style-table-body/20250124.html#utilizing-the-locations-parameter-in-gt.tab_style-pass-a-list-of-loc.body-objects",
    "href": "posts/style-table-body/20250124.html#utilizing-the-locations-parameter-in-gt.tab_style-pass-a-list-of-loc.body-objects",
    "title": "Three Approaches to Styling the Table Body in Great Tables",
    "section": "Utilizing the locations= Parameter in GT.tab_style(): Pass a List of loc.body() Objects",
    "text": "Utilizing the locations= Parameter in GT.tab_style(): Pass a List of loc.body() Objects\nA more concise method is to pass a list of loc.body() objects to the locations= parameter in GT.tab_style(), as shown below:\n\n(\n    gt.tab_style(\n        style=style.text(color=\"red\"),\n        locations=[\n            loc.body(columns=col, rows=pl.col(col).gt(650))\n            for col in year_cols\n        ],\n    )\n)\n\n\n\n\n\n\n\n  \n  2014\n  2015\n  2016\n  2017\n\n\n\n  \n    Ferrari\n  \n  \n    awd\n    None\n    652.0\n    None\n    680.0\n  \n  \n    rwd\n    562.0\n    678.4\n    661.0\n    None\n  \n  \n    Lamborghini\n  \n  \n    awd\n    None\n    700.0\n    None\n    None\n  \n  \n    rwd\n    550.0\n    610.0\n    None\n    None\n  \n  \n    BMW\n  \n  \n    awd\n    None\n    None\n    357.0\n    None\n  \n  \n    rwd\n    None\n    None\n    465.0\n    None"
  },
  {
    "objectID": "posts/style-table-body/20250124.html#leveraging-the-mask-parameter-in-loc.body-use-polars-expressions-for-streamlined-styling",
    "href": "posts/style-table-body/20250124.html#leveraging-the-mask-parameter-in-loc.body-use-polars-expressions-for-streamlined-styling",
    "title": "Three Approaches to Styling the Table Body in Great Tables",
    "section": "Leveraging the mask= Parameter in loc.body(): Use Polars Expressions for Streamlined Styling",
    "text": "Leveraging the mask= Parameter in loc.body(): Use Polars Expressions for Streamlined Styling\nThe most modern approach (0.16.0) is to pass a Polars expression to the mask= parameter in loc.body(), as illustrated here:\n\n(\n    gt.tab_style(\n        style=style.text(color=\"red\"),\n        locations=loc.body(mask=cs.numeric().gt(650))\n    )\n)\n\n\n\n\n\n\n\n  \n  2014\n  2015\n  2016\n  2017\n\n\n\n  \n    Ferrari\n  \n  \n    awd\n    None\n    652.0\n    None\n    680.0\n  \n  \n    rwd\n    562.0\n    678.4\n    661.0\n    None\n  \n  \n    Lamborghini\n  \n  \n    awd\n    None\n    700.0\n    None\n    None\n  \n  \n    rwd\n    550.0\n    610.0\n    None\n    None\n  \n  \n    BMW\n  \n  \n    awd\n    None\n    None\n    357.0\n    None\n  \n  \n    rwd\n    None\n    None\n    465.0\n    None\n  \n\n\n\n\n\n\n        \n\n\nIn this example, loc.body() is smart enough to automatically target the rows where the cell value exceeds 650 for each numerical column. In general, you can think of mask= as a syntactic sugar that Great Tables provides to save you from having to manually loop through the columns."
  },
  {
    "objectID": "posts/style-table-body/20250124.html#final-words",
    "href": "posts/style-table-body/20250124.html#final-words",
    "title": "Three Approaches to Styling the Table Body in Great Tables",
    "section": "Final Words",
    "text": "Final Words\nThis post summarizes three approaches to styling the table body. Among them, the mask= parameter in loc.body() is definitely my favorite, inspired by #389 and implemented by me.\nSpecial thanks to @rich-iannone and @machow for their invaluable suggestions during development. Any remaining bugs are entirely on me.\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/clone-reciprocal-tariffs-table-p9/20250416.html",
    "href": "posts/clone-reciprocal-tariffs-table-p9/20250416.html",
    "title": "Clone the Reciprocal Tariffs Table Using Plotnine",
    "section": "",
    "text": "This post presents a recreated visualization using Polars and plotnine, based on my earlier work.\nBelow is the final figure:\nShow full code\nimport polars as pl\nfrom matplotlib.figure import Figure\nfrom plotnine import (\n    aes,\n    element_blank,\n    element_rect,\n    element_text,\n    geom_segment,\n    geom_text,\n    ggplot,\n    position_nudge,\n    scale_color_identity,\n    scale_size_identity,\n    scale_y_discrete,\n    theme,\n    theme_void,\n    watermark,\n)\n\n\n# source1: https://truthsocial.com/@realDonaldTrump/114270398531479278\n# source2:\n# \"https://upload.wikimedia.org/wikipedia/commons/\n# thumb/3/36/Seal_of_the_President_of_the_United_States.svg/\n# 800px-Seal_of_the_President_of_the_United_States.svg.png\"\nlogo_filename = \"logo_resized.png\"\n\ndata = {\n    \"country\": [\n        \"China\",\n        \"European Union\",\n        \"Vietnam\",\n        \"Taiwan\",\n        \"Japan\",\n        \"India\",\n        \"South Korea\",\n        \"Thailand\",\n        \"Switzerland\",\n        \"Indonesia\",\n        \"Malaysia\",\n        \"Cambodia\",\n        \"United Kingdom\",\n        \"South Africa\",\n        \"Brazil\",\n        \"Bangladesh\",\n        \"Singapore\",\n        \"Israel\",\n        \"Philippines\",\n        \"Chile\",\n        \"Australia\",\n        \"Pakistan\",\n        \"Turkey\",\n        \"Sri Lanka\",\n        \"Colombia\",\n    ],\n    \"tariffs_charged\": [\n        \"67%\",\n        \"39%\",\n        \"90%\",\n        \"64%\",\n        \"46%\",\n        \"52%\",\n        \"50%\",\n        \"72%\",\n        \"61%\",\n        \"64%\",\n        \"47%\",\n        \"97%\",\n        \"10%\",\n        \"60%\",\n        \"10%\",\n        \"74%\",\n        \"10%\",\n        \"33%\",\n        \"34%\",\n        \"10%\",\n        \"10%\",\n        \"58%\",\n        \"10%\",\n        \"88%\",\n        \"10%\",\n    ],\n    \"reciprocal_tariffs\": [\n        \"34%\",\n        \"20%\",\n        \"46%\",\n        \"32%\",\n        \"24%\",\n        \"26%\",\n        \"25%\",\n        \"36%\",\n        \"31%\",\n        \"32%\",\n        \"24%\",\n        \"49%\",\n        \"10%\",\n        \"30%\",\n        \"10%\",\n        \"37%\",\n        \"10%\",\n        \"17%\",\n        \"17%\",\n        \"10%\",\n        \"10%\",\n        \"29%\",\n        \"10%\",\n        \"44%\",\n        \"10%\",\n    ],\n}\n\ncountry, tariffs_charged, reciprocal_tariffs = data.keys()\n\ndark_navy_blue = \"#0B162A\"  # background\nlight_blue = \"#B5D3E7\"  # row\nwhite = \"#FFFFFF\"  # row\nyellow = \"#F6D588\"  # \"reciprocal_tariffs\" column\ngold = \"#FFF8DE\"  # logo\n\nfontname_georgia = \"Georgia\"  # title\nfontname_roboto = \"Roboto\"  # body\n\n\ndef tweak_df() -&gt; pl.DataFrame:\n    # column width\n    x_col1_start, x_col1_end = 5, 52.5\n    x_col2_start, x_col2_end = 60, 75\n    x_col3_start, x_col3_end = 82.5, 97.5\n\n    # x-position for body text\n    x_col1_text = 5\n    x_col2_text = x_col2_start + (x_col2_end - x_col2_start) / 3 + 1\n    x_col3_text = x_col3_start + (x_col3_end - x_col3_start) / 3 + 1\n\n    return (\n        pl.DataFrame(data)\n        .with_row_index()\n        .with_columns(\n            pl.col(country).cast(pl.Categorical),\n            pl.when(pl.col(\"index\").mod(2).eq(0))\n            .then(pl.lit(light_blue))\n            .otherwise(pl.lit(white))\n            .alias(\"color_mod\"),\n            pl.lit(x_col1_start).alias(\"x_col1_start\"),\n            pl.lit(x_col1_end).alias(\"x_col1_end\"),\n            pl.lit(x_col2_start).alias(\"x_col2_start\"),\n            pl.lit(x_col2_end).alias(\"x_col2_end\"),\n            pl.lit(x_col3_start).alias(\"x_col3_start\"),\n            pl.lit(x_col3_end).alias(\"x_col3_end\"),\n            pl.lit(x_col1_text).alias(\"x_col1_text\"),\n            pl.lit(x_col2_text).alias(\"x_col2_text\"),\n            pl.lit(x_col3_text).alias(\"x_col3_text\"),\n        )\n    )\n\n\ndef get_textdata_df(x_ref: float = 0.0, y_ref: float = 0.0) -&gt; pl.DataFrame:\n    title_fontsize = 16\n    title_fontweight = \"bold\"\n    heading_fontsize = 8\n    heading_fontweight = \"bold\"\n    subheading_fontsize = 6\n    subheading_fontweight = \"normal\"\n\n    textdata_df = pl.DataFrame(\n        {\n            \"label\": [\n                \"Reciprocal Tariffs\",  # title\n                \"Country\",  # col1\n                \"Tariffs Charged\",  # col2\n                \"to the U.S.A.\",\n                \"Including\",\n                \"Currency Manipulation\",\n                \"and Trade Barriers\",\n                \"U.S.A. Discounted\",  # col3\n                \"Reciprocal Tariffs\",\n            ],\n            \"x\": [\n                x_ref + 34.0,\n                x_ref + 29.5,\n                x_ref + 67.5,\n                x_ref + 67.5,\n                x_ref + 67.5,\n                x_ref + 67.5,\n                x_ref + 67.5,\n                x_ref + 89.5,\n                x_ref + 89.5,\n            ],\n            \"y\": [\n                y_ref + 27,\n                y_ref + 25.5,\n                y_ref + 26.8,\n                y_ref + 26.4,\n                y_ref + 26.1,\n                y_ref + 25.8,\n                y_ref + 25.5,\n                y_ref + 26.0,\n                y_ref + 25.6,\n            ],\n            \"color\": [\n                gold,\n                white,\n                white,\n                white,\n                white,\n                white,\n                white,\n                white,\n                white,\n            ],\n            \"fontsize\": [\n                title_fontsize,\n                heading_fontsize,\n                heading_fontsize,\n                heading_fontsize,\n                subheading_fontsize,\n                subheading_fontsize,\n                subheading_fontsize,\n                heading_fontsize,\n                heading_fontsize,\n            ],\n            \"fontweight\": [\n                title_fontweight,\n                heading_fontweight,\n                heading_fontweight,\n                heading_fontweight,\n                subheading_fontweight,\n                subheading_fontweight,\n                subheading_fontweight,\n                heading_fontweight,\n                heading_fontweight,\n            ],\n            \"fontname\": [\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n            ],\n        }\n    )\n    return textdata_df\n\n\ndef plot_g() -&gt; ggplot:\n    geom_segment_props = {\"size\": 8, \"lineend\": \"round\"}\n\n    geom_text_props = {\n        \"ha\": \"left\",\n        \"va\": \"center\",\n        \"position\": position_nudge(y=-0.08),\n        \"size\": 10,\n        \"fontweight\": \"bold\",\n    }\n\n    return (\n        ggplot(data=df, mapping=aes(y=country, yend=country))\n        # col1 segment\n        + geom_segment(\n            mapping=aes(x=\"x_col1_start\", xend=\"x_col1_end\", color=\"color_mod\"),\n            **geom_segment_props,\n        )\n        # col2 segment\n        + geom_segment(\n            mapping=aes(x=\"x_col2_start\", xend=\"x_col2_end\", color=\"color_mod\"),\n            **geom_segment_props,\n        )\n        # col3 segment\n        + geom_segment(\n            mapping=aes(x=\"x_col3_start\", xend=\"x_col3_end\"),\n            color=yellow,\n            **geom_segment_props,\n        )\n        # col1 text\n        + geom_text(aes(x=\"x_col1_text\", label=country), **geom_text_props)\n        # col2 text\n        + geom_text(aes(x=\"x_col2_text\", label=tariffs_charged), **geom_text_props)\n        # col3 text\n        + geom_text(aes(x=\"x_col3_text\", label=reciprocal_tariffs), **geom_text_props)\n        # using \"color_mod\" column directly\n        + scale_color_identity()\n        # expand extra space\n        + scale_y_discrete(\n            limits=df.select(country).reverse().to_series().to_list(),\n            expand=(0.02, 0, 0, 1.5),\n        )\n        # title and headers\n        + geom_text(\n            data=textdata_df,\n            mapping=aes(\n                x=\"x\",\n                y=\"y\",\n                label=\"label\",\n                color=\"color\",\n                size=\"fontsize\",\n                fontweight=\"fontweight\",\n                fontname=\"fontname\",\n            ),\n            va=\"bottom\",\n            ha=\"center\",\n        )\n        # using \"size\" column directly\n        + scale_size_identity()\n        # logo\n        + watermark(logo_filename, 100, 2235)\n    )\n\n\ndef themify(p: ggplot) -&gt; Figure:\n    return (\n        p\n        + theme_void()\n        + theme(\n            legend_position=\"none\",  # turns off the legend\n            axis_text_x=element_blank(),\n            axis_text_y=element_blank(),\n            axis_title_x=element_blank(),\n            axis_title_y=element_blank(),\n            panel_background=element_rect(fill=dark_navy_blue),\n            plot_background=element_rect(fill=dark_navy_blue),\n            text=element_text(family=fontname_roboto),\n            dpi=300,\n            figure_size=(6, 8),\n        )\n    ).draw(False)\n\n\ndf = tweak_df()\ntextdata_df = get_textdata_df()\np = plot_g()\nfig = themify(p)\nfig"
  },
  {
    "objectID": "posts/clone-reciprocal-tariffs-table-p9/20250416.html#preparing-the-dataframes",
    "href": "posts/clone-reciprocal-tariffs-table-p9/20250416.html#preparing-the-dataframes",
    "title": "Clone the Reciprocal Tariffs Table Using Plotnine",
    "section": "Preparing the DataFrames",
    "text": "Preparing the DataFrames\n\nMain DataFrame\nWe start by extracting the data from a previous project. The country column is converted to a categorical type, which simplifies handling in plotnine. To enable alternating row colors in the final visualization, we also create a new column called color_mod. Additional columns are created to define the positions for the segments and text labels.\ndef tweak_df() -&gt; pl.DataFrame:\n    # column width\n    x_col1_start, x_col1_end = 5, 52.5\n    x_col2_start, x_col2_end = 60, 75\n    x_col3_start, x_col3_end = 82.5, 97.5\n\n    # x-position for body text\n    x_col1_text = 5\n    x_col2_text = x_col2_start + (x_col2_end - x_col2_start) / 3 + 1\n    x_col3_text = x_col3_start + (x_col3_end - x_col3_start) / 3 + 1\n\n    return (\n        pl.DataFrame(data)\n        .with_row_index()\n        .with_columns(\n            pl.col(country).cast(pl.Categorical),\n            pl.when(pl.col(\"index\").mod(2).eq(0))\n            .then(pl.lit(light_blue))\n            .otherwise(pl.lit(white))\n            .alias(\"color_mod\"),\n            pl.lit(x_col1_start).alias(\"x_col1_start\"),\n            pl.lit(x_col1_end).alias(\"x_col1_end\"),\n            pl.lit(x_col2_start).alias(\"x_col2_start\"),\n            pl.lit(x_col2_end).alias(\"x_col2_end\"),\n            pl.lit(x_col3_start).alias(\"x_col3_start\"),\n            pl.lit(x_col3_end).alias(\"x_col3_end\"),\n            pl.lit(x_col1_text).alias(\"x_col1_text\"),\n            pl.lit(x_col2_text).alias(\"x_col2_text\"),\n            pl.lit(x_col3_text).alias(\"x_col3_text\"),\n        )\n    )\n\ndf = tweak_df()\n\n\nTextdata DataFrame\nNext, we create another DataFrame that contains information for all the text elements, such as text color, font size, and font weight, for the title and headers.\ndef get_textdata_df(\n    x_ref: float = 0.0, y_ref: float = 0.0\n) -&gt; pl.DataFrame:\n    title_fontsize = 16\n    title_fontweight = \"bold\"\n    heading_fontsize = 8\n    heading_fontweight = \"bold\"\n    subheading_fontsize = 6\n    subheading_fontweight = \"normal\"\n\n    textdata_df = pl.DataFrame(\n        {\n            \"label\": [\n                \"Reciprocal Tariffs\",  # title\n                \"Country\",  # col1\n                \"Tariffs Charged\",  # col2\n                \"to the U.S.A.\",\n                \"Including\",\n                \"Currency Manipulation\",\n                \"and Trade Barriers\",\n                \"U.S.A. Discounted\",  # col3\n                \"Reciprocal Tariffs\",\n            ],\n            \"x\": [\n                x_ref + 34.0,\n                x_ref + 29.5,\n                x_ref + 67.5,\n                x_ref + 67.5,\n                x_ref + 67.5,\n                x_ref + 67.5,\n                x_ref + 67.5,\n                x_ref + 89.5,\n                x_ref + 89.5,\n            ],\n            \"y\": [\n                y_ref + 27,\n                y_ref + 25.5,\n                y_ref + 26.8,\n                y_ref + 26.4,\n                y_ref + 26.1,\n                y_ref + 25.8,\n                y_ref + 25.5,\n                y_ref + 26.0,\n                y_ref + 25.6,\n            ],\n            \"color\": [\n                gold,\n                white,\n                white,\n                white,\n                white,\n                white,\n                white,\n                white,\n                white,\n            ],\n            \"fontsize\": [\n                title_fontsize,\n                heading_fontsize,\n                heading_fontsize,\n                heading_fontsize,\n                subheading_fontsize,\n                subheading_fontsize,\n                subheading_fontsize,\n                heading_fontsize,\n                heading_fontsize,\n            ],\n            \"fontweight\": [\n                title_fontweight,\n                heading_fontweight,\n                heading_fontweight,\n                heading_fontweight,\n                subheading_fontweight,\n                subheading_fontweight,\n                subheading_fontweight,\n                heading_fontweight,\n                heading_fontweight,\n            ],\n            \"fontname\": [\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n                fontname_georgia,\n            ],\n        }\n    )\n    return textdata_df\n\ntextdata_df = get_textdata_df()"
  },
  {
    "objectID": "posts/clone-reciprocal-tariffs-table-p9/20250416.html#constructing-the-ggplot-object",
    "href": "posts/clone-reciprocal-tariffs-table-p9/20250416.html#constructing-the-ggplot-object",
    "title": "Clone the Reciprocal Tariffs Table Using Plotnine",
    "section": "Constructing the ggplot Object",
    "text": "Constructing the ggplot Object\nWith the processed DataFrame ready, we can now build the ggplot() object:\ndef plot_g() -&gt; ggplot:\n    geom_segment_props = {\"size\": 8, \"lineend\": \"round\"}\n\n    geom_text_props = {\n        \"ha\": \"left\",\n        \"va\": \"center\",\n        \"position\": position_nudge(y=-0.08),\n        \"size\": 10,\n        \"fontweight\": \"bold\",\n    }\n\n    return (\n        ggplot(data=df, mapping=aes(y=country, yend=country))\n        # col1 segment\n        + geom_segment(\n            mapping=aes(x=\"x_col1_start\", xend=\"x_col1_end\", color=\"color_mod\"),\n            **geom_segment_props,\n        )\n        # col2 segment\n        + geom_segment(\n            mapping=aes(x=\"x_col2_start\", xend=\"x_col2_end\", color=\"color_mod\"),\n            **geom_segment_props,\n        )\n        # col3 segment\n        + geom_segment(\n            mapping=aes(x=\"x_col3_start\", xend=\"x_col3_end\"),\n            color=yellow,\n            **geom_segment_props,\n        )\n        # col1 text\n        + geom_text(aes(x=\"x_col1_text\", label=country), **geom_text_props)\n        # col2 text\n        + geom_text(aes(x=\"x_col2_text\", label=tariffs_charged), **geom_text_props)\n        # col3 text\n        + geom_text(aes(x=\"x_col3_text\", label=reciprocal_tariffs), **geom_text_props)\n        # using \"color_mod\" column directly\n        + scale_color_identity()\n        # expand extra space\n        + scale_y_discrete(\n            limits=df.select(country).reverse().to_series().to_list(),\n            expand=(0.02, 0, 0, 1.5),\n        )\n        # title and headers\n        + geom_text(\n1            data=textdata_df,\n            mapping=aes(\n                x=\"x\",\n                y=\"y\",\n                label=\"label\",\n                color=\"color\",\n                size=\"fontsize\",\n                fontweight=\"fontweight\",\n                fontname=\"fontname\",\n            ),\n            va=\"bottom\",\n            ha=\"center\",\n        )\n        # using \"size\" column directly\n        + scale_size_identity()\n        # logo\n        + watermark(logo_filename, 100, 2235)\n    )\n\n1\n\nThe data= argument is set to textdata_df, which contains all the custom label and styling details for the title and column headers.\n\n\n\nWhat’s happening here?\n\ngeom_segment(): Since I couldn’t find a way to apply border radius, I used geom_segment() with lineend=\"round\" as the best available workaround. Thick lines serve as cell backgrounds.\ngeom_text(): Adds text for each column.\nscale_color_identity(): Uses the color values directly from the color_mod column, without applying a scale.\nscale_y_discrete(): Reorders the country axis and tweaks padding to add space above and below the table.\nscale_size_identity(): Similar to color scaling, this instructs plotnine to use the font sizes specified in the fontsize column without transformation.\nwatermark(): Embeds a logo. Since there’s no native figure size parameter in plotnine, I manually scaled the output."
  },
  {
    "objectID": "posts/clone-reciprocal-tariffs-table-p9/20250416.html#custom-theme",
    "href": "posts/clone-reciprocal-tariffs-table-p9/20250416.html#custom-theme",
    "title": "Clone the Reciprocal Tariffs Table Using Plotnine",
    "section": "Custom Theme",
    "text": "Custom Theme\nWe apply a tailored theme with themify() to refine the figure’s appearance:\ndef themify(p: ggplot) -&gt; Figure:\n    return (\n        p\n        + theme_void()\n        + theme(\n            legend_position=\"none\",  # turns off the legend\n            axis_text_x=element_blank(),\n            axis_text_y=element_blank(),\n            axis_title_x=element_blank(),\n            axis_title_y=element_blank(),\n            panel_background=element_rect(fill=dark_navy_blue),\n            plot_background=element_rect(fill=dark_navy_blue),\n            text=element_text(family=fontname_roboto),\n            dpi=300,\n            figure_size=(6, 8),\n        )\n    ).draw(False)"
  },
  {
    "objectID": "posts/clone-reciprocal-tariffs-table-p9/20250416.html#final-rendering",
    "href": "posts/clone-reciprocal-tariffs-table-p9/20250416.html#final-rendering",
    "title": "Clone the Reciprocal Tariffs Table Using Plotnine",
    "section": "Final Rendering",
    "text": "Final Rendering\nNow, let’s tie it all together:\np = plot_g()\nfig = themify(p)\nfig"
  },
  {
    "objectID": "posts/clone-reciprocal-tariffs-table-p9/20250416.html#closing-thoughts",
    "href": "posts/clone-reciprocal-tariffs-table-p9/20250416.html#closing-thoughts",
    "title": "Clone the Reciprocal Tariffs Table Using Plotnine",
    "section": "Closing Thoughts",
    "text": "Closing Thoughts\nThis post showcases how plotnine can be used to create table-like visualizations. I’m genuinely impressed by its capabilities — it’s surprisingly fun to approach a table as a figure.\nThroughout this exploration, I learned a lot from this repository, which won the Plotnine Contest 2024. It’s a fantastic example of what’s possible with the library.\nIt would be exciting to explore how plotnine and Great Tables might work together to enable even richer visual storytelling — I’m looking forward to diving into that next.\n\n\n\n\n\n\nDisclaimer\n\n\n\n\nThis table is intended as a self-practice project, and the data in the table may not be 100% accurate. Please refer to the original source if you require verified data.\nThis post was drafted by me, with AI assistance to refine the content."
  }
]