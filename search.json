[
  {
    "objectID": "posts/style-table-body/20250124.html",
    "href": "posts/style-table-body/20250124.html",
    "title": "Three Approaches to Styling the Table Body in Great Tables",
    "section": "",
    "text": "This post demonstrates three approaches to styling the table body:\nLet’s dive in."
  },
  {
    "objectID": "posts/style-table-body/20250124.html#preparations",
    "href": "posts/style-table-body/20250124.html#preparations",
    "title": "Three Approaches to Styling the Table Body in Great Tables",
    "section": "Preparations",
    "text": "Preparations\nWe’ll use the built-in dataset gtcars to create a Polars DataFrame. Next, we’ll select the columns mfr, drivetrain, year, and hp to create a small pivoted table named df_mini. Finally, we’ll pass df_mini to the GT object to create a table named gt, using drivetrain as the rowname_col= and mfr as the groupname_col=, as shown below:\n\n\nCode\nimport polars as pl\nfrom great_tables import GT, loc, style\nfrom great_tables.data import gtcars\nfrom polars import selectors as cs\n\nyear_cols = [\"2014\", \"2015\", \"2016\", \"2017\"]\ndf_mini = (\n    pl.from_pandas(gtcars)\n    .filter(pl.col(\"mfr\").is_in([\"Ferrari\", \"Lamborghini\", \"BMW\"]))\n    .sort(\"drivetrain\")\n    .pivot(on=\"year\", index=[\"mfr\", \"drivetrain\"], values=\"hp\", aggregate_function=\"mean\")\n    .select([\"mfr\", \"drivetrain\", *year_cols])\n)\n\ngt = GT(df_mini).tab_stub(rowname_col=\"drivetrain\", groupname_col=\"mfr\").opt_stylize()\ngt\n\n\n\n\n\n\n\n\n  \n  2014\n  2015\n  2016\n  2017\n\n\n\n  \n    Ferrari\n  \n  \n    awd\n    None\n    652.0\n    None\n    680.0\n  \n  \n    rwd\n    562.0\n    678.4\n    661.0\n    None\n  \n  \n    Lamborghini\n  \n  \n    awd\n    None\n    700.0\n    None\n    None\n  \n  \n    rwd\n    550.0\n    610.0\n    None\n    None\n  \n  \n    BMW\n  \n  \n    awd\n    None\n    None\n    357.0\n    None\n  \n  \n    rwd\n    None\n    None\n    465.0\n    None\n  \n\n\n\n\n\n\n        \n\n\nThe numbers in the cells represent the average horsepower for each combination of mfr and drivetrain for a specific year.\nIn the following section, we’ll demonstrate three different ways to highlight the cell text in red if the average horsepower exceeds 650."
  },
  {
    "objectID": "posts/style-table-body/20250124.html#using-a-for-loop-repeatedly-call-gt.tab_style-for-each-column",
    "href": "posts/style-table-body/20250124.html#using-a-for-loop-repeatedly-call-gt.tab_style-for-each-column",
    "title": "Three Approaches to Styling the Table Body in Great Tables",
    "section": "Using a For-Loop: Repeatedly Call GT.tab_style() for Each Column",
    "text": "Using a For-Loop: Repeatedly Call GT.tab_style() for Each Column\nThe most intuitive way is to call GT.tab_style() for each column. Here’s how:\n\n1gt1 = gt\nfor col in year_cols:\n    gt1 = gt1.tab_style(\n        style=style.text(color=\"red\"),\n        locations=loc.body(columns=col, rows=pl.col(col).gt(650))\n    )\ngt1\n\n\n1\n\nSince we want to keep gt intact for later use, we will modify gt1 in this approach instead.\n\n\n\n\n\n\n\n\n\n\n  \n  2014\n  2015\n  2016\n  2017\n\n\n\n  \n    Ferrari\n  \n  \n    awd\n    None\n    652.0\n    None\n    680.0\n  \n  \n    rwd\n    562.0\n    678.4\n    661.0\n    None\n  \n  \n    Lamborghini\n  \n  \n    awd\n    None\n    700.0\n    None\n    None\n  \n  \n    rwd\n    550.0\n    610.0\n    None\n    None\n  \n  \n    BMW\n  \n  \n    awd\n    None\n    None\n    357.0\n    None\n  \n  \n    rwd\n    None\n    None\n    465.0\n    None"
  },
  {
    "objectID": "posts/style-table-body/20250124.html#utilizing-the-locations-parameter-in-gt.tab_style-pass-a-list-of-loc.body-objects",
    "href": "posts/style-table-body/20250124.html#utilizing-the-locations-parameter-in-gt.tab_style-pass-a-list-of-loc.body-objects",
    "title": "Three Approaches to Styling the Table Body in Great Tables",
    "section": "Utilizing the locations= Parameter in GT.tab_style(): Pass a List of loc.body() Objects",
    "text": "Utilizing the locations= Parameter in GT.tab_style(): Pass a List of loc.body() Objects\nA more concise method is to pass a list of loc.body() objects to the locations= parameter in GT.tab_style(), as shown below:\n\n(\n    gt.tab_style(\n        style=style.text(color=\"red\"),\n        locations=[\n            loc.body(columns=col, rows=pl.col(col).gt(650))\n            for col in year_cols\n        ],\n    )\n)\n\n\n\n\n\n\n\n  \n  2014\n  2015\n  2016\n  2017\n\n\n\n  \n    Ferrari\n  \n  \n    awd\n    None\n    652.0\n    None\n    680.0\n  \n  \n    rwd\n    562.0\n    678.4\n    661.0\n    None\n  \n  \n    Lamborghini\n  \n  \n    awd\n    None\n    700.0\n    None\n    None\n  \n  \n    rwd\n    550.0\n    610.0\n    None\n    None\n  \n  \n    BMW\n  \n  \n    awd\n    None\n    None\n    357.0\n    None\n  \n  \n    rwd\n    None\n    None\n    465.0\n    None"
  },
  {
    "objectID": "posts/style-table-body/20250124.html#leveraging-the-mask-parameter-in-loc.body-use-polars-expressions-for-streamlined-styling",
    "href": "posts/style-table-body/20250124.html#leveraging-the-mask-parameter-in-loc.body-use-polars-expressions-for-streamlined-styling",
    "title": "Three Approaches to Styling the Table Body in Great Tables",
    "section": "Leveraging the mask= Parameter in loc.body(): Use Polars Expressions for Streamlined Styling",
    "text": "Leveraging the mask= Parameter in loc.body(): Use Polars Expressions for Streamlined Styling\nThe most modern approach (0.16.0) is to pass a Polars expression to the mask= parameter in loc.body(), as illustrated here:\n\n(\n    gt.tab_style(\n        style=style.text(color=\"red\"),\n        locations=loc.body(mask=cs.numeric().gt(650))\n    )\n)\n\n\n\n\n\n\n\n  \n  2014\n  2015\n  2016\n  2017\n\n\n\n  \n    Ferrari\n  \n  \n    awd\n    None\n    652.0\n    None\n    680.0\n  \n  \n    rwd\n    562.0\n    678.4\n    661.0\n    None\n  \n  \n    Lamborghini\n  \n  \n    awd\n    None\n    700.0\n    None\n    None\n  \n  \n    rwd\n    550.0\n    610.0\n    None\n    None\n  \n  \n    BMW\n  \n  \n    awd\n    None\n    None\n    357.0\n    None\n  \n  \n    rwd\n    None\n    None\n    465.0\n    None\n  \n\n\n\n\n\n\n        \n\n\nIn this example, loc.body() is smart enough to automatically target the rows where the cell value exceeds 650 for each numerical column. In general, you can think of mask= as a syntactic sugar that Great Tables provides to save you from having to manually loop through the columns."
  },
  {
    "objectID": "posts/style-table-body/20250124.html#final-words",
    "href": "posts/style-table-body/20250124.html#final-words",
    "title": "Three Approaches to Styling the Table Body in Great Tables",
    "section": "Final Words",
    "text": "Final Words\nThis post summarizes three approaches to styling the table body. Among them, the mask= parameter in loc.body() is definitely my favorite, inspired by #389 and implemented by me.\nSpecial thanks to @rich-iannone and @machow for their invaluable suggestions during development. Any remaining bugs are entirely on me.\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "posts/django-allauth-resend/20241223.html",
    "href": "posts/django-allauth-resend/20241223.html",
    "title": "Exploring Resend SMTP Service with Django",
    "section": "",
    "text": "This post demonstrates how to integrate Resend with django-allauth seamlessly in a Django project. If you’re looking to use Resend for sending emails via Django, refer to the repo provided by Resend."
  },
  {
    "objectID": "posts/django-allauth-resend/20241223.html#preparations-for-django",
    "href": "posts/django-allauth-resend/20241223.html#preparations-for-django",
    "title": "Exploring Resend SMTP Service with Django",
    "section": "Preparations for Django",
    "text": "Preparations for Django\n\nCreate a Virtual Environment\nStart by creating a virtual environment using uv and activating it:\nuv venv venv\nsource venv/bin/activate\n\n\nInstall Required Packages\nCreate a requirements.txt file and add the necessary dependencies:\ndjango\nenvirons[django]\ndjango-allauth\nInstall the packages via uv:\nuv pip install -r requirements.txt\n\n\nSet Up a Django Project\nUse the django-admin command to create a project named core:\ndjango-admin startproject core .\n\n\nConfigure Environment Variables\nCreate a .env file with the following content:\nDEFAULT_FROM_EMAIL=\nRESEND_SMTP_HOST=smtp.resend.com\nRESEND_SMTP_USERNAME=resend\nRESEND_API_KEY=\nRESEND_SMTP_PORT=587\nRESEND_USE_TLS=True\nThe next sections explain how to obtain DEFAULT_FROM_EMAIL and RESEND_API_KEY."
  },
  {
    "objectID": "posts/django-allauth-resend/20241223.html#preparations-for-resend",
    "href": "posts/django-allauth-resend/20241223.html#preparations-for-resend",
    "title": "Exploring Resend SMTP Service with Django",
    "section": "Preparations for Resend",
    "text": "Preparations for Resend\n\nVerify Your Domain\nFollow the Resend documentation to verify your domain. Once verified, you can send emails using an address like user@send.yourdomain.com.\n\nYou control the prefix before @, as ownership of the domain has been confirmed.\n\nAdd your chosen email to DEFAULT_FROM_EMAIL in the .env file.\n\n\n\nObtain an API Key\nGenerate an API key via the Resend API Keys page and add it to the RESEND_API_KEY field in your .env file."
  },
  {
    "objectID": "posts/django-allauth-resend/20241223.html#django-scaffold",
    "href": "posts/django-allauth-resend/20241223.html#django-scaffold",
    "title": "Exploring Resend SMTP Service with Django",
    "section": "Django Scaffold",
    "text": "Django Scaffold\nFollow the quick start guide from django-allauth to configure the project with minimal setup.\n\nModify core/urls.py\nInclude django-allauth routes and define a homepage route:\n# core/urls.py\n\nfrom django.contrib import admin\nfrom django.urls import path, include\nfrom . import views\n\nurlpatterns = [\n    path(\"admin/\", admin.site.urls),\n    path(\"accounts/\", include(\"allauth.urls\")),  # added\n    path(\"\", views.index, name=\"home\"),  # added\n]\n\n\nAdd core/views.py\nDefine the homepage with a link to the signup URL provided by django-allauth:\nfrom django.http import HttpResponse\nfrom django.urls import reverse\n\n\ndef index(request):\n    signup_url = reverse(\"account_signup\")\n    return HttpResponse(f'&lt;a href=\"{signup_url}\"&gt;Hello, please Sign Up here!&lt;/a&gt;')\n\n\nModify core/settings.py\n\nRead Environment Variables\n# core/settings.py\n\nfrom environs import Env\n\nenv = Env()\nenv.read_env()\n\n\nUpdate INSTALLED_APPS\n# core/settings.py\n\nINSTALLED_APPS = [\n    ...\n    \"allauth\",  # added\n    \"allauth.account\",  # added\n]\n\n\nUpdate MIDDLEWARE\n# core/settings.py\n\nMIDDLEWARE = [\n    \"django.middleware.security.SecurityMiddleware\",\n    \"django.contrib.sessions.middleware.SessionMiddleware\",\n    \"django.middleware.common.CommonMiddleware\",\n    \"django.middleware.csrf.CsrfViewMiddleware\",\n    \"django.contrib.auth.middleware.AuthenticationMiddleware\",\n    \"django.contrib.messages.middleware.MessageMiddleware\",\n    \"allauth.account.middleware.AccountMiddleware\",  # added\n    ...\n]\n\n\nConfigure Email Backend and Authentication Backends\n# core/settings.py\n\nEMAIL_BACKEND = \"django.core.mail.backends.smtp.EmailBackend\"\n\nAUTHENTICATION_BACKENDS = [\n    \"django.contrib.auth.backends.ModelBackend\",\n    \"allauth.account.auth_backends.AuthenticationBackend\",\n]\n\n\nDefine Login and Logout Redirect URLs\nHere, we define only ACCOUNT_LOGOUT_REDIRECT_URL because django-allauth overwrites LOGOUT_REDIRECT_URL.\nLOGIN_REDIRECT_URL = \"home\"\nACCOUNT_LOGOUT_REDIRECT_URL = \"home\"\n\n\nOptional Preference Settings\nOpinionated configurations for a simplified signup and email-based login:\nACCOUNT_SIGNUP_PASSWORD_ENTER_TWICE = False\nACCOUNT_USERNAME_REQUIRED = False\nACCOUNT_AUTHENTICATION_METHOD = \"email\"\nACCOUNT_EMAIL_REQUIRED = True\nACCOUNT_UNIQUE_EMAIL = True\n\n\nDefine Resend Variables\nDEFAULT_FROM_EMAIL = env(\"DEFAULT_FROM_EMAIL\")\nRESEND_SMTP_HOST = env(\"RESEND_SMTP_HOST\")\nRESEND_SMTP_USERNAME = env(\"RESEND_SMTP_USERNAME\")\nRESEND_API_KEY = env(\"RESEND_API_KEY\")\nRESEND_SMTP_PORT = env.int(\"RESEND_SMTP_PORT\")\nRESEND_USE_TLS = env.bool(\"RESEND_USE_TLS\")\n\n\nMap Resend Variables to Django Email Variables\nDelegate Django email settings to Resend environment variables:\nEMAIL_HOST = RESEND_SMTP_HOST\nEMAIL_HOST_USER = RESEND_SMTP_USERNAME\nEMAIL_HOST_PASSWORD = RESEND_API_KEY\nEMAIL_PORT = RESEND_SMTP_PORT\nEMAIL_USE_TLS = RESEND_USE_TLS"
  },
  {
    "objectID": "posts/django-allauth-resend/20241223.html#tryout",
    "href": "posts/django-allauth-resend/20241223.html#tryout",
    "title": "Exploring Resend SMTP Service with Django",
    "section": "Tryout",
    "text": "Tryout\nMigrate the database and run the development server with the following commands:\npython manage.py migrate\npython manage.py runserver\nNow, go to http://127.0.0.1:8000/ and click the sign-up link. You should see the signup page. After submitting the form, you will be redirected to the homepage.\nNext, check your inbox for an email with the subject [127.0.0.1:8000] Please Confirm Your Email Address.\nThe email will contain a confirmation link. Click the link, then click the confirmation button, and you’re all set for user registration!\n\n\n\n\n\n\nTip\n\n\n\nIf you encounter issues during configuration, the Resend logs can be a helpful resource, as they provide the request body, response body, and status code."
  },
  {
    "objectID": "posts/django-allauth-resend/20241223.html#final-words",
    "href": "posts/django-allauth-resend/20241223.html#final-words",
    "title": "Exploring Resend SMTP Service with Django",
    "section": "Final Words",
    "text": "Final Words\nThe configuration is straightforward, and it’s great that Resend offers SMTP services. The modern dashboard operates smoothly, and the well-documented resources make it easy for developers to find needed information. So far, the user experience has been positive, and I look forward to using it in real projects.\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Posts",
    "section": "",
    "text": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib\n\n\n\n\n\n\npython\n\n\npandas\n\n\npolars\n\n\nmatplotlib\n\n\n\n\n\n\n\n\n\nFeb 10, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nThree Approaches to Styling the Table Body in Great Tables\n\n\n\n\n\n\npython\n\n\npolars\n\n\ngt\n\n\n\n\n\n\n\n\n\nJan 24, 2025\n\n\nJerry Wu\n\n\n\n\n\n\n\n\n\n\n\n\nExploring Resend SMTP Service with Django\n\n\n\n\n\n\npython\n\n\ndjango\n\n\nresend\n\n\n\n\n\n\n\n\n\nDec 23, 2024\n\n\nJerry Wu\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html",
    "href": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html",
    "title": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib",
    "section": "",
    "text": "It was an honor to be one of the reviewers for Matt Harrison’s new book, Effective Visualization. If you’re looking to deepen your understanding of how to use Pandas and Matplotlib to craft compelling data stories, this book is a must-read.\nLast weekend, I decided to convert some of the Pandas code from the book into Polars just for fun, and I’d like to share an example in this post. You can find the original Pandas code in the repo (empty link for now).\nThe final figure, shown below, visualizes temperature trends for the ski season in Alta over the past few decades.\nShow full code\nimport polars as pl\nimport polars.selectors as cs\nimport matplotlib.pyplot as plt\n\nfrom highlight_text import ax_text\nfrom matplotlib import colormaps\nfrom functools import partial\n\n# https://github.com/mattharrison/datasets/raw/refs/heads/master/data/alta-noaa-1980-2019.csv\ndata_path = \"alta-noaa-1980-2019.csv\"\ncolumns = [\"DATE\", \"TOBS\"]\ndf = pl.scan_csv(data_path).select(columns).collect()\n\n\ndef get_season_expr(col: str = \"DATE\", alias: str = \"SEASON\") -&gt; pl.expr:\n    return (\n        (\n            pl.when((pl.col(col).dt.month().is_between(5, 10, closed=\"both\")))\n            .then(pl.lit(\"Summer \"))\n            .otherwise(pl.lit(\"Ski \"))\n        )\n        .add(\n            pl.when(pl.col(col).dt.month() &lt; 11)\n            .then(pl.col(col).dt.year().cast(pl.String))\n            .otherwise(pl.col(col).dt.year().add(1).cast(pl.String))\n        )\n        .alias(alias)\n    )\n\n\ndef add_day_of_season_expr(\n    col: str = \"DATE\", group_col: str = \"SEASON\", alias: str = \"DAY_OF_SEASON\"\n) -&gt; pl.expr:\n    return (\n        (pl.col(col) - pl.col(col).min()).dt.total_days().over(group_col).alias(alias)\n    )\n\n\ndef plot_temps(df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\") -&gt; pl.DataFrame:\n    plt.rcParams[\"font.family\"] = \"Roboto\"\n    figsize = (160, 165)  # pts\n\n    def points_to_inches(points):\n        return points / 72\n\n    figsize_inches = [points_to_inches(dim) for dim in figsize]\n\n    heading_fontsize = 9.5\n    heading_fontweight = \"bold\"\n    subheading_fontsize = 8\n    subheading_fontweight = \"normal\"\n    source_fontsize = 6.5\n    source_fontweight = \"light\"\n    axis_fontsize = 7\n    axis_fontweight = \"normal\"\n\n    grey = \"#aaaaaa\"\n    red = \"#e3120b\"\n    blue = \"#0000ff\"\n    cmap = colormaps.get_cmap(\"Grays\")\n\n    layout = [[\"title\"], [\"plot\"], [\"notes\"]]\n    fig, axs = plt.subplot_mosaic(\n        layout,\n        gridspec_kw={\"height_ratios\": [6, 12, 1]},\n        figsize=figsize_inches,\n        dpi=300,\n        constrained_layout=True,\n    )\n\n    # ----- Title -----\n    ax_title = axs[\"title\"]\n    ax_title.axis(\"off\")\n    sub_props = {\"fontsize\": subheading_fontsize, \"fontweight\": subheading_fontweight}\n    ax_text(\n        s=\"&lt;Alta Ski Resort&gt;\\n&lt;Temperature trends by &gt;\\n&lt;decade&gt;&lt; and &gt;&lt;2019&gt;\",\n        x=0,\n        y=0,\n        fontsize=heading_fontsize,\n        ax=ax_title,\n        va=\"bottom\",\n        ha=\"left\",\n        zorder=5,\n        highlight_textprops=[\n            {\"fontsize\": heading_fontsize, \"fontweight\": heading_fontweight},\n            sub_props,\n            {\"color\": blue, **sub_props},\n            sub_props,\n            {\"color\": red, **sub_props},\n        ],\n    )\n\n    # ----- Plot -----\n    ax = axs[\"plot\"]\n    season_temps = df_.filter(pl.col(\"SEASON\").str.contains(\"Ski\")).pivot(\n        \"SEASON\", index=idx_colname, values=\"TMEAN\", aggregate_function=\"first\"\n    )\n    season_temps_index = season_temps[idx_colname]\n\n    columns = season_temps.columns\n    columns.remove(idx_colname)\n    columns.remove(\"Ski 2019\")\n    for i, column in enumerate(columns):\n        color = cmap(i / len(columns))\n        ax.plot(\n            season_temps_index,\n            season_temps[column],\n            color=color,\n            linewidth=1,\n            alpha=0.2,\n            zorder=1,\n        )\n\n    # # ---- Decade Averages ----\n    decades = [1980, 1990, 2000, 2010]\n    blues = [\"#0055EE\", \"#0033CC\", \"#0011AA\", \"#3377FF\"]\n    for decade, color in zip(decades, blues):\n        match = str(decade)[:-1]  # 1980 -&gt; \"198\", 2010 -&gt; \"201\"\n        decade_temps = season_temps.select(cs.contains(match)).mean_horizontal()\n        ax.plot(season_temps_index, decade_temps, color=color, linewidth=1)\n\n        # add label to right of line\n        last_y_label = decade_temps.last()\n\n        if decade == 2000:\n            last_y_label -= 3\n        elif decade == 2010:\n            last_y_label -= 0.3\n\n        ax.text(\n            185,\n            last_y_label,\n            f\"{decade}\",\n            va=\"center\",\n            ha=\"left\",\n            fontsize=axis_fontsize,\n            fontweight=axis_fontweight,\n            color=color,\n        )\n        # # add dot to start and end of each line\n        ax.plot(\n            season_temps_index.first(),\n            decade_temps.first(),\n            marker=\"o\",\n            color=color,\n            markersize=1,\n            zorder=2,\n        )\n        ax.plot(\n            season_temps_index.last(),\n            decade_temps.last(),\n            marker=\"o\",\n            color=color,\n            markersize=1,\n            zorder=2,\n        )\n\n    # # ------ Ski 2019 ------\n    # # plot `Ski 2019` in red\n    ski_2019 = season_temps.select(idx_colname, cs.by_name(\"Ski 2019\")).drop_nulls()\n    ski_2019_index = ski_2019[idx_colname]\n    ski_2019 = ski_2019.drop([idx_colname]).to_series()\n    ax.plot(ski_2019_index, ski_2019, color=\"red\", linewidth=1)\n\n    # add dot to start and end of each line\n    ax.plot(\n        ski_2019_index.first(),\n        ski_2019.first(),\n        marker=\"o\",\n        color=\"red\",\n        markersize=2,\n        zorder=2,\n    )\n    ax.plot(\n        ski_2019_index.last(),\n        ski_2019.last(),\n        marker=\"o\",\n        color=\"red\",\n        markersize=2,\n        zorder=2,\n    )\n\n    # # ------ Ticks & Lines ------\n    # # remove spines\n    for side in [\"top\", \"left\", \"right\"]:\n        ax.spines[side].set_visible(False)\n\n    # # add horizontal line at 32F\n    ax.axhline(32, color=\"black\", linestyle=\"--\", linewidth=1, zorder=1)\n\n    # # set y ticks\n    ax.set_yticks(ticks=[10, 32, 40])\n\n    # # set y limit\n    ax.set_ylim([10, 55])\n\n    # # set x label\n    ax.set_xlabel(\"Day of season\", fontsize=axis_fontsize, fontweight=axis_fontweight)\n\n    # # ------ Source ------\n    ax_notes = axs[\"notes\"]\n    # add source\n    ax_notes.axis(\"off\")\n    ax_notes.text(\n        0,\n        0,\n        \"Source: NOAA\",\n        fontsize=source_fontsize,\n        fontweight=source_fontweight,\n        color=grey,\n    )\n    return df_\n\n\nidx_colname = \"DAY_OF_SEASON\"\n\ndata = (\n    df.with_columns(\n        pl.col(\"DATE\").str.to_datetime(),\n        pl.col(\"TOBS\").interpolate(),\n    )\n    .sort(\"DATE\")\n    .with_columns(\n        # Caveat: Cannot be placed in the previous `with_columns()`\n        # due to different statuses of `TOBS`.\n        pl.col(\"TOBS\").rolling_mean(window_size=28, center=True).alias(\"TMEAN\"),\n        get_season_expr(col=\"DATE\", alias=\"SEASON\"),\n    )\n    .with_columns(\n        add_day_of_season_expr(col=\"DATE\", group_col=\"SEASON\", alias=idx_colname)\n    )\n    .pipe(partial(plot_temps, idx_colname=idx_colname))\n)"
  },
  {
    "objectID": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#loading-the-data",
    "href": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#loading-the-data",
    "title": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib",
    "section": "Loading the Data",
    "text": "Loading the Data\nTo begin, we load the dataset, focusing on two key columns:\n\nDATE: The dates.\nTOBS: The recorded temperature in Fahrenheit.\n\n\nimport polars as pl\nimport polars.selectors as cs\nimport matplotlib.pyplot as plt\n\nfrom highlight_text import ax_text\nfrom matplotlib import colormaps\nfrom functools import partial\n\ndata_path = \"alta-noaa-1980-2019.csv\"\ncolumns = [\"DATE\", \"TOBS\"]\ndf = pl.scan_csv(data_path).select(columns).collect()\nprint(df.head())\n\nshape: (5, 2)\n┌────────────┬──────┐\n│ DATE       ┆ TOBS │\n│ ---        ┆ ---  │\n│ str        ┆ i64  │\n╞════════════╪══════╡\n│ 1980-01-01 ┆ 25   │\n│ 1980-01-02 ┆ 18   │\n│ 1980-01-03 ┆ 18   │\n│ 1980-01-04 ┆ 27   │\n│ 1980-01-05 ┆ 34   │\n└────────────┴──────┘"
  },
  {
    "objectID": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#data-processing-pipeline",
    "href": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#data-processing-pipeline",
    "title": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib",
    "section": "Data Processing Pipeline",
    "text": "Data Processing Pipeline\nHere’s the pipeline for generating the final figure:\nidx_colname = \"DAY_OF_SEASON\"\n\ndata = (\n    df.with_columns(\n1        pl.col(\"DATE\").str.to_datetime(),\n2        pl.col(\"TOBS\").interpolate(),\n    )\n    .sort(\"DATE\")\n    .with_columns(\n        # Caveat: Cannot be placed in the previous `with_columns()`\n        # due to different statuses of `TOBS`.\n3        pl.col(\"TOBS\").rolling_mean(window_size=28, center=True).alias(\"TMEAN\"),\n4        get_season_expr(col=\"DATE\", alias=\"SEASON\"),\n    )\n    .with_columns(\n5        add_day_of_season_expr(col=\"DATE\", group_col=\"SEASON\", alias=idx_colname)\n    ) \n6    .pipe(partial(plot_temps, idx_colname=idx_colname))\n)\n\n1\n\nConvert the DATE column to a datetime format.\n\n\n2\n\nPerform interpolation on the TOBS column.\n\n\n3\n\nCompute a 28-day rolling average for TOBS.\n\n\n4\n\nUse get_season_expr() to categorize each date into a SEASON.\n\n\n5\n\nApply add_day_of_season_expr() to calculate DAY_OF_SEASON, representing days elapsed since the start of the season.\n\n\n6\n\nUse plot_temps() to generate the final visualization with Matplotlib.\n\n\nThe first three steps involve straightforward Polars expressions. In the following sections, we’ll dive deeper into steps 4 to 6."
  },
  {
    "objectID": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#categorizing-dates-into-summer-and-ski-seasons",
    "href": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#categorizing-dates-into-summer-and-ski-seasons",
    "title": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib",
    "section": "Categorizing Dates into Summer and Ski Seasons",
    "text": "Categorizing Dates into Summer and Ski Seasons\nTo analyze seasonal trends, we classify dates into two categories:\n\nSummer: Covers May through October.\n\nSki: Covers November through April.\n\nIf a date falls in November or December, it is assigned to the following year’s season. For example, 2015-10-31 is categorized as Summer 2015, while 2015-11-01 belongs to Ski 2016.\nTo implement this logic, we define get_season_expr(), which leverages Polars’ when-then-otherwise expressions to determine the season and year.\ndef get_season_expr(col: str = \"DATE\", alias: str = \"SEASON\") -&gt; pl.expr:\n    return (\n        (\n            pl.when((pl.col(col).dt.month().is_between(5, 10, closed=\"both\")))\n            .then(pl.lit(\"Summer \"))\n            .otherwise(pl.lit(\"Ski \"))\n        )\n        .add(\n            pl.when(pl.col(col).dt.month() &lt; 11)\n            .then(pl.col(col).dt.year().cast(pl.String))\n            .otherwise(pl.col(col).dt.year().add(1).cast(pl.String))\n        )\n        .alias(alias)\n    )\nIn this function:\n\nIf the month is between May and October, the function assigns \"Summer \". Otherwise, it assigns \"Ski \" (with a trailing space for concatenation).\n\nThe year is determined based on the month: dates from January to October retain their current year, while those in November and December are shifted to the next year.\n\nBy applying this function, we can add a SEASON column to a Polars DataFrame, ensuring each date is categorized correctly."
  },
  {
    "objectID": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#calculating-the-total-days-for-each-season",
    "href": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#calculating-the-total-days-for-each-season",
    "title": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib",
    "section": "Calculating the Total Days for Each Season",
    "text": "Calculating the Total Days for Each Season\nOnce we have the seasonal categories, we calculate DAY_OF_SEASON, which tracks the number of days elapsed within each season. This is achieved using the pl.expr.over() expression, which operates similarly to Pandas’ groupby().transform(), applying transformations within groups.\ndef add_day_of_season_expr(\n    col: str = \"DATE\", group_col: str = \"SEASON\", alias: str = \"DAY_OF_SEASON\"\n) -&gt; pl.expr:\n    return (\n        (pl.col(col) - pl.col(col).min()).dt.total_days().over(group_col).alias(alias)\n    )"
  },
  {
    "objectID": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#visualizing-temperature-trends-with-matplotlib",
    "href": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#visualizing-temperature-trends-with-matplotlib",
    "title": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib",
    "section": "Visualizing Temperature Trends with Matplotlib",
    "text": "Visualizing Temperature Trends with Matplotlib\nWith the data prepared, we move on to plotting. Since plot_temps() is quite long, we’ll break it down into several parts for easier explanation\n\nSetting Up the Figure\nWe start by defining some parameters and using plt.subplot_mosaic() to create the figure layout. This provides structured axes for different elements of the visualization.\ndef plot_temps(df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\") -&gt; pl.DataFrame:\n    plt.rcParams[\"font.family\"] = \"Roboto\"\n    figsize = (160, 165)  # pts\n\n    def points_to_inches(points):\n        return points / 72\n\n    figsize_inches = [points_to_inches(dim) for dim in figsize]\n\n    heading_fontsize = 9.5\n    heading_fontweight = \"bold\"\n    subheading_fontsize = 8\n    subheading_fontweight = \"normal\"\n    source_fontsize = 6.5\n    source_fontweight = \"light\"\n    axis_fontsize = 7\n    axis_fontweight = \"normal\"\n\n    grey = \"#aaaaaa\"\n    red = \"#e3120b\"\n    blue = \"#0000ff\"\n    cmap = colormaps.get_cmap(\"Grays\")\n\n    layout = [[\"title\"], [\"plot\"], [\"notes\"]]\n    fig, axs = plt.subplot_mosaic(\n        layout,\n        gridspec_kw={\"height_ratios\": [6, 12, 1]},\n        figsize=figsize_inches,\n        dpi=300,\n        constrained_layout=True,\n    )\n    ...\n    \n\n\nAdding the Title\nFor the title, we use ax_text() from the HighlightText library, which allows selective styling of text enclosed in &lt; &gt;. This lets us highlight key parts of the title, such as &lt;Alta Ski Resort&gt;, &lt;Temperature trends by &gt;, &lt;decade&gt;, &lt; and &gt;, and &lt;2019&gt;, with custom formatting.\ndef plot_temps(\n    df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    ...\n\n    # ----- Title -----\n    ax_title = axs[\"title\"]\n    ax_title.axis(\"off\")\n    sub_props = {\"fontsize\": subheading_fontsize, \"fontweight\": subheading_fontweight}\n    ax_text(\n        s=\"&lt;Alta Ski Resort&gt;\\n&lt;Temperature trends by &gt;\\n&lt;decade&gt;&lt; and &gt;&lt;2019&gt;\",\n        x=0,\n        y=0,\n        fontsize=heading_fontsize,\n        ax=ax_title,\n        va=\"bottom\",\n        ha=\"left\",\n        zorder=5,\n        highlight_textprops=[\n            {\"fontsize\": heading_fontsize, \"fontweight\": heading_fontweight},\n            sub_props,\n            {\"color\": blue, **sub_props},\n            sub_props,\n            {\"color\": red, **sub_props},\n        ],\n    )\n\n\nPlotting Seasonal Trends\nNext, we generate the main plot by:\n\nFiltering the dataset for Ski seasons.\n\nPivoting the table to organize TMEAN values by DAY_OF_SEASON and SEASON.\n\nUsing ax.plot() to draw a separate line for each Ski season.\n\ndef plot_temps(\n    df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    ...\n\n    # ----- Plot -----\n    ax = axs[\"plot\"]\n    season_temps = df_.filter(pl.col(\"SEASON\").str.contains(\"Ski\")).pivot(\n        \"SEASON\", index=idx_colname, values=\"TMEAN\", aggregate_function=\"first\"\n    )\n    season_temps_index = season_temps[idx_colname]\n\n    columns = season_temps.columns\n    columns.remove(idx_colname)\n    columns.remove(\"Ski 2019\")\n    for i, column in enumerate(columns):\n        color = cmap(i / len(columns))\n        ax.plot(\n            season_temps_index,\n            season_temps[column],\n            color=color,\n            linewidth=1,\n            alpha=0.2,\n            zorder=1,\n        )\nTo illustrate long-term trends, we overlay four lines representing the average temperature trends for different decades, marking their start and end points with dots for emphasis.\ndef plot_temps(\n    df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    ...\n\n    # # ---- Decade Averages ----\n    decades = [1980, 1990, 2000, 2010]\n    blues = [\"#0055EE\", \"#0033CC\", \"#0011AA\", \"#3377FF\"]\n    for decade, color in zip(decades, blues):\n        match = str(decade)[:-1] # 1980 -&gt; \"198\", 2010 -&gt; \"201\"\n1        decade_temps = season_temps.select(cs.contains(match)).mean_horizontal()\n        ax.plot(season_temps_index, decade_temps, color=color, linewidth=1)\n\n        # add label to right of line\n        last_y_label = decade_temps.last()\n\n        if decade == 2000:\n            last_y_label -= 3\n        elif decade == 2010:\n            last_y_label -= 0.3\n\n        ax.text(\n            185,\n            last_y_label,\n            f\"{decade}\",\n            va=\"center\",\n            ha=\"left\",\n            fontsize=axis_fontsize,\n            fontweight=axis_fontweight,\n            color=color,\n        )\n        # # add dot to start and end of each line\n        ax.plot(\n            season_temps_index.first(),\n            decade_temps.first(),\n            marker=\"o\",\n            color=color,\n            markersize=1,\n            zorder=2,\n        )\n        ax.plot(\n            season_temps_index.last(),\n            decade_temps.last(),\n            marker=\"o\",\n            color=color,\n            markersize=1,\n            zorder=2,\n        )\n\n1\n\nWe leverage two powerful features of Polars: Polars selectors, which enable efficient column selection based on name patterns to extract data for each decade (cs.contains(match)), and df.mean_horizontal(), which performs vectorized operations across columns to compute the average temperature for each decade.\n\n\n\n\nHighlighting the 2019 Ski Season\nTo make Ski 2019 stand out, we plot its trend in red and highlight its start and end points with dots, similar to the decade lines.\ndef plot_temps(\n    df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    ...\n\n    # # ------ Ski 2019 ------\n    # # plot `Ski 2019` in red\n1    ski_2019 = season_temps.select(idx_colname, cs.by_name(\"Ski 2019\")).drop_nulls()\n    ski_2019_index = ski_2019[idx_colname]\n    ski_2019 = ski_2019.drop([idx_colname]).to_series()\n    ax.plot(ski_2019_index, ski_2019, color=\"red\", linewidth=1)\n\n    # add dot to start and end of each line\n    ax.plot(\n        ski_2019_index.first(),\n        ski_2019.first(),\n        marker=\"o\",\n        color=\"red\",\n        markersize=2,\n        zorder=2,\n    )\n    ax.plot(\n        ski_2019_index.last(),\n        ski_2019.last(),\n        marker=\"o\",\n        color=\"red\",\n        markersize=2,\n        zorder=2,\n    )\n\n1\n\nWe use the Polars selector (cs.by_name()) to isolate the Ski 2019 data.\n\n\n\n\nRefinements for Clarity\nTo enhance readability, we refine the visualization by adjusting:\n\nSpines: Removing unnecessary borders.\n\nReference Line: Adding a horizontal dashed line at 32°F for context.\n\nTicks & Limits: Setting appropriate y-axis ticks and limits.\n\nLabels: Customizing the x-axis label for clarity.\n\ndef plot_temps(\n    df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    ...\n\n    # # ------ Ticks & Lines ------\n    # # remove spines\n    for side in [\"top\", \"left\", \"right\"]:\n        ax.spines[side].set_visible(False)\n\n    # # add horizontal line at 32F\n    ax.axhline(32, color=\"black\", linestyle=\"--\", linewidth=1, zorder=1)\n\n    # # set y ticks\n    ax.set_yticks(ticks=[10, 32, 40])\n\n    # # set y limit\n    ax.set_ylim([10, 55])\n\n    # # set x label\n    ax.set_xlabel(\"Day of season\", fontsize=axis_fontsize, fontweight=axis_fontweight)\n\n\nAdding Notes\nFinally, we use Matplotlib’s ax.text() to annotate the source of the data.\ndef plot_temps(\n    df_: pl.DataFrame, idx_colname: str = \"DAY_OF_SEASON\"\n) -&gt; pl.DataFrame:\n    ...\n\n    # # ------ Source ------\n    ax_notes = axs[\"notes\"]\n    # add source\n    ax_notes.axis(\"off\")\n    ax_notes.text(\n        0,\n        0,\n        \"Source: NOAA\",\n        fontsize=source_fontsize,\n        fontweight=source_fontweight,\n        color=grey,\n    )\n    return df_"
  },
  {
    "objectID": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#wrapping-up",
    "href": "posts/effective-dataviz-polars-alta-ski-resort/20250210.html#wrapping-up",
    "title": "Weekend Challenge - Effective Data Visualization with Polars and Matplotlib",
    "section": "Wrapping Up",
    "text": "Wrapping Up\nRecreating this figure with Polars turned out to be more involved than I initially expected. However, the process was incredibly rewarding, as it deepened my understanding of Pandas, Polars, and Matplotlib. Switching between Pandas and Polars required a shift in mindset, but it also reinforced key concepts in both libraries. I look forward to exploring more of these challenges in the future.\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis post was drafted by me, with AI assistance to refine the content."
  }
]